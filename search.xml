<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[2016年BAT公司常见的Web前端面试题整理]]></title>
    <url>%2F2019%2F01%2F21%2F2016%E5%B9%B4BAT%E5%85%AC%E5%8F%B8%E5%B8%B8%E8%A7%81%E7%9A%84Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[2016年BAT公司常见的Web前端面试题整理1.JavaScript是一门什么样的语言，它有哪些特点？ 没有标准答案。 2.JavaScript的数据类型都有什么？ 基本数据类型：String,boolean,Number,Undefined` 引用数据类型：Object(Array,Date,RegExp,Function,Null) 那么问题来了，如何判断某变量是否为数组数据类型？ 方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效 方法二.obj instanceof Array `在某些IE版本中不正确 方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下： 12345if (typeof Array.isArray === "undefined") &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === "[object Array]" &#125;; &#125; 3.已知ID的Input输入框，希望改变文本框的背景颜色，怎么做？(原生JS) 1document.getElementById("id").style.backgroundColor="red"; 4.希望获取到页面中所有的checkbox怎么做？(原生JS) 12345678var domList = document.getElementsByTagName('input'); var checkBoxList = []; var len = domList.length; //缓存到局部变量 while (len--) &#123;//使用while的效率比for高 if (domList[len].type == 'checkbox') &#123; checkBoxList.push(domList[len]); &#125; &#125; 5.Html事件绑定有几种方式？ 直接在DOM里绑定事件： 这种方式称为原生事件或者属性事件 在JS里通过onclick绑定：xxx.onclick = test Dom标准通过事件添加进行绑定：addEventListener(&quot;click&quot;,test, false) //第三个参数为是否支持事件捕捉 IE事件：attachEvent(&quot;onclick&quot;,test) 那么问题来了，Javascript的事件流模型都有什么？ “事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的 目标事件 “事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播 “DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡 IE事件流：目标事件和事件冒泡 阻止事件冒泡的方式： 1234567stopPropagation():function (ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125;else&#123; ev.cancelBubble=true; &#125;&#125; 阻止事件的默认行为： 1234567preventDefault: function (event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue=false; &#125;&#125; 6.看下列代码，将会输出什么?(变量声明提升) 123var a=1;function a()&#123;&#125;alert(a);//打印1 上面的代码经过变量提升后，等价于下面的代码 123var a;function a()&#123;&#125;a=1;//alert(a); 再看下面的输出结果： 123var a=1;var a=function ()&#123;&#125;alert(a)//打印a函数 此时打印a函数，不会打印1，因为下面是一个函数表达式，跟变量声明一样，只会把var a;提升到最前面，a=function(){}保留，会覆盖前面的a=1;因此打印函数。 此题目，我再百度面试的时候问到过。 7.掌握样式的优先级。 !important &gt; style(内联) &gt; Id(权重100) &gt; class(权重10) &gt; 标签（权重1） 同类别的样式，后面的会覆盖前面的。 百度视频部门一道面试题是这样的： 12345&lt;style&gt; .red&#123;color:red;&#125; .blue&#123;color: blue;&#125;&lt;/style&gt;&lt;p class="blue red"&gt;&lt;/p&gt;//后面的覆盖前面的,显示为blue 8.怎样添加、移除、移动、复制、创建和查找节点 1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 9.用js写一个正则匹配标签中是否包含一个class(百度面试题) 12345function hasClassName (id,name) &#123; var cls=document.getElementById(id).className; var reg=new RegExp("(^|\\s"+name+"($|\\s","g"); return reg.test(cls)&#125; 10.事件循环绑定，输出结果（考察闭包） 12345678var list = document.getElementsByTagName("a") //10个a标签for (let i = 0; i &lt; list.length; i++) &#123; list[i].onclick = function (i) &#123; return function () &#123; alert(i); &#125; &#125;&#125; //都打印10 通过闭包封装后的代码： 123456789var list = document.getElementsByTagName("a") //10个a标签for (let i = 0; i &lt; list.length; i++) &#123; list[i].onclick = (function (i) &#123; return function () &#123; alert(i); &#125; &#125;)(i)&#125; //打印对应的索引 闭包我所知道的两个作用： a.通过闭包可以把局部变量传递出来，就是通过闭包可以访问函数内部的变量，比如下面的代码： 1234567891011function count () &#123; var num = 1; return function () &#123; return num++; &#125;&#125;var countFn = count();countFn();//1countFn();//2countFn();//3countFn();//4 通过闭包就可以访问函数内部的局部变量，并且实现数量累加。 b.使用闭包可以避免空间污染，闭包内部的变量都只能在内部使用，这样有效避免和外部变量的混淆。（个人理解） 11.js数组去重。 12345678910111213var arr = [1, 5, 3, 2, 4, 5, 5, 6, 2, 6, 8]var obj = &#123;&#125;, newArr = [];function delrepeat() &#123; for (let i = 0; i &lt; arr.length; i &lt; j; i++) &#123; if (!obj[arr[i]]) &#123; newArr.push(arr[i]) obj[arr[i]] = arr[i] &#125; &#125;&#125; 12.两个div标签，如何控制标签左边固定，右边自适应，左边div标签的宽度为100px（滴滴面试题） 滴滴面试起初问我，现在有并排的三个Div框，如何实现三个div都自适应，我当时就懵了，这个考察的是display:table的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style&gt; html &#123; font-size: 10px; &#125; body &#123; font-size: 1.4rem; &#125; .box &#123; background-color: rgba(200, 200, 200, 0.7); margin: 0 1rem; width: 33.334; padding: 1rem; &#125; .box:nth-child(2) &#123; height: 5rem; background-color: rgba(200, 210, 230, 0.7)1 &#125; .accordant &#123; display: table-row; &#125; .table &#123; width: 100%; display: table &#125; .table .accordant &#123; display: table-row; &#125; .table .accordant .box &#123; display: table-cell; vertical-align: middle; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="table"&gt; &lt;div class="accordant"&gt; &lt;div class="box"&gt; &lt;p&gt;这是一个figure&lt;/p&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;p&gt;这是一个figure&lt;/p&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;p&gt;这是一个figure&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 13.实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制 考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚 考察点2：是否知道如何判断一个变量是什么类型的 考察点3：递归算法的设计 1234567891011121314151617181920212223242526272829//方法一Object.prototype.clone = () =&gt; &#123; var o = this.constructor === Array ? [] : &#123;&#125;; for (const e in this) &#123; o[e] = typeof this[e] === 'object' ? this[e].clone() : this[e] &#125; return o;&#125;//方法二function clone (obj) &#123; var buf; if (obj instanceof Array) &#123; buf = []; var i = obj.length; while (i--) &#123; buf[i]=clone(obj[i]) &#125; return buf; &#125;else if (obj instanceof Object) &#123; buf = &#123;&#125;; for (const key in obj) &#123; buf[key]=clone(obj[key]) &#125; return buf; &#125; else &#123; return obj; &#125;&#125; 14.继承的使用 1234567891011121314151617class Animal &#123; constructor(name) &#123; this.name = name &#125; showName() &#123; console.log(this.name); &#125;&#125;class Dog extends Animal &#123; constructor(name, sex) &#123; super(name); this.sex = 'man' &#125; bark() &#123; console.log('barkiing'); &#125;&#125; 15.请评价以下代码并给出改进意见 1234567891011if (window.addEventListener) &#123; var addListener = function (el, type, listener, userCapture) &#123; el.addEventListener(type, listener, userCapture) &#125;&#125; else if (document.all) &#123; var addListener = function (el, type, listener) &#123; el.attachEvent('on' + type, function () &#123; listener.apply(el) &#125;) &#125;&#125; 评价： 不应该在if和else语句中声明addListener函数，应该提前先声明，定义全局变量； 不需要使用window.addEventListener或document.all来进行检测浏览器，应该使用能力检测； 由于attachEvent在IE中有this指向问题，所以调用它时需要处理一下 改进如下： 试题大全集，程序员收藏了，只发一次！ 123456789function addEvent (elem,type,handler) &#123; if (elem.addEventListener) &#123; elem.addEventListener(type,handler,false) &#125; else if(elem.attachEvent)&#123; elem.attachEvent('on'+type,handler) &#125;else&#123; elem['on'+type]=handler; &#125;&#125; 16.对作用域上下文和this的理解，看下列代码： 123456789var User = &#123; count: 1, getCount() &#123; return this.count; &#125;&#125;;console.log(User.getCount());var func = User.getCount;console.log(func());]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装 Kali Linux 后需要做的 20 件事]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%AE%89%E8%A3%85%20Kali%20Linux%20%E5%90%8E%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%2020%20%E4%BB%B6%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[##安装 Kali Linux 后需要做的 20 件事 专门针对Kali用户 Kali Linux是来自Debian的一个特殊版本，Kali Linux同样存在Debian Linux的许多问题。这部分为读者介绍如何解决那些问题。它们并不是Kali Linux特有的问题，你可以不用理它们；不过我看到错误，强迫症就会发作，非解决错误不可。 实用工具和软件 这部分汇集了我觉得有用的一批实用工具和软件。这些是大多数其他Linux发行版里面也有的日常软件，或者至少我认为它们应作为默认安装系统的一部分而出现。 改进和辅助功能 Kali Linux天生具有启动速度快、占用资源少的特点。但如果你有一些CPU和GPU能力可用，不妨试着让Kali Linix的外观更靓丽一些。 专门针对Kali用户 1. 解决有线网络的”设备无法托管”错误 如果你希望NetworkManager（网络管理器）处理在/etc/network/interfaces中启用的接口，只要在/etc/NetworkManager/NetworkManager.conf中设置managed=true。所以，该文件看起来就像： 1[main] plugins=ifupdown,keyfile [ifupdown] managed=true 请阅读全文：《Debian或Kali Linux中解决有线网络接口的”设备无法托管”错误》。 2. 修复默认的软件库 最简单的办法就是，编辑/etc/apt/sources.list，去掉每一行或在开头用#注释每一行，并添加下面这几行： 1leafpad /etc/apt/sources.list 用下面几行，注释或去掉现有的配置： 1## Regular repositories deb http://http.kali.org/kali kali main non-free contrib deb http://security.kali.org/kali-security kali/updates main contrib non-free ## Source repositories deb-src http://http.kali.org/kali kali main non-free contrib deb-src http://security.kali.org/kali-security kali/updates main contrib non-free 保存并关闭文件。想了解相关细节和介绍，请参阅《添加官方的Kali Linux软件库》一文。 3. 更新、升级和发行版升级 对你安装的Kali进行清洁、更新、升级和发行版升级等处理。 1apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get dist-upgrade -y 4. 解决PulseAudio警告问题 我的Kali经常弹出这个警告信息： 1[warn] PulseAudio configured for per-user sessions ... (warning). Debian变种版本也会在启动过程中弹出类似的警告信息。为了解决这个问题，键入下面这个命令： 1leafpad /etc/default/pulseaudio 找到这一行： 1PULSEAUDIO_SYSTEM_START=0 把0换成1： 1PULSEAUDIO_SYSTEM_START=1 其中，0表示系统模式下不启动PulseAudio，1表示系统模式下启动PulseAudio。 1reboot 想了解相关细节和介绍，请参阅《解决Kali Linux中的PulseAudio configured for per-user sessions …（warning）》一文。 5. 确保启动时发出声音 遵照下列步骤，即可解决Kali Linux中启动时没有声音的问题。 1apt-get install alsa-utils -y 在GNOME桌面（默认是Kali桌面）中： 鼠标右击小小的音量图标，选择Sound Preferences（声音首选项）。 此外，你还可以依次进入到Applications（应用程序）&gt; System Tools（系统工具）&gt; Preferences（首选项）&gt; System Settings（系统设置）&gt; Sound（声音），即可调出同样的选项。 将Output volume（输出音量）滑块切换到ON（打开），类似下面的屏幕截图。这就是你要做的。关闭Sound（声音）窗口。 想了解相关细节和介绍，请参阅《解决Kali Linux中启动时没有声音这个问题》一文。 实用工具和软件 6. 安装Java 进入到下面这个链接，下载jdk7。截至本文截稿时，jdk版本是jdk-7u45-linux-x64。注意：我使用的是x64，即64位版本。32位版本用户应选择相应的版本。这其实不难！ 下面是我使用的方法。截至本文截稿时，可用版本是jdk-7u45-linux-x64.tar.gz。下载该文件，并保存在/root目录中。 1tar -xzvf /root/jdk-7u45-linux-x64.tar.gz mv jdk1.7.0_45 /opt cd /opt/jdk1.7.0_45 这一步将已下载的Java版本登记为替代版本，将其改成作为默认版本来使用： 1update-alternatives --install /usr/bin/java java /opt/jdk1.7.0_45/bin/java 1 update-alternatives --install /usr/bin/javac javac /opt/jdk1.7.0_45/bin/javac 1 update-alternatives --install /usr/lib/mozilla/plugins/libjavaplugin.so mozilla-javaplugin.s /opt/jdk1.7.0_45/jre/lib/amd64/libnpjp2.so 1 update-alternatives --set java /opt/jdk1.7.0_45/bin/java update-alternatives --set javac /opt/jdk1.7.0_45/bin/javac update-alternatives --set mozilla-javaplugin.so /opt/jdk1.7.0_45/jre/lib/amd64/libnpjp2.so 参阅《在Kali Linux中安装Java JDK》一文，即可详细了解逐步操作和测试选项。 7. 安装Flash 这件事情相当简单、容易，对大多数人来说应该没有问题：在终端中，键入这个命令： 1apt-get install flashplugin-nonfree 然后键入： 1update-flashplugin-nonfree - -install 就是这样。你的flash现在应该能够正常工作了。 参阅《在Kali Linux中安装Flash》一文，以便了解逐步操作和测试选项。如果有些人使用上述方法安装失败，该文还给出了Flash手动安装步骤。 8. 安装File Roller（归档管理器） Kali Linux缺少一个真正的GUI归档管理器。使用下面这个命令来安装归档管理器（File Roller）： 1apt-get install unrar unace rar unrar p7zip zip unzip p7zip-full p7zip-rar file-roller -y 现在你可以在Applications（应用程序）&gt; Accessories（附件）&gt; Archive Manager（归档管理器）中找到归档管理器。 9. 添加标准用户 默认情况下，Kali Linux只有root用户。虽然大多数应用程序需要root访问权，但添加第二个用户总归是个好主意。打开终端，键入下面这个命令，即可创建新用户（把user1换成你想要的用户名称）。 1useradd -m user1 （注意：-m意味着创建通常是/home/username的主目录） 现在为该用户设置密码： 1passwd user1 将所需密码输入两次。添加用户到sudo群组（允许用户进行安装软件、允许打印、使用特权模式等操作）。 1usermod -a -G sudo user1 （注意：-a意味着附加或添加，-G意味着指定一个群组/多个群组）。将之前创建的用户的默认外壳改成bash： 1chsh -s /bin/bash user1 想了解更多内容，请参阅这篇详细而深入的文章：《如何在Kali Linux中添加/删除用户（标准用户/非root用户）》，参阅http://www.blackmoreops.com/2013/11/27/how-to-add-remove-user-standard-user-non-root-in-kali-linux/。该文解释了了如何添加用户，而所有的用户目录也已经到位（因而避免了&quot;无法更新.ICEauthority var/lib/gdm3/.ICEauthority”或含有.ICEauthority或一般权限的任何错误。） 10. 添加add-apt-repository Debian让用户可以通过一个名为add-apt-repository的应用程序，添加和使用PPA软件库，不过Kali Linux在其默认的程序包列表中并不含有该应用程序。就Kali而言，由于这是个特殊用途的应用程序，已进行了某些改动，以便让它适用于最擅长的地方（渗透测试）。想通过add-apt-repository应用程序启用PPA软件库，遵照下面几个步骤。 首先安装Python软件属性程序包。 1apt-get install python-software-properties 接下来安装apt-file。 1apt-get install apt-file 更新apt-file。 1apt-file update 这需要一点时间，所以万一你的apt-file更新起来很慢，可能想试试一并解决这个问题。（注意：我的/etc/apt/sources.list文件中有repo.kali.org，而不是http.kali.org。）一旦apt-file更新完毕，你应该能够搜索它了。 1apt-file search add-apt-repository 你的输出结果应该看起来类似这样： 1python-software-properties: /usr/bin/add-apt-repository python-software-properties: /usr/share/man/man1/add-apt-repository.1.gz 位于/usr/bin/add-apt-repository的默认add-apt-repository应用程序适用于Debian。所以，如果你使用Kali，它很可能无法工作。我在本文末尾处添加了一个巧妙的解决办法，如果你喜欢的话，可以在VirtualBox上一下。但我发现，我们完全可以模仿Ubuntu Oneiric，让add-apt-repository正常工作。 1cd /usr/sbin vi add-apt-repository 添加下列代码，并保存文件。 1#!/bin/bash if [ $# -eq 1 ] NM=`uname -a &amp;&amp; date` NAME=`echo $NM | md5sum | cut -f1 -d&quot; &quot;` then ppa_name=`echo &quot;$1&quot; | cut -d&quot;:&quot; -f2 -s` if [ -z &quot;$ppa_name&quot; ] then echo &quot;PPA name not found&quot; echo &quot;Utility to add PPA repositories in your debian machine&quot; echo &quot;$0 ppa:user/ppa-name&quot; else echo &quot;$ppa_name&quot; echo &quot;deb http://ppa.launchpad.net/$ppa_name/ubuntu oneiric main&quot; &gt;&gt; /etc/apt/sources.list apt-get update &gt;&gt; /dev/null 2&gt; /tmp/$&#123;NAME&#125;_apt_add_key.txt key=`cat /tmp/$&#123;NAME&#125;_apt_add_key.txt | cut -d&quot;:&quot; -f6 | cut -d&quot; &quot; -f3` apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $key rm -rf /tmp/$&#123;NAME&#125;_apt_add_key.txt fi else echo &quot;Utility to add PPA repositories in your debian machine&quot; echo &quot;$0 ppa:user/ppa-name&quot; fi 注意：在echo “deb http://ppa.launchpad.net/$ppa_name/ubuntu oneiric main” &gt;&gt; /etc/apt/sources.list这一行中，我使用了Oneiric。你可以根据自己的选择，试着使用Lucid、Raring或Saucy。现在，使用chmod和chown这两个命令，对文件进行相应的操作。 1chmod +x /usr/sbin/add-apt-repository chown root:root /usr/sbin/add-apt-repository 由于我们已添加了正确的代码，我们就可以使用add-apt-repository，添加PPA软件库。我试着输入下面这两个命令，在Kali Linux中添加主题和自定义图标。 1/usr/sbin/add-apt-repository ppa:noobslab/themes /usr/sbin/add-apt-repository ppa:alecive/antigone 我删除了本文中的所有屏幕截图，但如果你想看个清楚，了解具体是如何工作的，建议你参阅《在Kali Linux中添加PPA软件库add-apt-repository》一文，了解更多细节。 11. 安装Tor Tor是自由软件，也是一种开放网络，可以帮助你防御流量分析。流量分析是一种网络监视行为，会危及个人自由和隐私、机密性的商业活动和关系以及国家安全。该指南为你详细介绍了在Kali Linux中安装Tor的步骤。Tor保护你的方法是，通过由全球广大志愿者运营的一个分布式中转网络，传递你的通信内容：它可以防止有人监视你的互联网连接、进而了解你访问哪些网站，它还可以防止你访问的网站了解你的实际位址。 Tor在Kali软件库中就用；想直接从软件库安装它，只要打开终端，键入这个命令： 1apt-get install tor 从命令行启用Tor服务： 1service tor start 使用proxychains命令和Tor，实现安全浏览： 1proxychains iceweasel 为了在本文中确保行文简单，我只显示了使用Tor的一方面。你可以在《在Kali Linux中安装Tor》一文中详细阅读完整细节，详见http://www.blackmoreops.com/2013/12/16/installing-tor-kali-linux/。 12. 安装Filezilla FTP客户端 要是缺少功能完备的FTP客户端，任何Linux安装都谈不上是完整的。Filezilla是最好的FTP客户端，所以使用下面这个命令，安装Filezilla： 1apt-get install filezilla filezilla-common -y 13. 安装HTOP和NetHogs HTOP是个特别的工具，显示了运行中的进程和所使用的内存，包括更多的详细信息。（你也可以使用top命令，但HTOP完全有用得多。）NetHogs也很有用，它按接口显示了应用程序所用的流量。使用下面这个命令，安装这两个工具： 1apt-get install htop nethogs -y 你现在可以使用下面几个命令来运行它们了： 1htop nethogs eth0 nethogs wlan0 你会喜欢使用这些小巧工具的，这点我几乎可以肯定。 14. 为显卡安装专有的驱动程序 你可能需要安装专有的驱动程序，以发掘更多的功能特性，这取决于你使用哪种显卡（ADM还是英伟达）。我写过一篇详细的文章，介绍了如何在Kali Linux中安装AMD ATI专有驱动程序（fglrx）。 英伟达用户完全可以遵照安装英伟达驱动程序的官方说明文档。要是官方说明文档不管用，或者你已无计可施，不妨关注我写过的这另一篇文章：《如何手动安装英伟达二进制驱动程序》。 15. 安装Recordmydesktop和Reminna远程桌面客户端 Recordmydesktop让你能够录制在Kali Linux中的活动，并制作视频。Remmina类似Windows远程桌面客户端。两者都非常实用。可以使用下面这个命令安装它们： 1apt-get install gtk-recordmydesktop recordmydesktop remmina -y 16. 安装GDebi程序包管理器 dpkg是一个功能强大的工具，但它并不自动安装依赖项。为此，我们需要某种程序包安装工具，以便在安装.deb程序包的同时，可以去获取所有必要的依赖项。眼下最出色的程序包安装工具非gdebi莫属。使用下面这个命令来安装它： 1apt-get install gdebi -y 改进和辅助功能 17. 安装主题 安装主题、美化桌面是个好主意。Kali的默认桌面单调而乏味。你可以使用两种不同的方法来更改主题。 手动安装主题 通过PPA软件库安装主题 请阅读此处的细节，即可了解如何在Kali Linux中更改或安装GTK3主题。 18. 安装一种新的桌面环境（我青睐XFCE） 我青睐XFCE桌面，但你可以试着在Kali Linux中安装/删除不同的桌面环境或窗口管理器。根据你的需要，选择下列链接： 1.《如何在Kali Linux中安装/删除XFCE桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-xfce-desktop-environment-in-kali-linux/。 \2. 《如何在Kali Linux中安装/删除不同的KDE桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-different-kde-desktop-environments-in-kali-linux/。 \3. 《如何在Kali Linux中安装/删除LXDE桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-lxde-desktop-environment-in-kali-linux/。 \4. 《如何在Kali Linux中安装/删除GNOME桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-gnome-desktop-environment-on-kali-linux/。 \5. 《如何在Kali Linux中安装/删除Cinnamon桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-cinnamon-desktop-environment-in-kali-linux/。 \6. 《如何在Kali Linux中安装/删除MATE桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-mate-desktop-environment-in-kali-linux/。 最后，遵照这些操作步骤，永久性地更换桌面环境（也就是启动进入到XFCE，而不是GNOME）。 19. 启用自动登录用户 这是个简单的变更。只要打开并编辑名为/etc/gdm3/daemon.conf的文件，假设你在使用GNOME显示管理器（gmd3）作为主要的显示管理器。你可能想要另外也能试一下其他桌面。下面这个链接介绍了《如何在Kali Linux中添加/删除不同的桌面管理器》，详见http://www.blackmoreops.com/2013/10/11/how-to-installremove-different-desktop-environment-or-window-manager-in-kali-linux-1-x/。 1root@kali:~# leafpad /etc/gdm3/daemon.conf 在daemon即守护程序部分，将用于自动登录的那两行代码取消注释。它最后应该看起来像这样： 1[daemon] # Enabling automatic login AutomaticLoginEnable = true AutomaticLogin = root 就是这样，容易得很。要是你想知道如何使用不同于root用户的用户，方法如下： 1[daemon] # Enabling automatic login AutomaticLoginEnable = true AutomaticLogin = myanotheruser 最后但并非最不重要的是，重启系统，核实一下是否管用。（这会管用，因为它是Linux，Kali很出色。） 1reboot 你可能想要采取进一步行动，或者如果你是KDE用户，那么这里的操作步骤介绍了如何在Kali Linux中，系统启动时，让root用户自动登录（GNOME和KDE），详见http://www.blackmoreops.com/2013/12/19/auto-login-root-user-system-start-kali-linux-gnome-kde/。该文还介绍了如何让不同的非root用户实现自动登录，相当方便。 下面这部分解释了如何更充分地发挥你系统的功能，尤其是发挥显卡的功能。 20. 发掘GPU处理的能力 最后但并非最不重要的是，在你试图破解密码时，GPU处理速度要快得多。你可以选择下面介绍的几种方法，具体取决于所使用的显卡： a. AMD显卡 《在Kali Linux 1.x中安装AMD ATI驱动程序（fglrx）》，参阅：http://www.blackmoreops.com/2013/10/22/install-amd-ati-driver-fglrx-in-kali-linux-1-x/。 然后参阅其余指南文章： 《如何在Kali Linux中安装AMD APP SDK？》 《如何在Kali Linux中安装Pyrit？》 《如何在Kali Linux中安装CAL++？》 b. 英伟达显卡 英伟达显卡用户完全可以参阅安装英伟达驱动程序的官方说明文档。如果官方说明文档不管用或者你已无计可施，不妨参阅我写过的另一篇文章，介绍如何手动安装英伟达显卡二进制驱动程序。 《如何在Kali Linux中安装英伟达内核模块Cuda和Pyrit？》，参阅http://www.blackmoreops.com/2013/10/20/how-to-install-nvidia-kernel-module-cuda-and-pyrit/。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery ajax方法]]></title>
    <url>%2F2018%2F02%2F27%2Fjquery%E4%B8%AD%E7%9A%84ajax%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%80%BB%E6%98%AF%E8%AE%B0%E4%B8%8D%E4%BD%8F%EF%BC%8C%E8%BF%99%E9%87%8C%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[jquery中的ajax方法参数总是记不住，这里记录一下。 1.url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。 2.type:要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。 3.timeout:要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。 4.async:要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。 5.cache:要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。 6.data:要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看 processData选项。对象必须为key/value格式，例如{foo1:&quot;bar1&quot;,foo2:&quot;bar2&quot;}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[&quot;bar1&quot;,&quot;bar2&quot;]}转换为&amp;foo=bar1&amp;foo=bar2。 7.dataType:要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：xml：返回XML文档，可用JQuery处理。html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。json：返回JSON数据。jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。text：返回纯文本字符串。 8.beforeSend：要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。 123function(XMLHttpRequest) &#123; this; //调用本次ajax请求时传递的options参数 &#125; 9.complete：要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。 123function(XMLHttpRequest, textStatus) &#123; this; //调用本次ajax请求时传递的options参数 &#125; 10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。​ (1)由服务器返回，并根据dataType参数进行处理后的数据。​ (2)描述状态的字符串。 1234function(data, textStatus)&#123; //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数&#125; 11.error:要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下： 1234function(XMLHttpRequest, textStatus, errorThrown)&#123; //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数&#125; 12.contentType：要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。 13.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。​ 1234function(data, type)&#123; //返回处理后的数据 return data; &#125; 14.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。 1234function(data, type) &#123; //返回处理后的数据 return data; &#125; 15.global：要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。 16.ifModified：要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。 17.jsonp：要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。 18.username：要求为String类型的参数，用于响应HTTP访问认证请求的用户名。 19.password：要求为String类型的参数，用于响应HTTP访问认证请求的密码。 20.processData：要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application/x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。 21.scriptCharset：要求为String类型的参数，只有当请求时dataType为”jsonp”或者”script”，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。 案例代码： 1234567891011121314151617181920$(function()&#123; $('#send').click(function()&#123; $.ajax(&#123; type: "GET", url: "test.json", data: &#123;username:$("#username").val(), content:$("#content").val()&#125;, dataType: "json", success: function(data)&#123; $('#resText').empty(); //清空resText里面的所有内容 var html = ''; $.each(data, function(commentIndex, comment)&#123; html += '&lt;div class="comment"&gt;&lt;h6&gt;' + comment['username'] \+ ':&lt;/h6&gt;&lt;p class="para"' + comment['content'] \+ '&lt;/p&gt;&lt;/div&gt;'; &#125;); $('#resText').html(html); &#125; &#125;); &#125;);&#125;); $.ajax验证登录： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 &lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt; function IbtnEnter_onclick() &#123; checklogin(); return false; &#125; function checklogin() &#123; if ($(&quot;#TxtUserName&quot;).val() == &quot;&quot;) &#123; alert(&quot;用户名不能为空！&quot;); $(&quot;#TxtUserName&quot;).focus(); return false; &#125; if ($(&quot;#TxtPassword&quot;).val() == &quot;&quot;) &#123; alert(&quot;密码不能为空！&quot;); $(&quot;#TxtPassword&quot;).focus(); return false; &#125; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;ajax/Handler.ashx?M=&quot; + Math.random(), data: &quot;username=&quot; + $(&quot;#TxtUserName&quot;).val().toString() + &quot;&amp;pwd=&quot; + $(&quot;#TxtPassword&quot;).val().toString(), success: function (data) &#123; if (data == &quot;1&quot;) &#123; location.href = &quot;index.aspx&quot;; return true; &#125; else &#123; alert(&quot;请确认您输入的用户名或密码输入是否正确！&quot;); $(&quot;#TxtUserName&quot;).val(&quot;&quot;); $(&quot;#TxtPassword&quot;).val(&quot;&quot;); $(&quot;#TxtUserName&quot;).focus(); return false; &#125; &#125; &#125;) &#125; &lt;/script&gt;一般处理程序&lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;Handler&quot; %&gt;using System;using System.Web;using System.Data.SqlClient;using System.Web.SessionState;//继承接口IReadOnlySessionState需要引入的命名空间public class Handler : IHttpHandler, IRequiresSessionState&#123; SqlHelper helper = new SqlHelper(); public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = &quot;text/plain&quot;; string username = context.Request.Params[&quot;username&quot;].ToString().Trim(); string pwd = context.Request.Params[&quot;pwd&quot;].ToString().Trim(); if (username != &quot;&quot; &amp;&amp; pwd != &quot;&quot;) &#123; string sql = @&quot;SELECT * FROM [USER] WHERE USERNAME=&apos;&quot;+username+&quot;&apos; AND PASSWORD=&apos;&quot;+pwd+&quot;&apos; &quot;; if (!helper.Exists(sql)) &#123; context.Response.Write(&quot;0&quot;); &#125; else &#123; SqlDataReader reader = helper.ExecuteReader(sql); while (reader.Read()) &#123; context.Response.Write(&quot;1&quot;); context.Session[&quot;username&quot;] = username.ToString().Trim(); context.Session[&quot;pwd&quot;] = pwd.ToString().Trim(); &#125; &#125; &#125; &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端,js</category>
      </categories>
      <tags>
        <tag>Programming</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cloudsim 配置]]></title>
    <url>%2F2017%2F12%2F29%2Fcloudsim%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[cloudsimCloudSim simulation toolkit works on the basis of porgramatic models that are designed by carefully studying the behaviors of real world cloud system components. These are some of the models of CloudSim: Datacenter, Datacenterbroker, Host, Vm, VmScheduling, VMAllocation, Storage etc, few of these are abstract models and few are defined to its fullest. The abstract models are defined for enabling the extension of these models for user defined simulation scenarios. 配置 cloudsim 配置 cloudsim(Eclipse) 首先要下载 cloudsim 包,下载地址在这里:https://github.com/Cloudslab/cloudsim 下载后解压,把解压后的东西放到 eclipse 的 workspaces,方便使用, 用 eclipse 打开项目,在菜单栏上 File&gt;import导入为一个 maven 项目,它会自动下载 pom.xml 里面的包,大家一般的错误就是缺少相应的依赖包:导入后就出现了项目,等下面的进度条走完就好了, 然后打开实例,直接运行即可 如果导入失败,可以尝试换一个工作区重新导入! console 里面的就是输出结果 配置 cloudsim(idea) 这个比较好配置,直接导入即可 点击 open,打开我们的 cloudsim 文件夹即可 打开后同样需要添加依赖,import changes 就好了添加好后,他已经是一个完整的项目了,可以直接运行 依据 CloudSim 源代码介绍几个核心类：123456789(1)Cloudlet类：构建云环境下的任务。(2)DataCenter类：数据中心，提供虚拟化的网格资源，处理虚拟机信息的查询，包含虚拟机对资源的分配策略，云计算采用VMProvisioner处理虚拟机。(3)DataCenterBroker类：隐藏了虚拟机的管理，如创建、任务提交、虚拟机的销毁等。(4)Host类：扩展了机器对虚拟机除处理单元(PE)之外的参数分配策略，如带宽、存储空间、内存等，一台Host可对应多台虚拟机。(5)VirtualMachine类：虚拟机类，运行在Host上，与其它虚拟机共享资源，每台虚拟机由一个拥有者所有，可提交任务，并由VMScheduler类定制该虚拟机的调度策略。(6)VMScheduler类：虚拟机的调度策略，用来管理执行任务，实现了任务接口。(7)VMCharacteristics类：提供虚拟机描述。(8)VMMAllocationPolicy类：虚拟机监视器策略类，描述同一Host上的多台虚拟机共享资源的策略。(9)VMProvisioner类：实现数据中心的主机到虚拟机的映射。 1)CloudInformationService.java（org.cloudbus.cloudsim.core） Cloudsim 中最重要的类之一，它在 CloudSim 的仿真过程中保存资源列表（在现实生活中作为数据库）。这个类实现了 processEvent（SimEvent）方法，在模拟过程中，它处理七个离散类别的事件。如果仔细分析所有基本示例，将调用 CloudSim.Init（）方法，该方法将初始化 CloudInformationService 类的实例。这个类实例提供的基本服务将注册新的资源，索引和它们的发现。 2) DataCenter.java（org.cloudbus.cloudsim）该类通过持有主机，处理元素（Pe）和存储为列表的实例来模仿真实数据中心的基础架构功能。同时，为了方便您的模型和地理位置的可用性，它将初始化 DataCenterCharacteristics。这个类还实现了自己的 processEvent（SimEvent）方法，在模拟过程中，它处理了二十七个默认离散事件类别，如资源信息收集，虚拟机生命周期，云端提交状态等。 3) DataCenterBroker.java（org.cloudbus.cloudsim）4) CloudSimShutdown.java（org.cloudbus.cloudsim.core）5) NetDatacenterBroker.java（org.cloudbus.cloudsim.network.datacenter）6) Switch.java（org.cloudbus.cloudsim.network.datacenter） 在这里，在CloudSim文件夹中，有以下文件夹： 例子：这个文件夹还包含了各种基于场景的用例，这个基本上是一个非常简单的实现来演示如何使用这个模拟引擎。这些示例包含各种用例，从基于虚拟机的数据中心开始，模仿使用功耗感知模型有效处理其操作的真正数据中心的实际配置。所有这些例子都被归类为以下包/名称空间： org.cloudbus.cloudsim.examples：与生成基础级别基础结构实现有关的基本示例。 org.cloudbus.cloudsim.examples.network：包含与基于拓扑的数据中心模拟相关的各种使用案例。 org.cloudbus.cloudsim.examples.network.datacenter：这个包支持“org.cloudbus.cloudsim.examples.network”这个软件包，并附加了一些模仿网络支持云系统数据中心的类。 org.cloudbus.cloudsim.examples.power：包含与功耗感知用例相关的实现，是cloudsim功耗感知模型实现最有趣的实现之一。 org.cloudbus.cloudsim.examples.power.random：包含用于支持数据中心中的绿色计算概念的各种Power模型的实现。 org.cloudbus.cloudsim.examples.power.planetlab：这也包含类似的功率模型实现，但是用来测试仿真的数据是从planetlab中获得的。这意味着这套示例可以处理真实的数据。 workload.planetlab：这个软件包包含了来自地球实验室的所有数据，它是一个数据明智的数据。这进一步被’org.cloudbus.cloudsim.examples.power.planetlab’包中定义的例子所消耗。 来源：该文件夹包含所有的模型类，支持cloudsim的模拟过程。这些模型根据其属性和行为进一步在各种包/名称空间中进行结构化。以下是可用的软件包： org.cloudbus.cloudsim：包含与CPU，RAM，网络带宽等相关的DataCenter，Broker，Host，CPU，存储，资源，分配策略和利用模型相关的类的集合。 org.cloudbus.cloudsim.core：包含云模拟引擎的支柱类，包括事件调度执行引擎，实体库定义，云信息服务等。 org.cloudbus.cloudsim.core.predicates：这些类用于启用事件比较以及执行相应的事件。 org.cloudbus.cloudsim.distributions：包含模拟过程中使用的各种标准数学分布的实现。 org.cloudbus.cloudsim.lists：包含在主机，虚拟机，虚拟机等列表上执行的操作的实现。 org.cloudbus.cloudsim.network：包含几个路由算法的实现，如：FloydWarshall，BRITE等 org.cloudbus.cloudsim.network.datacenter：包含基于基于网络的数据中心模拟的与模型有关的类的实现。 org.cloudbus.cloudsim.power：包含与功耗感知模型相关的数据中心，代理，主机，虚拟机和分配策略的扩展实现 org.cloudbus.cloudsim.power.lists：仅包含启用了功耗感知数据中心模型的虚拟机的实现 org.cloudbus.cloudsim.power.models：包含市场上可用的各种CPU模型的实现，并用于各种现实生活中的数据中心提供商。 org.cloudbus.cloudsim.provisioners：包含CPU，RAM，带宽的供应程序的实施。 org.cloudbus.cloudsim.util：包含在仿真过程中用于某些计算目的的一组类。 CloudSimExample1 包含以下属性的声明和定义： CloudletList：List 类型的静态变量。通过仿真过程它将包含云类的所有实例的列表。该列表被提交给 DataCenterBroker 的实例，以便分配给特定的 VM 用于执行目的。 vmlist：一个 List 类型的静态变量，在模拟过程中，它将包含 Vm 类的所有实例的列表。该列表还将被提交给 DataCenterBroker 的实例以分配用于执行的云实例。云块到 Vm 的映射可以是随机的或特定的。这取决于用例实现。 createBroker（）：此方法将创建并返回 DataCenterBroker 的实例。这个方法在 main 方法里面调用也是一个静态的方法。 createDatacenter(String):该方法包含定义 DataCenter 配置的实现，该配置将用于在仿真过程中处理云的执行。此方法将数据中心名称作为名称，仅用于识别目的。在这个方法中，只有 DataCenterCharateristics 被定义了哪个实例实例化主机列表以及处理元素列表。这些列表以及存储列表，分配策略和 DataCenterCharacteristics 的实例将创建 DataCenter 实例并返回到主方法调用。 printCloudletList(List):一旦模拟结束，此方法用于打印模拟结果。 main(string args[])：这个方法是一旦你点击运行按钮就被调用的第一个方法。此方法包含执行下面提到的所有步骤，并按顺序执行。此方法根据执行中的步骤在需要的时候向特定的方法发送一个调用。以下步骤解释了每个步骤及其代码： 第一步:Cloudsim 仿真将被初始化以进行仿真，并且这个仿真需要下面的信息来启动： number of user, calendar instance traceflag value. 所有这些参数都需要初始化 Cloudsim 仿真过程，CloudSim.init()方法初始化并发送一个调用来创建一个 CloudInfromationService 实例（创建第一个实体）。下面的代码用于此： 1234int num_user = 1; // number of cloud users defined staticallyCalendar calendar = Calendar.getInstance();boolean trace_flag = false; // mean trace eventsCloudSim.init(num_user, calendar, trace_flag);//初始化CloudSim工具包，它应该在创建任何实体之前调用 第二步一个数据中心实例将被创建，这是通过一个单独的CreateDataCenter 完成的，这个实例创建了处理元素，主机，存储，成本和数据中心特性的实例。 1Datacenter datacenter0 = createDatacenter("Datacenter_0"); 这反过来将调用发送到 createDatacenter（）方法的以下定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static Datacenter createDatacenter(String name) &#123; // 1.创建列表用于储存机器，简称主机列表 List&lt;Host&gt; hostList = new ArrayList&lt;Host&gt;(); // 2. 创建主机包含的PE或者CPU处理器列表 List&lt;Pe&gt; peList = new ArrayList&lt;Pe&gt;(); int mips = 1000; // 3. 创建处理器，并添加到Pe列表中 peList.add(new Pe(0, new PeProvisionerSimple(mips))); int hostId = 0; int ram = 2048; // long storage = 1000000; //主机容量 int bw = 10000; // 4. 创建主机，并将其添加至主机列表 hostList.add( new Host(hostId, new RamProvisionerSimple(ram),//内存提供者，为虚拟机提供内存 new BwProvisionerSimple(bw),//带宽提供者 storage, peList, new VmSchedulerTimeShared(peList)//时间共享的VM调度 )); String arch = "x86"; // system architecture String os = "Linux"; // operating system String vmm = "Xen"; double time_zone = 10.0; // time zone this resource located double cost = 3.0; // the cost of using processing in this resource double costPerMem = 0.05; // the cost of using memory in this resource double costPerStorage = 0.001; // the cost of using storage in this resource double costPerBw = 0.0; // the cost of using bw in this resource // we are not adding SAN devices by no LinkedList&lt;Storage&gt; storageList = new LinkedList&lt;Storage&gt;();// 创建数据中心特征，它表示了数据中心的资源的静态属性，比如：体系结构，操作系统，主机列表，分配策略，时间或空间共享，时区，价格 DatacenterCharacteristics characteristics = new DatacenterCharacteristics(arch, os, vmm,hostList, time_zone,cost,costPerMem,costPerStorage, costPerBw);// .最后，创建Power-aware数据中心 Datacenter datacenter = null; try &#123; datacenter = new Datacenter(name, characteristics, new VmAllocationPolicySimple(hostList), storageList, 0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return datacenter;&#125; 第三步一个 Datacenterbroker 实例被创建，创建代理 1DatacenterBroker broker = createBroker(); 这反过来将调用发送到 createBroker（）方法的以下定义： 1234567891011private static DatacenterBroker createBroker()&#123; DatacenterBroker broker = null; try &#123; broker = new DatacenterBroker("Broker"); &#125; catch (Exception e) &#123; e.printStackTrace(); return null;//in case of error it will return null object. &#125; return broker;&#125; 第四步创建一个虚拟机列表，然后再创建一个虚拟机，并将虚拟机添加到虚拟机列表中，然后将虚拟机列表提交到数据中心代理中 1234567891011121314151617// Virtual Machine parameter descriptionint vmid = 0;int mips = 1000;long size = 10000; // image size (MB)int ram = 512; // vm memory (MB)long bw = 1000;int pesNumber = 1; // number of cpusString vmm = "Xen"; // VMM name// create VM model class instanceVm vm = new Vm(vmid,brokerId, mips, pesNumber, ram, bw, size, vmm, new CloudletSchedulerTimeShared());// add the VM to the vmList, which was declared in start of the class as class variablevmlist.add(vm);// submit vm list to the broker instance created in step 3.broker.submitVmList(vmlist); 第五步创建云任务列表，创建云任务，将云任务添加到列表中，将云任务列表提交给数据中心代理 123456789101112131415161718192021222324252627// Cloudlet propertiesint id = 0;long length = 400000;// estimated instruction length of your workloadlong fileSize = 300;// input size of the file used for the calculation of bandwidthlong outputSize = 300;//output size of the file used for the calculation of bandwidth//this defines how much compute capacity of allocated resource can be consumed by a cloudlet.UtilizationModel utilizationModel = new UtilizationModelFull();//New instance of cloudlet is createdCloudlet cloudlet = new Cloudlet(id, length, pesNumber, fileSize, outputSize, utilizationModel, utilizationModel, utilizationModel);//set to be executed through the specific brokercloudlet.setUserId(brokerId);/*Defines on which VM does this cloudlet is going to be executed during the simulation.The vmid used here is the one defined during step 4.*/cloudlet.setVmId(vmid);// add the cloudlet to the listcloudletList.add(cloudlet);// submit cloudlet list to the brokerbroker.submitCloudletList\(cloudletList\); 第六步开始模拟，结束模拟1234567891011121314151617/*Simulation started here after all teh configurations are set.The method calls initiate all the entities and their eventsare started scheduling, then each event entity processesits scheduled tasks. Once all the scheduled tasks are overthe call for this method is over.*/CloudSim.startSimulation();/*Once the startsimulation() method call is over andit there is no error occured then immdeiatly afterthat the stopsimulation() method is call.This method is going to stop all the entitiesand returns the control to main method.*/CloudSim.stopSimulation(); 第七步输出结果 123//Final step: Print results when simulation is overList&lt;Cloudlet&gt; newList = broker.getCloudletReceivedList();printCloudletList(newList); 这反过来调用 printCloudletList 方法，如下所示： 12345678910111213141516171819202122232425262728293031private static void printCloudletList(List&lt;Cloudlet&gt; list)&#123; int size = list.size(); Cloudlet cloudlet; String indent = " "; Log.printLine(); Log.printLine("========== OUTPUT =========="); Log.printLine("Cloudlet ID" + indent + "STATUS" + indent + "Data center ID" + indent + "VM ID" + indent + "Time" + indent + "Start Time" + indent + "Finish Time"+ indent + "End Waiting Time"); DecimalFormat dft = new DecimalFormat("###.##"); for (int i = 0; i &lt; size; i++) &#123; cloudlet = list.get(i); Log.print(indent + cloudlet.getCloudletId() + indent + indent); if (cloudlet.getCloudletStatus() == Cloudlet.SUCCESS) &#123; Log.print("SUCCESS"); Log.printLine(indent + indent + cloudlet.getResourceId() + indent + indent + indent + cloudlet.getVmId() + indent + indent + dft.format(cloudlet.getActualCPUTime()) + indent + indent + dft.format(cloudlet.getExecStartTime()) + indent + indent + dft.format(cloudlet.getFinishTime())+ indent + indent + cloudlet.getUtilizationModelCpu()); &#125; &#125;&#125; 这最终打印出云资源在其各自资源（即 DataCenter，Broker，虚拟机等）上的执行状态。在模拟过程中，状态日志会在各种情况下打印，完整的日志可能与“ CloudSimExample1.java ” 类似。 12345678910111213141516171819202122232425Starting CloudSimExample1... Initialising... Starting CloudSim version 3.0 Datacenter\_0 is starting... Broker is starting... Entities started. 0.0: Broker: Cloud Resource List received with 1 resource\(s\) 0.0: Broker: Trying to Create VM \#0 in Datacenter\_0 0.1: Broker: VM \#0 has been created in Datacenter \#2, Host \#0 0.1: Broker: Sending cloudlet 0 to VM \#0 400.1: Broker: Cloudlet 0 received 400.1: Broker: All Cloudlets executed. Finishing... 400.1: Broker: Destroying VM \#0 Broker is shutting down... Simulation: No more future events CloudInformationService: Notify all CloudSim entities for shutting down. Datacenter\_0 is shutting down... Broker is shutting down... Simulation completed. Simulation completed.========== OUTPUT ========== Cloudlet ID STATUS Data center ID VM ID Time Start Time Finish Time 0 SUCCESS 2 0 400 0.1 400.1 CloudSimExample1 finished! CloudSim 的拓展(ps:算法来自网络)CloudSim 主要是对真实的云环境的一种模拟仿真，其各个类分别模拟了云计算的资源分配的各个过程，包括虚拟机向物理机的分配过程，计算任务向虚拟机的分配过程等等，这些分配策略分别在不同的 class 中进行了描述。由于 CloudSim 只是搭建了一个云数据中心的框架，因此具体的分配策略需要我们自己去实现，也就需要去在相应的 Class 中添加自己的策略函数。在 CloudSim 给的 examples 中，给运任务分配虚拟机的时候，使用的函数是broker.bindCloudletToVm(cloudlet1.getCloudletId(),vm1.getId());,我们可以跟进去发现，该函数是在DatacenterBroker.java中，该函数使用的是直接绑定的策略，即程序中指定了云任务和虚拟机的绑定方式，如果我们需要使用自己的分配策略，就得在 DatacenterBroker.java 中添加自己的分配策略函数。下面分别使用两种分配策略对云任务进行分配虚拟机，分别为顺序分配策略和贪心分配策略： 顺序分配策略在 DatacenterBroker 类中实现方法 bindCloudletsToVmsSimple()：用于把一组任务顺序分配给一组虚拟机，当所有的虚拟机都运行有任务后，再从第一个虚拟机开始重头分配任务。 123456789public void bindCloudletsToVmsSimple() &#123; int vmNum = vmList.size(); int cloudletNum = cloudletList.size(); int idx = 0; for (int i = 0; i &lt; cloudletNum; i++) &#123; cloudletList.get(i).setVmId(vmList.get(idx).getId()); idx = (idx + 1) % vmNum; &#125; &#125; 贪心策略在DatacenterBroker类中实现方法bindCloudletsToVmsTimeAwared()：定义一个矩阵 time[i][j]，表示任务 i 在虚拟机 j 上所需的执行时间。在初始化矩阵 time 前，首先将任务按 MI 的大小降序排序，将虚拟机按 MIPS 的大小升序排列。从矩阵中行号为 0 的任务开始，每次都尝试分配给最后一列对应的虚拟机，如果该选择相对于其他选择是最优的，就完成分配，否则将任务分配给使当前结果最优的虚拟机。同时，如果有多种分配方法都能使当前结果最优，则将任务分配给运行任务最少的虚拟机。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public void bindCloudletsToVmsTimeAwared() &#123; int cloudletNum = cloudletList.size(); int vmNum = vmList.size(); // time[i][j] 表示任务i在虚拟机j上的执行时间 double[][] time = new double[cloudletNum][vmNum]; // cloudletList按MI降序排列, vm按MIPS升序排列 Collections.sort(cloudletList, new CloudletComparator()); Collections.sort(vmList, new VmComparator()); // ////////For test////////////////////////////////// System.out.println("///////////For test///////////////"); for (int i = 0; i &lt; cloudletNum; i++) &#123; System.out.print(cloudletList.get(i).getCloudletId() + ":" + cloudletList.get(i).getCloudletLength() + " "); &#125; System.out.println(); for (int i = 0; i &lt; vmNum; i++) &#123; System.out.print(vmList.get(i).getId() + ":" + vmList.get(i).getMips() + " "); &#125; System.out.println(); System.out.println("//////////////////////////////////"); // //////////////////////////////////////////////////////////////////// for (int i = 0; i &lt; cloudletNum; i++) &#123; for (int j = 0; j &lt; vmNum; j++) &#123; time[i][j] = (double) cloudletList.get(i).getCloudletLength() / vmList.get(j).getMips(); System.out.print("time[" + i + "][" + j + "]=" + time[i][j] + " "); // For test &#125; System.out.println(); // For test &#125; double[] vmLoad = new double[vmNum];// 在某个虚拟机上任务的总执行时间 int[] vmTasks = new int[vmNum]; // 在某个Vm上运行的任务数量 double minLoad = 0;// 记录当前任务分配方式的最优值 int idx = 0;// 记录当前任务最优分配方式对应的虚拟机列号 // 第一个cloudlet分配给最快的vm vmLoad[vmNum - 1] = time[0][vmNum - 1]; vmTasks[vmNum - 1] = 1; cloudletList.get(0).setVmId(vmList.get(vmNum - 1).getId()); for (int i = 1; i &lt; cloudletNum; i++) &#123; minLoad = vmLoad[vmNum - 1] + time[i][vmNum - 1]; idx = vmNum - 1; for (int j = vmNum - 2; j &gt;= 0; j--) &#123; // 如果当前虚拟机未分配任务，则比较完当前任务分配给该虚拟机是否最优 if (vmLoad[j] == 0) &#123; if (minLoad &gt;= time[i][j]) idx = j; break; &#125; if (minLoad &gt; vmLoad[j] + time[i][j]) &#123; minLoad = vmLoad[j] + time[i][j]; idx = j; &#125; // 简单的负载均衡 else if (minLoad == vmLoad[j] + time[i][j] &amp;&amp; vmTasks[j] &lt; vmTasks[idx]) idx = j; &#125; vmLoad[idx] += time[i][idx]; vmTasks[idx]++; cloudletList.get(i).setVmId(vmList.get(idx).getId()); System.out.print(i + "th " + "vmLoad[" + idx + "]=" + vmLoad[idx] + "minLoad=" + minLoad); System.out.println(); &#125; &#125; 如果想实现自定义任务绑定，可以自行编写 CloudletList-&gt;VmList 的映射函数，以某种方式完成任务列表中的所有 Cloudlet 的绑定工作。然后在模拟程序中，vm 列表和 cloudlet 列表提交之后调用该自定义函数，即可完成所有任务的绑定（这样自然就不需要自带的轮转法代劳了）。下面采用一种改进型轮转法来绑定任务，长任务尽量优先分配到高性能 VM 上。 插入到 DatacenterBroker 类中 1234567891011121314151617181920212223242526272829303132import java.util.Collections;import java.util.Comparatorpublic void bindCloudletsToVmsRRImproved()&#123;int vmNum=vmList.size();int cloudletNum=cloudletList.size();// 任务按指令长度降序，Vm按性能降序，需要导入包 java.util.CollectionsCollections.sort(cloudletList, new CloudletComparator()); Collections.sort(vmList, new VmComparator());int idx=0;for(int i=0;i&lt;cloudletNum;i++) &#123; //将任务绑定到指定 id 的虚拟机，按Round-Robin轮转法 bindCloudletToVm(vmList.get(idx).getId(), cloudletList.get(i).getCloudletId()) idx=(idx+1)%vmNum; //循环遍历虚拟机&#125;&#125;//根据指令长度降序排列任务，需要导入包 java.util.Comparatorprivate class CloudletComparator implements Comparator&lt;Cloudlet&gt;&#123;public int compare(Cloudlet cl1,Cloudlet cl2)&#123;return (int)(c12.getCloudletLength()-cl1. getCloudletLength());&#125;&#125;//根据执行速度降序排列虚拟机private class VmComparator implements Comparator&lt;Vm&gt;&#123; @Override public int compare(Vm vm1, Vm vm2) &#123; return (int) (vm2.getMips() - vm1.getMips()); &#125;&#125; 写完两个分配策略函数，后面可以写一个测试函数，分别对这两种分配策略进行仿真实验，并进行对比。在org.cloudbus.cloudsim.examples中，写一个自己的MyAllocationTest类，其源码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223public class MyAllocationTest &#123; /** The cloudlet list. */ private static List&lt;Cloudlet&gt; cloudletList; private static int cloudletNum = 10; /** The vmlist. */ private static List&lt;Vm&gt; vmlist; private static int vmNum = 5; /** * Creates main() to run this example */ public static void main(String[] args) &#123; Log.printLine("Starting TestAllocation..."); try &#123; // First step: Initialize the CloudSim package. It should be called // before creating any entities. int num_user = 1; // number of cloud users Calendar calendar = Calendar.getInstance(); boolean trace_flag = false; // mean trace events // Initialize the CloudSim library CloudSim.init(num_user, calendar, trace_flag); // Second step: Create Datacenters /* * Datacenters are the resource providers in CloudSim. We need at list one of * them to run a CloudSim simulation */ Datacenter datacenter0 = createDatacenter("Datacenter_0"); //Third step: Create Broker DatacenterBroker broker = createBroker(); int brokerId = broker.getId(); //VM description int vmid = 0; int[] mipss = new int[]&#123;278,289,132,209,286&#125;; long size = 10000; int ram = 256; long bw = 1000; int pesNumber = 1; String vmm = "Xen"; //Fourth step: Create one virtual machine vmlist = new ArrayList&lt;Vm&gt;(); for(int i=0;i&lt;vmNum;i++)&#123; vmlist.add(new Vm(vmid,brokerId,mipss[i],pesNumber, ram,bw,size,vmm,new CloudletSchedulerSpaceShared())); vmid++; &#125; //submit vm list to the broker broker.submitVmList(vmlist); //Cloudlet properties int id = 0; long[] lengths = new long[]&#123;19365,49809,32018,44157,16754, 18336,20045,31493,30727,31017&#125;; long fileSize = 300; long outputSize = 300; UtilizationModel utilizationModel = new UtilizationModelFull(); //Fifth step: Create two Cloudlets cloudletList = new ArrayList&lt;Cloudlet&gt;(); for(int i = 0;i &lt; cloudletNum;i++)&#123; Cloudlet cloudlet = new Cloudlet(id,lengths[i],pesNumber,fileSize, outputSize,utilizationModel,utilizationModel,utilizationModel); //add the cloudlets to the list cloudlet.setUserId(brokerId); cloudletList.add(cloudlet); id++; &#125; //submit cloudlet list to the broker broker.submitCloudletList(cloudletList); //bind the cloudlets to the vms. This way, the broker // will submit the bound cloudlets only to the specific VM // 下面是顺序算法 broker.bindCloudletsToVmsSimple(); broker.bindCloudletsToVmsSimple(); // 下面是贪心算法broker.bindCloudletsToVmsTimeAwared(); //broker.bindCloudletsToVmsTimeAwared(); // Sixth step: Starts the simulation CloudSim.startSimulation(); // Final step: Print results when simulation is over List&lt;Cloudlet&gt; newList = broker.getCloudletReceivedList(); CloudSim.stopSimulation(); printCloudletList(newList); //Print the debt of each user to each datacenter //datacenter0; Log.printLine("TestAllocation finished!"); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.printLine("Unwanted errors happen"); &#125; &#125; /** * * @Title: createDatacenter * @Description: TODO * @param: @param name * @param: @return * @return: Datacenter * @Date: May 17, 20167:16:32 PM */ private static Datacenter createDatacenter(String name)&#123; // Here are the steps needed to create a PowerDatacenter: // 1. We need to create a list to store // our machine List&lt;Host&gt; hostList = new ArrayList&lt;Host&gt;(); // PE and its properties int mips = 1000; int hostId=0; int ram = 2048; //host memory (MB) long storage = 1000000; //host storage int bw = 10000; // 2. A Machine contains one or more PEs or CPUs/Cores. List&lt;Pe&gt; peList = new ArrayList&lt;Pe&gt;(); // 3. Create PEs and add these into a list. peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating //4. Create Host with its id and list of PEs and add them to the list of machines hostList.add( new Host( hostId, new RamProvisionerSimple(ram), new BwProvisionerSimple(bw), storage, peList, new VmSchedulerTimeShared(peList) ) ); // This is our machine // 5. Create a DatacenterCharacteristics object that stores the // properties of a data center: architecture, OS, list of // Machines, allocation policy: time- or space-shared, time zone // and its price (G$/Pe time unit). String arch = "x86"; // system architecture String os = "Linux"; // operating system String vmm = "Xen"; double time_zone = 10.0; // time zone this resource located double cost = 3.0; // the cost of using processing in this resource double costPerMem = 0.05; // the cost of using memory in this resource double costPerStorage = 0.001; // the cost of using storage in this resource double costPerBw = 0.0; // the cost of using bw in this resource LinkedList&lt;Storage&gt; storageList = new LinkedList&lt;Storage&gt;(); //we are not adding SAN devices by now //创建数据中心特征对象 DatacenterCharacteristics characteristics = new DatacenterCharacteristics( arch, os, vmm, hostList, time_zone, cost, costPerMem, costPerStorage, costPerBw); // 6. Finally, we need to create a PowerDatacenter object. Datacenter datacenter = null; try &#123; datacenter = new Datacenter(name, characteristics, new VmAllocationPolicySimple(hostList), storageList, 0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return datacenter; &#125; /* * We strongly encourage users to develop their own broker policies, to submit vms and cloudlets * according to the specific rules of the simulated scenario */ /** * * @Title: createBroker * @Description: TODO * @param: @return * @return: DatacenterBroker * @Date: May 17, 20167:17:32 PM */ private static DatacenterBroker createBroker() &#123; DatacenterBroker broker = null; try &#123; broker = new DatacenterBroker("Broker"); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; return broker; &#125; private static void printCloudletList(List&lt;Cloudlet&gt; list) &#123; int size = list.size(); Cloudlet cloudlet; String indent = " "; Log.printLine(); Log.printLine("========== OUTPUT =========="); Log.printLine("CloudletID" + indent + "STATUS" + indent + "DatacenterID" + indent + "VMID" + indent + "Time" + indent + "StartTime" + indent + "FinishTime"); DecimalFormat dft = new DecimalFormat("###.##"); for (int i = 0; i &lt; size; i++) &#123; cloudlet = list.get(i); Log.print(indent + cloudlet.getCloudletId() + indent + indent); if (cloudlet.getCloudletStatus() == Cloudlet.SUCCESS) &#123; Log.print("SUCCESS"); Log.printLine( indent + indent + cloudlet.getResourceId() + indent + indent + indent + cloudlet.getVmId() + indent + indent + dft.format(cloudlet.getActualCPUTime()) + indent + indent + dft.format(cloudlet.getExecStartTime())+ indent + indent + dft.format(cloudlet.getFinishTime())); &#125; &#125; &#125;&#125; 在主函数中，分别调用函数broker.bindCloudletsToVmsSimple()和broker.bindCloudletsToVmsTimeAwared()，表示分别启动顺序分配策略和贪心策略，其运行结果分别为： 贪心算法见下一篇博客]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>电脑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2017%2F12%2F29%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[贪心算法总结贪心算法贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 基本思路 建立数学模型来描述问题； 把求解的问题分成若干个子问题； 对每一子问题求解，得到子问题的局部最优解； 把子问题的解局部最优解合成原来解问题的一个解。 算法实现 从问题的某个初始解出发。 采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模。 将所有部分解综合起来，得到问题的最终解。 实例分析实例 1 背包问题 问题描述有一个背包，背包容量是 M=150。有 7 个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。 ​ ​ 问题分析 ​ 1.目标函数： ∑pi 最大，使得装入背包中的所有物品 pi 的价值加起来最大。 ​ 2.约束条件：装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150) ​ 3.贪心策略： 选择价值最大的物品 选择价值最大的物品 选择单位重量价值最大的物品有三个物品 A,B,C，其重量分别为{30,10,20}，价值分别为{60,30,80}，背包的容量为 50，分别应用三种贪心策略装入背包的物品和获得的价值如下图所示： 三种策略 算法设计： 计算出每个物品单位重量的价值 按单位价值从大到小将物品排序 根据背包当前所剩容量选取物品 如果背包的容量大于当前物品的重量，那么就将当前物品装进去。否则，那么就将当前物品舍去，然后跳出循环结束。 代码实现 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef struct&#123; int w; int v; double avg;&#125;P;bool cmp(P a,P b)&#123; return a.avg&gt;b.avg;&#125;int main()&#123; P *p; int n,i,m;//n 物品个数 m背包容量 while(cin&gt;&gt;n&gt;&gt;m)&#123; p=new P[n]; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;p[i].w&gt;&gt;p[i].v; p[i].avg=p[i].v/p[i].w*1.0; &#125; sort(p,p+n,cmp); int maxvalue=0; for(i=0;i&lt;n;i++)&#123; if(p[i].w&lt;=m)&#123; m-=p[i].w; maxvalue+=p[i].v; &#125;else&#123; break; &#125; &#125; cout&lt;&lt;maxvalue&lt;&lt;endl; &#125; return 0;&#125; 运行结果 ​ ​ 实例 2 活动安排问题 问题描述：设有 n 个活动的集合 E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 i 都有一个要求使用该资源的起始时间 si 和一个结束时间 fi,且 si &lt;fi 。要求设计程序，使得安排的活动最多。 (ps:活动结束时间按从小到大排序) 问题分析：活动安排问题要求安排一系列争用某一公共资源的活动。用贪心算法可提供一个简单、漂亮的方法，使尽可能多的活动能兼容的使用公共资源。设有 n 个活动的集合｛0，1，2，…，n-1｝，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 i 都有一个要求使用该资源的起始时间 starti 和一个结束时间 endi，且 starti&lt;endi。如选择了活动 i，则它在半开时间区间[starti,endi）内占用资源。若区间[starti,endi)与区间[startj,endj)不相交，称活动 i 与活动 j 是相容的。也就是说，当 startj≥endi 或 starti≥endj 时，活动 i 与活动 j 相容。活动安排问题就是在所给的活动集合中选出最多的不相容活动。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。该问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。 算法设计：若被检查的活动 i 的开始时间 starti 小于最近选择的活动 j 的结束时间 endj，则不选择活动 i，否则选择活动 i 加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需 O(n)的时间安排 n 个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用 O(nlogn)的时间重排。 代码实现：代码 1 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct actime&#123; int start,finish;&#125;act[1002];bool cmp(actime a,actime b)&#123; return a.finish&lt;b.finish;&#125;int main()&#123; int i,n,t,total; while(cin&gt;&gt;n)&#123;//活动的个数 for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;act[i].start&gt;&gt;act[i].finish; &#125; sort(act,act+n,cmp);//按活动结束时间从小到大排序 t=-1; total=0; for(i=0;i&lt;n;i++)&#123; if(t&lt;=act[i].start)&#123; total++; t=act[i].finish; &#125; &#125; cout&lt;&lt;total&lt;&lt;endl; &#125; return 0;&#125; 运行结果 1 ​ ​ 代码 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;template&lt;class Type&gt;void GreedySelector(int n, Type s[], Type f[], bool A[]);const int N = 11;int main()&#123; //下标从1开始,存储活动开始时间 int s[] = &#123;0,1,3,0,5,3,5,6,8,8,2,12&#125;; //下标从1开始,存储活动结束时间 int f[] = &#123;0,4,5,6,7,8,9,10,11,12,13,14&#125;; bool A[N+1]; cout&lt;&lt;&quot;各活动的开始时间,结束时间分别为：&quot;&lt;&lt;endl; for(int i=1;i&lt;=N;i++) &#123; cout&lt;&lt;&quot;[&quot;&lt;&lt;i&lt;&lt;&quot;]:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;s[i]&lt;&lt;&quot;,&quot;&lt;&lt;f[i]&lt;&lt;&quot;)&quot;&lt;&lt;endl; &#125; GreedySelector(N,s,f,A); cout&lt;&lt;&quot;最大相容活动子集为：&quot;&lt;&lt;endl; for(int i=1;i&lt;=N;i++) &#123; if(A[i])&#123; cout&lt;&lt;&quot;[&quot;&lt;&lt;i&lt;&lt;&quot;]:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;s[i]&lt;&lt;&quot;,&quot;&lt;&lt;f[i]&lt;&lt;&quot;)&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125;template&lt;class Type&gt;void GreedySelector(int n, Type s[], Type f[], bool A[])&#123; A[1]=true; int j=1;//记录最近一次加入A中的活动 for (int i=2;i&lt;=n;i++)//依次检查活动i是否与当前已选择的活动相容 &#123; if (s[i]&gt;=f[j]) &#123; A[i]=true; j=i; &#125; else &#123; A[i]=false; &#125; &#125;&#125; 运行结果 2 实例 3 最小生成树（克鲁斯卡尔算法） 问题描述 求一个连通无向图的最小生成树的代价（图边权值为正整数）。 输入 第一行是一个整数 N（1&lt;=N&lt;=20），表示有多少个图需要计算。以下有 N 个图，第 i 图的第一行是一个整数 M（1&lt;=M&lt;=50），表示图的顶点数，第 i 图的第 2 行至 1+M 行为一个 M*M 的二维矩阵，其元素 ai,j 表示图的 i 顶点和 j 顶点的连接情况，如果 ai,j=0，表示 i 顶点和 j 顶点不相连；如果 ai,j&gt;0，表示 i 顶点和 j 顶点的连接权值。 输出 每个用例，用一行输出对应图的最小生成树的代价。 样例输入 160 6 1 5 0 06 0 5 0 3 01 5 0 5 6 45 0 5 0 0 20 3 6 0 0 60 0 4 2 6 0 样例输出 15 Kruskal 算法简述假设 WN=(V,{E}) 是一个含有 n 个顶点的连通网，则按照克鲁斯卡尔算法构造最小生成树的过程为：先构造一个只含 n 个顶点，而边集为空的子图，若将该子图中各个顶点看成是各棵树上的根结点，则它是一个含有 n 棵树的一个森林。之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，也就是说，将这两个顶点分别所在的两棵树合成一棵树；反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直至森林中只有一棵树，也即子图中含有 n-1 条边为止。 模拟过程： ​ ​ 模拟过程 算法难点：（1）边的选择要求从小到大选择，则开始显然要对边进行升序排序。（2）选择的边是否需要，则从判断该边加入后是否构成环入手。 算法设计：（1）对边升序排序在此采用链式结构，通过插入排序完成。每一结点存放一条边的左右端点序号、权值及后继结点指针（2）边的加入是否构成环一开始假定各顶点分别为一组，其组号为端点序号。选择某边后，看其两个端点是否在同一组中，即所在组号是否相同，如果是，表示构成了环，则舍去。 如果两个端点所在的组不同，则表示可以加入，则将该边两端的组合并成同一组。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;using namespace std;struct node&#123; int l; int r; int len; node *next;&#125;;void insert(node *&amp;h,node *p) //指针插入排序&#123; node *q=h; while(q-&gt;next &amp;&amp; q-&gt;next-&gt;len &lt;= p-&gt;len) &#123; q=q-&gt;next; &#125; p-&gt;next=q-&gt;next; q-&gt;next=p;&#125;int main()&#123;// freopen(&quot;001.in&quot;,&quot;r&quot;,stdin); node *h,*p; int n,m,x,temp; int *a; int i,j; int sum; cin&gt;&gt;n; while(n--) &#123; sum=0; cin&gt;&gt;m; a=new int[m+1]; for (i=1;i&lt;=m;i++) &#123; a[i]=i; &#125; h=new node; p=h; p-&gt;next=NULL; for (i=1;i&lt;=m;i++) for (j=1;j&lt;=m;j++) &#123; cin&gt;&gt;x; if (i&gt;j &amp;&amp; x!=0) &#123; p=new node; p-&gt;l=i; p-&gt;r=j; p-&gt;len=x; p-&gt;next=NULL; insert(h,p); //调用插入排序 &#125; &#125; p=h-&gt;next; while (p) &#123; if (a[p-&gt;l]!=a[p-&gt;r]) &#123; sum+=p-&gt;len; temp=a[p-&gt;l]; for(i=1;i&lt;=m;i++) if (a[i]==temp) &#123; a[i]=a[p-&gt;r]; &#125; &#125; p=p-&gt;next; &#125; /* 可以测试程序工作是否正常 p=h-&gt;next; while(p) &#123; cout&lt;&lt;p-&gt;l&lt;&lt;&apos;:&apos;;cout&lt;&lt;p-&gt;r&lt;&lt;&apos; &apos;; cout&lt;&lt;p-&gt;len&lt;&lt;&quot; &quot;; p=p-&gt;next; &#125; */ cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; 运行结果 ​ ​ image.png 实例 4 hdu1050-Moving Tables 题目描述 在一个狭窄的走廊里将桌子从一个房间移动到另一个房间，走廊的宽度只能允许一个桌子通过。给出 t，表示有 t 组测试数据。再给出 n，表示要移动 n 个桌子。n 下面有 n 行，每行两个数字，表示将桌子从 a 房间移到 b 房间。走廊的分布图如一图所示，每移动一个桌子到达目的地房间需要花 10 分钟，问移动 n 个桌子所需要的时间。 输入 3410 2030 4050 6070 8021 32 200310 10020 8030 50 输出 102030 解题思路若移动多个桌子时，所需要经过的走廊没有重合处，即可以同时移动。若有一段走廊有 m 个桌子都要经过，一次只能经过一个桌子，则需要 m*10 的时间移动桌子。 设一个数组，下标值即为房间号。桌子经过房间时，该房间号为下标对应的数组值即加 10。最后找到最大的数组值，即为移动完桌子需要的最短时间。(以上为代码 2，代码 3 同这个思想)注意： 可能出发位置比目的地房间大,无论大小，我们都可以看做从小的房间移动到大的房间 出发房间为偶数则减一，结束房间为奇数则加一 ​ ​ ​ 我们首先输入每次移动的出发和结束房间，然后按每次移动的出发房间从小到大排序，然后直至所有的房间移动完毕。（代码 1 的解释） 代码 1（我自己感觉不是贪心算法，属于暴力破解吧，大家酌情考虑） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct table&#123; int from,to; bool flag;//记录改房间是否被访问过&#125;moving[205];bool cmp(table a,table b)&#123; return a.from&lt;b.from;&#125;int main()&#123; int i,T,n;//T代表测试实例个数，n代表每个测试下的table个数 cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;moving[i].from&gt;&gt;moving[i].to; if(moving[i].from &gt; moving[i].to) &#123; int temp = moving[i].from; moving[i].from = moving[i].to; moving[i].to = temp; &#125;//可能出发位置比目的地房间大,无论大小，我们都可以看做从小的房间移动到大的房间 if(moving[i].from%2==0)&#123;//考虑实际情况，出发房间为偶数是减一，可参照题中给出的图一 moving[i].from--; &#125; if(moving[i].to%2==1)&#123;//考虑实际情况，结束房间为奇数是加一， moving[i].to++; &#125; moving[i].flag=false;//初始化房间未被访问过 &#125; sort(moving,moving+n,cmp);//将所有table按出发房间从小到大排序; bool completion=false;//是否所有的table移动结束 int cnt=-1,priorTo;//priorTo 记录前一个table移动结束的房间 while(!completion)&#123; completion=true; cnt++; priorTo=0; for(i=0;i&lt;n;i++)&#123;//每一轮将可以同时移动的table全部移动完：比如2-&gt;5,6-&gt;10，因为他们没有共用走廊 if(!moving[i].flag&amp;&amp;moving[i].from&gt;priorTo)&#123; moving[i].flag=true;//标记当前table已经移动完毕 priorTo=moving[i].to; completion=false; &#125; &#125; &#125; cout&lt;&lt;cnt*10&lt;&lt;endl; &#125; return 0;&#125; 代码 1 运行结果 ​ ​ 代码 2 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int t,n,count[410],i,start,end,k; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); memset(count,0,sizeof(count)); while(n--) &#123; scanf(&quot;%d%d&quot;,&amp;start,&amp;end); if(start&gt;end)//可能出发位置比目的地房间大。 &#123; //无论大小，我们都可以看做从小的房间移动到大的房间 k=start; start=end; end=k; &#125; if(start%2==0)//考虑实际情况，出发房间为偶数是减一，可参照题中给出的图一 start-=1; if(end%2==1)//目的地房间为奇数时加一 end+=1; for(i=start;i&lt;=end;++i) count[i]+=10; &#125; printf(&quot;%d\n&quot;,*max_element(count,count+400));//STL中寻找数列最大值函数 &#125; return 0;&#125; 代码 3 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define MAXN 500using namespace std;struct temp&#123; int be,en;&#125;;bool comp(temp a,temp b)&#123; return a.be&lt;b.be;&#125;int main()&#123; temp my[MAXN]; int m,n,i; cin&gt;&gt;m; while(m--)&#123; cin&gt;&gt;n; i=0; int a,b,j; while(i&lt;n)&#123; cin&gt;&gt;a&gt;&gt;b; if(a&gt;b)a^=b^=a^=b; my[i].be=(a+1)/2; my[i++].en=(b+1)/2; &#125; sort(my,my+n,comp); int s=0,out=n,t=0; int aa[203]; memset(aa,0,sizeof(aa)); for(i=0;i&lt;n;++i)&#123; for(j=my[i].be;j&lt;=my[i].en;++j)aa[j]++; &#125; sort(aa,aa+200); cout&lt;&lt;aa[199]*10&lt;&lt;&apos;\12&apos;; &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>电脑</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用手机这么久]]></title>
    <url>%2F2017%2F12%2F27%2F%E7%94%A8%E6%89%8B%E6%9C%BA%E8%BF%99%E4%B9%88%E4%B9%85%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%85%B3%E4%BA%8E%E6%89%8B%E6%9C%BA%E9%80%89%E9%A1%B9%E5%90%97%2F</url>
    <content type="text"><![CDATA[用手机这么久 你了解&quot;关于手机&quot;选项吗?手机已经日渐成为用户日常生活中必不可少的一部分，随着移动互联网的发展，特别是智能手机出现以后，手机功能的丰富以及移动互联网的快速发展，智能手机已然取代了我们身边很多常用的电子设备。但不论是使用 Android 的用户还是 iPhone，在摸索了手机各种设置后，对于其中的“关于手机”选项还是似懂非懂，究竟“内核”、“基带”都是些什么东西呢？今天就带大家了解一下你“关于手机”。 如今国产手机定制系统花样繁多，但无论是什么样的系统，有些功能都不会变，所以你总是能在手机选项中找到“关于手机”，通常位于“设置”中的最后一项。通过它也能帮助你快速了解自己手机的真正属性如何。 1.Android 版本 Android 操作系统是 Google 开发移动设备操作系统，而版本号则意味着手机系统的迭代更新，最早的一个版本 Android 1.0 发布于 2007 年 11 月 5 日，目前正式版已经进化到了 Android7.0。这些更新版本都在前一个版本的基础上修复了 Bug 并且添加了前一个版本所没有的新功能。每一个版本不论是功能还是设计界面都是当时社会的要求下的产物，所以理论上来说越新的版本功能也越强大。 目前 Android 版本已近到了 7.0 Android 版本号一般是 X.X.X 的形式，第一位数的改变意味着大版本升级，包括整个界面风格，以及性能提升和 linux 内核提升，第二位数的变化表示小幅升级，通常是一些优化更新等。而到了第三位数基本没有更新的内容，仅仅是为了修复一些 bug。 2.IMEI 码与序列号 每台手机在生产的时候都有一个自己的编号，这个就是 IMEI 码，它是国际移动设备标识的缩写，由 15 位数字(英文字母)组成。是手机的唯一识别号码。 双卡双待手机通常有两个 IMEI 号 IMEI 是区别移动设备的标识，储存在移动设备中，可用于监控被窃或无效的移动设备。IMEI 印在手机机身背面的标志上，不过随着手机外观备受重视，通常 IMEI 码都做的非常小，或者是贴在手机背面，不过它都被读写存储在手机内存中。所以用户无需担心 IMEI 码损坏。另外通过 IMEI 码，还能查询是否与包装盒机身以及系统内置的一致，从而达到辨别是真伪或者否为翻新机的目的。 序列号是一串标识你手机的出生证明 序列号是一串标识你手机出生证明以及身材特征的信息，同样你也还可用来识别是否为官方翻新机。你可以简单的将这一串数字分割为：aabccdddeef 的形式。拿 iPhone6s 为例 aa=工厂及生产线编号、b=年份、cc=制造周数、ddd=机身识别码、ee=颜色、f=容量大小，通过序列号在苹果官网可以查询手机的激活和保修信息。 而 IMEI 码与序列号在一定的条件下可以相互对应，也就是可以通过这任意一个查询双方的码，是手机重要安全信息，现阶段很多技术可以将别人手机的 IMEI 序列号等信息刷入其他手机，从而产生各种“黑机”“妖机”，这些都可以影响到你手机正常服务，因此也不要轻易泄露。 3.版本号 注意这并不是 Android 系统的版本号，在 Android 环境下，直接采用原生系统的手机是极少部分的，特别是国内手机厂商，几乎都会在该系统的基础之上修改美化、本土化从而达到宣传自家手机服务，加强品牌影响力的效果，这样就形成了版本号这一说法。因此即使是基于相同的 Android 版本，也会有不同的版本号产生，例如部分小米手机系统版本升级至 MIUI7，但依然基于 Android4.4.4 版本。 iOS 手机版本号（右）与 Android 手机的版本号（左）不同 在 iPhone 上版本号与 Android 则有所不同，版本号除了前面的数字对应着系统版本外，后面不同的数字对应不同的地区、不同的运营商。如果版本号不对，也许你在美国购买的手机在国内并不能使用通讯功能，所以在购买之前我们就可以通过 iOS 里的版本号识别手机是什么国家版本，是美版还是国行。 4.基带版本 基带版本用一句话总结，它主要是负责手机通讯功能，也就是手机的调制解调器使用的驱动版本号，关于打电话，发短信，数据交换等都与基带有关。其实就是手机中的一块电路，负责完成移动网络中无线信号的解调、解扰、解扩和解码工作。 图片说明 在我们的手机中通常由两大部分电路组成，一部分是高层处理部分，相当于我们使用的电脑；另一部分就是基带，这部分相当于我们使用的 Modem，手机支持什么样的网络制式（GSM、CDMA、WCDMA、TD-SCDMA 等）都是由它来决定的。另外值得一提的是在刷机时候如果 ROM 包含基带是很容易出错。所以建议在刷机前选择不带基带的刷机包是最好的 5.内核版本 内核版本就是手机的硬件驱动集合体的版本号，例如主板、GPS、摄像头、WIFI 等这些硬件如同电脑需要驱动来促使他们工作一样，手机的操作系统同样如此。 我们知道 Android 是一个基于 Linux 内核的开放移动操作系统。内核主要是指操作系统或者相应软件中最核心的功能框架部分，它是实现该软件所有功能的基础，决定着系统的性能和稳定性。同样一个系统版本的 ROM，或许你不同的内核都会带来不一样的效果，内核优化的更好，整个系统也会更加省电，所以内核也是厂商优化的重点。 总结：通过介绍想必大家对于自己的手机更加了解，以后手机哪方面出了问题也可以顺藤摸瓜找到相应的解决思路。另外在刷机时面对各种专业术语，刷什么内核这样也能从容应对了。]]></content>
      <categories>
        <category>数码</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>数码</tag>
        <tag>手机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12款很赞的web前端移动开发框架]]></title>
    <url>%2F2017%2F12%2F26%2F12%E6%AC%BE%E5%BE%88%E8%B5%9E%E7%9A%84web%E5%89%8D%E7%AB%AF%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[12 款很赞的 web 前端移动开发框架原生移动应用程序运行更快、更顺畅，有更好的用户体验。而同时，前端开发人员总是寻找新的 Web 技术来获得这种性能。利用现有的高质量移动框架来构建移动 Web 应用程序已成为非常容易，但是如何选择合适的框架是比较纠结的。因此在本文中，我们整理了 12 个很赞的移动框架。 1.Redbeard Redbeard 让它来创建本地应用程序没有一个样板更快和更容易。它与吨的组成部分的一个完整的框架，有一系列的准备使用的组件的一些最常用的功能。每一个组件是完全主题化的通过我们的可怕的主题引擎，不需要包装或包装的应用程序框架。Redbeard 100%原生开发框架，整个 iOS 套件 Objective-C 和 Swift。 2.Weex Weex 是一款跨平台 UI 框架。它重量轻，高性能和可扩展性。Weex 是从阿里巴巴与 HTML 构建移动应用程序，CSS 和 JavaScript，它的模块、UI 组件，它自己的工具和命令，设计了对移动环境和加快发展。 3.Rikulo Rikulo UI 是一个 HTML5 创建跨平台的 Web 和本地移动应用飞镖框架。它采用了结构化的用户界面模型和提供跨桌面和 UX 触摸设备的响应。 4.A Frame A-Frame 一种用于虚拟现实网页建造东西的框架。您可以使用标记来创建虚拟现实的经验在工作桌面，iPhone，和 Oculus Rift。 5.Onsen UI Onsen UI 是一个移动的框架，包括 HTML5、JavaScript 和 CSS 框架 PhoneGap 应用程序和科尔多瓦。它提供了大量基于 Web 的 UI 组件，以及智能手机和平板电脑的响应式布局，以及其他功能。 6.Tabris.js Tabris.js 是一个移动框架，它可以简单地用 JavaScript 创建 iOS 和 Android 的原生应用程序。它不使用 Web 视图渲染 UI，而是创造原生部件移动平台上通过 JavaScript 原生的桥。这也使您从 Web 开发中知道了快速开发/部署周期。 7.Rad.js RAD.js 是创建跨平台能力和母语一样的反应，应用程序的性能和可用性问题的解决。这是一个工具包，通过 mobidev 专家移动初创公司，企业需要有实力的企业创造的，并直接为软件开发者。 8.Konva Kanva 是一个用于创建桌面和移动应用程序的 2D HTML5 画布框架。它有一个面向对象的 API，分层支持，吐温和动画支持，过滤器，和自定义形状，以及其他功能。 9.Mootor Mootor 是用于开发移动应用程序的 HTML5 框架。它是极简主义者，在多个平台上工作，包括 iOS、Android 等。 10.TouchstoneJS TouchstoneJS 是一个由 react.js 开发混合移动应用程序 UI 框架。它包括表单组件、导航、转换、本地触摸行为等等，还有更多的功能。 11.Pikabu Pikabu 是一个用于创建了画布弹出面板框架。它具有简单的标记，支持本地滚动，并且是完全可定制的。 12.Clank Clank 是一个开源的 HTML 和 CSS 框架，用于原型本地移动和平板应用程序。它利用现代的 CSS 技术，公司和指南针，和基于组件的所以你可以选择你所需要的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js开发工具大全]]></title>
    <url>%2F2017%2F12%2F26%2Fjs%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[标签: js,前端 js 开发工具JavaScript 开发工具大全为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习。 简介 2017 年 1 月，Stack Overflow 年度开发者调研一共访问了64000个程序员，发现 JavaScript 已经连续 5 年成为最流行的编程语言。 这篇博客将介绍一些常用的 JavaScript 开发工具： 构建&amp;自动化 IDE&amp;编辑器 文档 测试 调试 安全 代码优化&amp;分析 包管理 构建 &amp; 自动化 Webpack对 JavaScript 应用依赖的所有模块进行静态分析，生成依赖图，然后将它们打包成数个静态文件。 Grunt以将重复耗时的任务自动化。Grunt 的生态系统非常大，有超过 6010 个插件。 Gulp发布于 Grunt 之后，采用了完全不同的方式，使用 JavaScript 函数定义任务。它有超过 2770 个插件，并且提供了更好的控制。 Browserify使得开发者可以在浏览器使用CommonJS 模块。开发者像在 node 环境一样，通过require(&#39;modules&#39;)来组织模块之间的引用和依赖，Browserify 将这些依赖打包成浏览器可以直接引用的 JS 文件。 Brunch非常简单，速度很快。Brunch 的配置文件非常简单，入门文档非常详细。Brunch 会自动生成 Source Map，方便了开发者 Debug。 Yeoman可以用于任何编程语言(JavaScript, Python, C#, Java, etc.)。它是前端开发的脚手架，有 6213 个插件。 IDE &amp; 编辑器 WebStorm是一款强大的 JavaScript IDE。它支持多种框架和 CSS 语言，包括前端，后端，移动端以及桌面应用。WebStorm 可以无缝整合第三方工具，例如构建构建、语法检查构建 linter 等等。它提供了代码补全，实时错误监测，导航，内置控制台，各种插件等一系统功能。 Atom是 GitHub 团队开发的。开发者可以很容易地对 Atom 进行自定义。Atom 自带了一个包管理工具，代码补全，文件系统浏览器，支持多个平台以及其他有用的功能。 Visual Studio Code是微软开发的 IDE，支持 TypeScript。它提供了代码补全，语法高亮，支持 Git 命令等等。另外，它还有非常多的插件。 Brackets是一个轻量级的开源编辑器。它专注于可视化工具，可以帮助开发者开发 Web 应用。Brackets 支持实时预览以及行内编辑。 文档 Swagger提供了一系列规则用于描述 API。使用 Swagger，可以创建清晰的文档，并且自动化 API 相关的操作(例如功能测试)。 JSDoc可以根据 javascript 文件中注释信息，生成 JavaScript 应用程序或库、模块的 API 文档。JSDoc 可以用于管理大型项目。 jGrouseDoc 是一个开源工具，可根据 JavaScript 注释生成类似 Jaavdoc 的源码文档。它不仅可以为变量和函数生成文档，还可以为模块等其他元素生成文档。 YUIDoc基于 Nodejs，可以将文档中的注释生成 API 文档。它使用类似于 Javadoc 与 Doxygen 的语法，并且支持实时预览，支持各种语言，并且支持标记语言。 Docco 是免费的文档工具，由 Literate CoffeeScript 编写。它将代码中的注释生成 HTML 文档。Docco 并不限于 JavaScript，同时支持 Python, Ruby, Clojure 等语言。 测试 Jasmine是一个行为驱动开发(BDD)框架，用于测试 JavaScript 代码。它不依赖任何第三方模块，也不需要 DOM。它的语法非常简单易懂，使得编写测试变得很简单。另外，它也可以用于测试 Node.js，Python 以及 Ruby。 Mocha是一个功能测试框架，用于测试 Node.js 以及浏览器端 JavaScript。作为开发者首选的测试框架，它可以自由的编写测试组，提供详细的测试报告，同时让异步测试非常简单。Mocha 通常与断言库Chai来验证测试结果。 PhantomJS用于前端单元测试。由于 PhantomJS 是一个无界面的 Webkit 浏览器引擎，与直接使用浏览器测试相比，使用 PhantomJS 脚本可以运行得更快。它支持各种网页标准，例如 JSON, Canvas, DOM 操作, SVG 以及 CSS 选择器。 Protractor是一个端到端测试框架，用于测试 Angular 应用。它是基于 WebDriverJS 构建的，它可以通过浏览器事件或者原生事件，从而模拟真实用户，来测试应用。 调试 JavaScript Debugger由 Mozilla Developer Network (MDN)开发，可以独立用于调试 Node.js 代码，或者用于其他浏览器。Firefox 提供了本地和远程调试功能，并且，Firefox 安卓端也用于调试运行在安卓应用。 Chrome Dev Tools提供了一系列工具，可以用于调试 JavaScript 代码，编辑 CSS，以及测试应用性能。 ng-inspector是 Firefox，Chrome 和 Safari 浏览器插件，可以帮助开发者开发、理解以及调试 AngularJS 应用。它提供了实时更新，DOM 高亮等功能。 Augury是一个 Chrome 插件，可以用于调试 Angular 2 应用。它让开发者可以直接查看应用结构，操作特征以及状态变化。 安全 Snyk是一个付费服务，用于发现、修复和预防 JavaScript，Node.js 和 Ruby 应用的已知漏洞。Snyk 拥有自己的漏洞库，以及 NSP 和 NIST NVD 的漏洞数据。它允许开发者使用它们的补丁和更新来修复这些安全漏洞。 Node Security Project提供了工具用于扫描依赖来监测漏洞。NSP 使用自己的漏洞数据，以及来自 NIST NVD 的漏洞数据。NSP 支持集成 GitHub 和 CI 软件，实时监测和报警，并且可以提供如何修复 Node.js 应用漏洞的建议。 RetireJS是一个开源的依赖监测工具。它包含了多个组件，包括命令行工具，Grunt 插件，Firefox 和 Chrome 插件，Burp 和 OWASP ZAP 插件。Retirejs 从 NIST NVD，漏洞追踪系统，博客和邮件列表等手机漏洞数据。 Gemnasium是一个付费工具，不过有免费方案。它支持各种技术，比如 Ruby, PHP, Bower, Python 和 npm。Gemnasium 提供很多非常有用的特性，比如自动更新，实时报警以及 Slack 集成等。 OSSIndex支持多个生态系统(Java, JavaScript 和.NET/C#)，以及多个平台，例如 NuGet, npm, Bower, Chocolatey, Maven, Composer, Drupal 和 MSI。它从 NVD 以及其他来源收集漏洞数据。 代码优化 &amp; 分析 JSLint是一个 Web 服务，用于验证 JavaScript 的代码质量。当它诊断到一个问题时，它会返回问题的大致位置和出错信息。JSLint 可以分析一些编码规范以及语法错误。 JSHint可以发现 JavaScript 中的错误以及一些潜在的问题。JSHint 是一个静态代码分析工具，旨在帮助开发者编写大型的程序。它可以诊断语法错误、隐形类型转换等问题，但是它并不能确定你的应用是否正确、性能是否足够好、以及是否会发生内存泄漏。 JSHint 是 JSLint 的一个 fork。 ESLint是一个开源诊断工具，用于 JSX 和 JavaScript 应用。它可以帮助开发者发现可疑的或者不符合特定编程规范的代码。它帮助开发者在没有执行代码之前发现 JS 代码中问题，节省了不少时间。ESLint 由 Node.js 编写，可以使用 NPM 安装。 Flow是 JavaScript 代码静态类型检测器，由 Facebook 开发。Flow 可以在编码时检查到类型错误并做出提示。 包管理 Bower是一个用于管理前端依赖的包管理器，Twitter 创建。它提供了大量可供使用的依赖包，帮助 JavaScript 开发者更方便地管理前端依赖的 JS 库。 NPM是node package manager的缩写，事实上 NPM 包可以用于前后端。它是 JavaScript 包管理系统，也是世界上最大的依赖库，有超过 475,000 个模块。 Yarn是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。与 NPM 相比，它解决了安全、性能以及一致性问题。 Duo吸取了 Component, Browserify 和 Go 的经验，致力于简化大型 Web 应用的构建过程。 原文: THE ULTIMATE LIST OF JAVASCRIPT TOOLS 译者: Fundebug]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>编程</tag>
        <tag>电脑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[送给前端开发者的一份新年礼物]]></title>
    <url>%2F2017%2F12%2F18%2F%E9%80%81%E7%BB%99%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%80%E4%BB%BD%E6%96%B0%E5%B9%B4%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[送给前端开发者的一份新年礼物 大家好，新年快乐！今天，我开源了一个 React 的项目。这个项目虽小，但是五脏六腑俱全，并且接下来我会根据该项目做一整套的免费视频，预计总时间在 20 小时以上。 先来介绍下这个项目的技术栈： React 全家桶：React 16 + Redux + React-router 4.0 + Immutable.js ES6 + ES7 语法 网络请求：Axios + Socket.io UI 框架：Antd-mobile 后端：Express + MongoDB 接下来是我初步拟订的课程大纲规划 从2018年1月开始，每周都会更新 2 小时左右的教学视频，视频会按照以上大纲教学，这个视频是完全免费的，保证更新完成。 想第一时间获得更新的视频，可以扫码加群。(二维码在文章最后，你可以先将项目总结看一遍，有兴趣再加不迟) 项目总结React 是什么React 其实只是一个 UI 框架，频繁进行 DOM 操作的代价是很昂贵的，所以 React 使用了虚拟 DOM 的技术，每当状态发生改变，就会生成新的虚拟 DOM 并与原本的进行改变，让变化的地方去渲染。并且为了性能的考虑，只对状态进行浅比较（这是一个很大的优化点）。 React 已经成为当今最流行的框架之一，但是他的学习成本并不低并且需要你有一个良好的 JS 基础。由于React 只是一个 UI 框架，所以你想完成一个项目，你就得使用他的全家桶，更加提高了一个学习成本。所以本课程也是针对初学者，让初学者能够快速的上手 React 。 React 组件如何写好规划好一个组件决定了你的 React 玩的溜不溜。一个组件你需要考虑他提供几个对外暴露的接口，内部状态通过局部状态改变还是全局状态改变好。并且你的组件应该是利于复用和维护的。 组件的生命周期 render 函数会在 UI 渲染时调用，你多次渲染就会多次调用，所以控制一个组件的重复渲染对于性能优化很重要 componentDidMount 函数只会在组件渲染以后调用一次，通常会在这个发起数据请求 shouldComponentUpdate 是一个很重要的函数，他的返回值决定了是否需要生成一个新的虚拟 DOM 去和之前的比较。通常遇到的性能问题你可以在这里得到很好的解决 componentWillMount 函数会在组件即将销毁时调用，项目中在清除聊天未读消息中用到了这个函数 父子组件参数传递在项目中我使用的方式是单个模块顶层父组件通过 connect 与 Redux 通信。子组件通过参数传递的方式获取需要的参数，对于参数类型我们应该规则好，便于后期 debug。 性能上考虑，我们在参数传递的过程中尽量只传递必须的参数。 路由在 React-router 4.0 版本，官方也选择了组件的方式去书写路由。 下面介绍一下项目中使用到的按需加载路由高阶组件 123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from "react";// 其实高阶组件就是一个组件通过参数传递的方式生成新的组件export default function asyncComponent(importComponent) &#123; class AsyncComponent extends Component &#123; constructor(props) &#123; super(props); // 存储组件 this.state = &#123; component: null &#125;; &#125; async componentDidMount() &#123; // 引入组件是需要下载文件的，所以是个异步操作 const &#123; default: component &#125; = await importComponent(); this.setState(&#123; component: component &#125;); &#125; // 渲染时候判断文件下完没有，下完了就渲染出来 render() &#123; const C = this.state.component; return C ? &lt;C &#123;...this.props&#125; /&gt; : null; &#125; &#125; return AsyncComponent;&#125; ReduxRedux 通常是个另新手困惑的点。首先，不是每个项目都需要使用 Redux，组件间通信不多，逻辑不复杂，你也就不需要使用这个库，毕竟这个使用这个库的开发成本很大。 Redux 是与 React 解耦的，所以你想和 Redux 通信就需要使用 React-redux，你在 action 中使用异步请求就得使用 Redux-thunk，因为 action 只支持同步操作。 Redux 的组成Redux 由三部分组成：action，store，reducer。 Action 顾名思义，就是你发起一个操作，具体使用如下： 1234export function getOrderSuccess(data) &#123;// 返回的就是一个 action，除了第一个参数一般这样写，其余的参数名随意 return &#123; type: GET_ORDER_SUCCESS, payload: data &#125;;&#125; Action 发出去以后，会丢给 Reducer。Reducer 是一个纯函数（不依赖于且不改变它作用域之外的变量状态的函数），他接收一个之前的 state 和 action 参数，然后返回一个新的 state 给 store。 123456789export default function(state = initialState, action) &#123; switch (action.type) &#123; case GET_ALL_ORDERS: return state.set("allOrders", action.payload); default: break; &#125; return state;&#125; Store 很容易和 state 混淆。你可以把 Store 看成一个容器，state 存储在这个容器中。Store 提供一些 API 让你可以对 state 进行访问，改变等等。 PS：state 只允许在 reducer 中进行改变。 说明完了这些基本概念，我觉得是时候对 Redux 进行一点深入的挖掘。 自己实现 Redux之前说过 Store 是个容器，那么可以写下如下代码 12345678class Store &#123; constructor() &#123;&#125; // 以下两个都是 store 的常用 API dispatch() &#123;&#125; subscribe() &#123;&#125;&#125; Store 容纳了 state，并且能随时访问 state 的值，那么可以写下如下代码 123456789101112131415class Store &#123; constructor(initState) &#123; // _ 代表私有，当然不是真的私有，便于教学就这样写了 this._state = initState &#125; getState() &#123; return this._state &#125; // 以下两个都是 store 的常用 API dispatch() &#123;&#125; subscribe() &#123;&#125;&#125; 接下来我们考虑 dispatch 逻辑。首先 dispatch 应该接收一个 action 参数，并且发送给 reducer 更新 state。然后如果用户 subscribe 了 state，我们还应该调用函数，那么可以写下如下代码 1234dispatch(action) &#123; this._state = this.reducer(this.state, action) this.subscribers.forEach(fn =&gt; fn(this.getState()))&#125; reducer 逻辑很简单，在 constructor 时将 reducer 保存起来即可，那么可以写下如下代码 1234constructor(initState, reducer) &#123; this._state = initState this._reducer = reducer&#125; 现在一个 Redux 的简易半成品已经完成了，我们可以来执行下以下代码 12345678910111213141516const initState = &#123;value: 0&#125;function reducer(state = initState, action) &#123; switch (action.type) &#123; case 'increase': return &#123;...state, value: state.value + 1&#125; case 'decrease': &#123; return &#123;...state, value: state.value - 1&#125; &#125; &#125; return state&#125;const store = new Store(initState, reducer)store.dispatch(&#123;type: 'increase'&#125;)console.log(store.getState()); // -&gt; 1store.dispatch(&#123;type: 'increase'&#125;)console.log(store.getState()); // -&gt; 2 最后一步让我们来完成 subscribe 函数， subscribe 函数调用如下 123store.subscribe(() =&gt; console.log(store.getState())) 所以 subscribe 函数应该接收一个函数参数，将该函数参数 push 进数组中，并且调用该函数 123456789subscribe(fn) &#123; this.subscribers = [...this.subscribers, fn]; fn(this.value);&#125;constructor(initState, reducer) &#123; this._state = initState this._reducer = reducer this.subscribers = []&#125; 自此，一个简单的 Redux 的内部逻辑就完成了，大家可以运行下代码试试。 Redux 中间件的实现我会在课程中讲解，这里就先放下。通过这段分析，我相信大家应该不会对 Redux 还是很迷惑了。 Immutable.js我在该项目中使用了该库，具体使用大家可以看项目，这里讲一下这个库到底解决了什么问题。 首先 JS 的对象都是引用关系，当然你可以深拷贝一个对象，但是这个操作对于复杂数据结构来说是相当损耗性能的。 Immutable 就是解决这个问题而产生的。这个库的数据类型都是不可变的，当你想改变其中的数据时，他会clone 该节点以及它的父节点，所以操作起来是相当高效的。 这个库带来的好处是相当大的： - 防止了异步安全问题 - 高性能，并且对于做 React 渲染优化提供了很大帮助 - 强大的语法糖 - 时空穿梭 （就是撤销恢复） 当然缺点也是有点： - 项目倾入性太大 （不推荐老项目使用） - 有学习成本 - 经常忘了重新赋值。。。 对于 Immutable.js 的使用也会在视频中讲述 性能优化 减少不必要的渲染次数 使用良好的数据结构 数据缓存，使用 Reselect 具体该如何实现性能优化，在课程的后期也会讲述 聊天相关在聊天功能中我用了 Socket.io 这个库。该库会在支持的浏览器上使用 Websocket，不支持的会降级使用别的协议。 Websocket 底下使用了 TCP 协议，在生产环境中，对于 TCP 的长链接理论上只需要保证服务端收到消息并且回复一个 ACK 就行。 在该项目的聊天数据库结构设计上，我将每个聊天存储为一个 Document，这样后续只需要给这个 Document 的 messages 字段 push 消息就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152const chatSchema = new Schema(&#123; messageId: String, // 聊天双方 bothSide: [ &#123; user: &#123; type: Schema.Types.ObjectId &#125;, name: &#123; type: String &#125;, lastId: &#123; type: String &#125; &#125; ], messages: [ &#123; // 发送方 from: &#123; type: Schema.Types.ObjectId, ref: "user" &#125;, // 接收方 to: &#123; type: Schema.Types.ObjectId, ref: "user" &#125;, // 发送的消息 message: String, // 发送日期 date: &#123; type: Date, default: Date.now &#125; &#125; ]&#125;);// 聊天具体后端逻辑module.exports = function() &#123; io.on("connection", function(client) &#123; // 将用户存储一起 client.on("user", user =&gt; &#123; clients[user] = client.id; client.user = user; &#125;); // 断开连接清除用户信息 client.on("disconnect", () =&gt; &#123; if (client.user) &#123; delete clients[client.user]; &#125; &#125;); // 发送聊天对象昵称 client.on("getUserName", id =&gt; &#123; User.findOne(&#123; _id: id &#125;, (error, user) =&gt; &#123; if (user) &#123; client.emit("userName", user.user); &#125; else &#123; client.emit("serverError", &#123; errorMsg: "找不到该用户" &#125;); &#125; &#125;); &#125;); // 接收信息 client.on("sendMessage", data =&gt; &#123; const &#123; from, to, message &#125; = data; const messageId = [from, to].sort().join(""); const obj = &#123; from, to, message, date: Date() &#125;; // 异步操作，找到聊天双方 async.parallel( [ function(callback) &#123; User.findOne(&#123; _id: from &#125;, (error, user) =&gt; &#123; if (error || !user) &#123; callback(error, null); &#125; callback(null, &#123; from: user.user &#125;); &#125;); &#125;, function(callback) &#123; User.findOne(&#123; _id: to &#125;, (error, user) =&gt; &#123; if (error || !user) &#123; callback(error, null); &#125; callback(null, &#123; to: user.user &#125;); &#125;); &#125; ], function(err, results) &#123; if (err) &#123; client.emit("error", &#123; errorMsg: "找不到聊天对象" &#125;); &#125; else &#123; // 寻找该 messageId 是否存在 Chat.findOne(&#123; messageId &#125;).exec(function(err, doc) &#123; // 不存在就自己创建保存 if (!doc) &#123; var chatModel = new Chat(&#123; messageId, bothSide: [ &#123; user: from, name: results[0].hasOwnProperty("from") ? results[0].from : results[1].from &#125;, &#123; user: to, name: results[0].hasOwnProperty("to") ? results[0].to : results[1].to &#125; ], messages: [obj] &#125;); chatModel.save(function(err, chat) &#123; if (err || !chat) &#123; client.emit("serverError", &#123; errorMsg: "后端出错" &#125;); &#125; if (clients[to]) &#123; // 该 messageId 不存在就得发送发送方昵称 io.to(clients[to]).emit("message", &#123; obj: chat.messages[chat.messages.length - 1], name: results[0].hasOwnProperty("from") ? results[0].from : results[1].from &#125;); &#125; &#125;); &#125; else &#123; doc.messages.push(obj); doc.save(function(err, chat) &#123; if (err || !chat) &#123; client.emit("serverError", &#123; errorMsg: "后端出错" &#125;); &#125; if (clients[to]) &#123; io.to(clients[to]).emit("message", &#123; obj: chat.messages[chat.messages.length - 1] &#125;); &#125; &#125;); &#125; &#125;); &#125; &#125; ); &#125;); &#125;);&#125;;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>js</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基本知识]]></title>
    <url>%2F2017%2F12%2F18%2Flinux%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[标签： linux Linux 的命令行 第一章安装桌面环境: login 进入系统之后，开始进行用户界面的安装。首先输入如下命令：sudo apt-get install xinit上述安装完毕之后，再安装环境管理器。本人亲测安装的是 GNOME。使用如下命令安装：sudo apt-get install gdm然后，安装桌面环境。本人亲测安装的是 KUbuntu。安装命令如下： sudo apt-get install kubuntu-desktopsudo apt-get install gnome-session-fallback 或者： sudo apt-get install gnome-panel。安装时的界面如下所示 安装中文语言包sudo apt-get install language-pack-zh-han* 安装 gnome 包sudo apt-get install language-pack-gnome-zh-han* 安装 kde 包sudo apt-get install language-pack-kde-zh-han*到这里就能够查看目录下面的中文字符了。 最后运行语言支持检查sudo apt install $(check-language-support)会更新最新的语言支持包设置语言:改英文: 用 vi(或 nano 等文本编辑器)打开 /etc/default/locale 文件将原来的配置内容修改为LANG=”en_US.UTF-8″LANGUAGE=”en_US:en”再在终端下运行：locale-gen -en_US:en注销或重启后，即可恢复为英文的语言环境。改为中文:1、修改／etc/default/locale如不存在则新建一个如下： LANG=’en_US’ #中文可以用 zh_CNLANGUAGE=’en_US:en’ #中文可以用 zh_CN:zh 2、reboot 即可locale 命令可以列出当前系统所用的所有语言设置123Sudo apt installSudo apt installsudo apt apt 1.4 (amd64)用法： apt [选项] 命令 命令行软件包管理器 apt 提供软件包搜索，管理和信息查询等功能。它提供的功能与其他 APT 工具相同（像 apt-get 和 apt-cache），但是默认情况下被设置得更适合交互。 常用命令： 12345678910list - 根据名称列出软件包search - 搜索软件包描述show - 显示软件包细节install - 安装软件包remove - 移除软件包autoremove - 卸载所有自动安装且不再使用的软件包update - 更新可用软件包列表upgrade - 通过 安装/升级 软件来更新系统full-upgrade - 通过 卸载/安装/升级 来更新系统edit-sources - 编辑软件源信息文件 参见 apt(8) 以获取更多关于可用命令的信息。程序配置选项及语法都已经在 apt.conf(5) 中阐明。欲知如何配置软件源，请参阅 sources.list(5)。软件包及其版本偏好可以通过 apt_preferences(5) 来设置。关于安全方面的细节可以参考 apt-secure(8).本 APT 具有超级牛力。 好玩的软件 oneko,cmatrix, 软件安装,1gdebi ,gedit ,cinnamon ,mate,xfce,unity,gnome-fontviewer,或者 font-manager,gnome-ternimal,firefox,screefetch,file-roller(压缩包管理器),tree,transmission(迅雷),gnome-software 软件更新器,gnome-packagekit 软件包 unbuntu-desktop, Software-properties-gtk(软件源,ppa 更新) Gnome-software (软件商店) Gnome-systemmoniter(任务管理器) FTP/SFTP 客户端: 声音视频:audacity,vlc,rhythmbox 图像处理:gimp 抓图工具:shutter gnome-web-photo Mypaint,darktable,inkscape,dia,shotwell, 录屏工具:gek-recordmydesktop 视频后期处理:openshot 搜狗输入法安装,安装 gdebi进入搜狗输入法目录输入命令行: sudo gdebi sogoupinyin_2.1.0.0086_amd64.deb安装 cinnamon :sudo apt install cinnamon然后运行cinnamon –replace运行图形化命令,gksuFilezilla:sudo aptitude install –y filezilla 安装主题: elementary os 的主题 123sudo add-apt-repository ppa:elementary-os/dailysudo apt-get updatesudo apt-get install elementary-icon-theme ubuntukylin ukui 主题, www.ukui.org 官网教程安装这个就好 zorinos 主题安装方法，首先打开终端输入以下命令安装主题： 123sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install zorinos-themes 在终端输入以下命令安装图标主题：123sudo add-apt-repository ppa:noobslab/icons2sudo apt-get updatesudo apt-get install zorinos-icons 安装或使用调节工具：如 Unity Tweak Tool、Gnome-tweak-tool 或者 Ubuntu-Tweak 来启用主题和图标。 第二章 linux 的文件系统Lib 各种动态链接库存放的位置,类似 windows 的 dll 文件,只不过 linux 的是.so 文件, 123``````]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos网络错误]]></title>
    <url>%2F2017%2F12%2F16%2Fcentos%E5%AE%89%E8%A3%85%E6%97%A0%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[centos 网络标签： linux 使用 安装过 centos7 后需要安装图形界面,可是 ping 命令发现没有网络,ping www.baidu.com 出现了一个网络不通,怎么办呢,网上找了一些方法; 查看 ip 发现,ifconfig 不能用了,只好用 ip 命令了,, 123456789101112131415ip link show # 显示网络接口信息ip link set eth0 upi # 开启网卡ip link set eth0 down # 关闭网卡ip link set eth0 promisc on # 开启网卡的混合模式ip link set eth0 promisc offi # 关闭网卡的混个模式ip link set eth0 txqueuelen 1200 # 设置网卡队列长度ip link set eth0 mtu 1400 # 设置网卡最大传输单元ip addr show # 显示网卡IP信息ip addr add 192.168.0.1/24 dev eth0 # 设置eth0网卡IP地址192.168.0.1ip addr del 192.168.0.1/24 dev eth0 # 删除eth0网卡IP地址ip route list # 查看路由信息ip route add 192.168.4.0/24via192.168.0.254 dev eth0 # 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口ip route add default via192.168.0.254dev eth0 # 设置默认网关为192.168.0.254ip route del 192.168.4.0/24 # 删除192.168.4.0网段的网关ip route del default # 删除默认路由 使用 ip addr 命令看了一下，果然没有没有配置 IP 地址。进入 /etc/sysconfig/network-scripts/ 查看 ifcfg-eth0 文件,发现没有,看看有啥呢？发现一个文件，文件名为：ifcfg-eno16777736 我勒个去，这是什么奇葩名字啊？ vi 打开瞅一眼 果然，这是网卡配置信息。不过奇葩的是 它的 ONBOOT=no 好像就是这个原因导致不能正常上网的。改成 ONBOOT=yes :wq 保存文件。重启网络服务 service network restart 。然后在 ping 一下百度，果然 ping 通了。这就说明网络正常了。 不过这里有一个问题，我需要把虚拟机里面的 IP 给定死，否则每次访问都不知道 IP 是啥，这是个问题。次 VI 这个文件。再里面添加上 12345#BOOTPROTO=dhcpIPADDR0=192.168.1.254PREFIX0=24GATEWAY0=192.168.1.1DNS1=114.114.114.114 这里要把 dhcp 给关闭，所以在前面加上一个#号，注释掉。 再次保存，然后重启网络服务 service network restart 。 好了，在宿主机上用 putty 连接一下，果然连上了。 PS：文章技术资料来自于网络。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux桌面环境]]></title>
    <url>%2F2017%2F12%2F16%2Flinux%E5%AE%89%E8%A3%85%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[linux 桌面环境标签： linux 使用 ubuntu 和她的衍生 首先，ubuntu server 版本的安装这里就不再赘述，基本的还是三个步骤，首先是下载镜像，然后使用 ultraISO 刻录至 u 盘，最后通过 U 盘引导进行安装。安装过程中，会要求你输入用户名和密码，一定要牢记，因为后续软件的安装都需要密码。 然后，login 进入系统之后，开始进行用户界面的安装。首先输入如下命令：sudo apt-get install xinit 上述安装完毕之后，再安装环境管理器。本人亲测安装的是 GNOME。使用如下命令安装：sudo apt-get install gdm 然后，安装桌面环境。本人亲测安装的是 KUbuntu。安装命令如下：sudo apt-get install kubuntu-desktop centos1、首先安装X(X Window System),命令为yum groupinstall &quot;X Window System&quot; 回车（注意有引号） 2、由于这个软件组比较大，安装过程会比较慢，安装完成会出现complete！ 3、检查一下我们已经安装的软件以及可以安装的软件，用命令yum grouplist 回车 4、然后安装我们需要的图形界面软件，GNOME(GNOME Desktop)这里需要特别注意！！！！一定要注意 名称必须对应 不同版本的centOS的软件名可能不同 其他Linux系统类似否则会出现No packages in any requested group available to install or update 的错误。5、同样的。由于这个软件组比第一个要大很多（包含700个左右的软件），安装过程会很慢，请耐心等待。安装完成会出现complete！ 6、安装完成后我们可以通过命令 startx 进入图形界面，第一次进入会比较慢，请耐心等待。（可能需要重启，命令为reboot）如果启动正常的话，到这里就可以不用继续向下看了，如果出现问题，那么请继续看。]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos安装hadoop]]></title>
    <url>%2F2017%2F12%2F16%2Flinux%E5%AE%89%E8%A3%85hadoop%2F</url>
    <content type="text"><![CDATA[标签： linux CentOS7 安装 Hadoop2.7 完整步骤总体思路，准备主从服务器，配置主服务器可以无密码 SSH 登录从服务器，解压安装 JDK，解压安装 Hadoop，配置 hdfs、mapreduce 等主从关系。1、环境，3 台 CentOS7，64 位，Hadoop2.7 需要 64 位 Linux，CentOS7 Minimal 的 ISO 文件只有 600M，操作系统十几分钟就可以安装完成， Master 192.168.0.182Slave1 192.168.0.183Slave2 192.168.0.184 2、SSH 免密码登录，因为 Hadoop 需要通过 SSH 登录到各个节点进行操作，我用的是 root 用户，每台服务器都生成公钥，再合并到 authorized_keys(1)CentOS 默认没有启动 ssh 无密登录，去掉/etc/ssh/sshd_config 其中 2 行的注释，每台服务器都要设置， 12#RSAAuthentication yes#PubkeyAuthentication yes (2)输入命令，ssh-keygen -t rsa，生成 key，都不输入密码，一直回车，/root 就会生成.ssh 文件夹，每台服务器都要设置，(3)合并公钥到 authorized_keys 文件，在 Master 服务器，进入/root/.ssh 目录，通过 SSH 命令合并， 123cat id_rsa.pub&gt;&gt; authorized_keysssh root@192.168.0.183 cat ~/.ssh/id_rsa.pub&gt;&gt; authorized_keysssh root@192.168.0.184 cat ~/.ssh/id_rsa.pub&gt;&gt; authorized_keys (4)把 Master 服务器的 authorized_keys、known_hosts 复制到 Slave 服务器的/root/.ssh 目录 (5)完成，ssh root@192.168.0.183、ssh root@192.168.0.184 就不需要输入密码了 3、安装 JDK，Hadoop2.7 需要 JDK7，由于我的 CentOS 是最小化安装，所以没有 OpenJDK，直接解压下载的 JDK 并配置变量即可(1)下载“jdk-7u79-linux-x64.gz”，放到/home/java 目录下(2)解压，输入命令，tar -zxvf jdk-7u79-linux-x64.gz(3)编辑/etc/profile 123export JAVA_HOME=/home/java/jdk1.7.0_79export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin (4)使配置生效，输入命令， source /etc/profile(5)输入命令，java -version，完成 4、安装 Hadoop2.7，只在 Master 服务器解压，再复制到 Slave 服务器(1)下载“hadoop-2.7.0.tar.gz”，放到/home/hadoop 目录下(2)解压，输入命令，tar -xzvf hadoop-2.7.0.tar.gz(3)在/home/hadoop 目录下创建数据存放的文件夹，tmp、hdfs、hdfs/data、hdfs/name 5、配置/home/hadoop/hadoop-2.7.0/etc/hadoop 目录下的 core-site.xml 1234567891011121314&lt;configuration&gt;&lt;property&gt;&lt;name&gt;fs.defaultFS&lt;/name&gt;&lt;value&gt;hdfs://192.168.0.182:9000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;&lt;value&gt;file:/home/hadoop/tmp&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;io.file.buffer.size&lt;/name&gt;&lt;value&gt;131702&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 6、配置/home/hadoop/hadoop-2.7.0/etc/hadoop 目录下的 hdfs-site.xml 12345678910111213141516171819202122&lt;configuration&gt;&lt;property&gt;&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;&lt;value&gt;file:/home/hadoop/dfs/name&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;&lt;value&gt;file:/home/hadoop/dfs/data&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.replication&lt;/name&gt;&lt;value&gt;2&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;&lt;value&gt;192.168.0.182:9001&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 7、配置/home/hadoop/hadoop-2.7.0/etc/hadoop 目录下的 mapred-site.xml 1234567891011121314&lt;configuration&gt;&lt;property&gt;&lt;name&gt;mapreduce.framework.name&lt;/name&gt;&lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;&lt;value&gt;192.168.0.182:10020&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;&lt;value&gt;192.168.0.182:19888&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 8、配置/home/hadoop/hadoop-2.7.0/etc/hadoop 目录下的 mapred-site.xml 12345678910111213141516171819202122232425262728293031323334&lt;configuration&gt;&lt;property&gt;&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;&lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.nodemanager.auxservices.mapreduce.shuffle.class&lt;/name&gt;&lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;&lt;value&gt;192.168.0.182:8032&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;&lt;value&gt;192.168.0.182:8030&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;&lt;value&gt;192.168.0.182:8031&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt;&lt;value&gt;192.168.0.182:8033&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;&lt;value&gt;192.168.0.182:8088&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;&lt;value&gt;768&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 9、配置/home/hadoop/hadoop-2.7.0/etc/hadoop 目录下 hadoop-env.sh、yarn-env.sh 的 JAVA_HOME，不设置的话，启动不了， 1export JAVA_HOME=/home/java/jdk1.7.0_79 10、配置 /home/hadoop/hadoop-2.7.0/etc/hadoop目录下的 slaves，删除默认的 localhost，增加 2 个从节点，192.168.0.183192.168.0.184 11、将配置好的 Hadoop 复制到各个节点对应位置上，通过 scp 传送， 12scp -r /home/hadoop 192.168.0.183:/home/scp -r /home/hadoop 192.168.0.184:/home/ 12、在 Master 服务器启动 hadoop，从节点会自动启动，进入/home/hadoop/hadoop-2.7.0 目录(1)初始化，输入命令，bin/hdfs namenode -format(2)全部启动 sbin/start-all.sh，也可以分开 sbin/start-dfs.sh、sbin/start-yarn.sh(3)停止的话，输入命令，sbin/stop-all.sh(4)输入命令，jps，可以看到相关信息 13、Web 访问，要先开放端口或者直接关闭防火墙(1)输入命令，systemctl stop firewalld.service(2)浏览器打开http://192.168.0.182:8088/(3)浏览器打开http://192.168.0.182:50070/ 14、安装完成。这只是大数据应用的开始，之后的工作就是，结合自己的情况，编写程序调用 Hadoop 的接口，发挥 hdfs、mapreduce 的作用。 12]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>linux</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互传工具]]></title>
    <url>%2F2017%2F12%2F11%2F%E8%BF%98%E5%9C%A8%E7%94%A8%E5%BE%AE%E4%BF%A1QQ%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%EF%BC%9F%E8%BF%9910%E4%B8%AA%E5%85%8D%E8%B4%B9%E4%BA%92%E4%BC%A0%E5%B7%A5%E5%85%B7%E5%93%AA%E4%B8%AA%E4%B8%8D%E6%AF%94%E5%AE%83%E4%BB%AC%E5%A5%BD%EF%BC%9F%EF%BC%81%2F</url>
    <content type="text"><![CDATA[还在用微信 QQ 传输文件？这 10 个免费互传工具哪个不比它们好？！如果你想把手机上的文件传输到电脑上，你一般会怎么做呢？连接数据线？借助 QQ 微信？毫无疑问这的确也是一种方法，但是也会用文件大小，传输速度等等的限制。其实除了上述的方法之外，还是有其他更为安全的方法，不妨来看看吧。 在列举其他方式之前，我们先来考虑一键事情，那就是在文件传输的时候，我们最注重的是什么？是传输速度?支持的文件大小？还是电脑与手机的匹配便捷性？其实小编觉得，在文件传输当中最担心的是什么呢？是丢失！ 当然了，如果手机不小心发生丢失文件的情况，我们也可以用专业的数据恢复软件【手机数据恢复精灵】尝试扫描恢复。 但是更好的方法是找到一款安全可靠的手机电脑传输工具，防止传输过程中数据丢失，小编今天就整理了一些 P2P 传输工具，这类服务通过浏览器或者便利的手机 App，便能在不同设备间进行快捷文件传输，十分方便，一起来看看吧。 1、Send Anywhere免费！免账号！相比于大多数传输工具需要同时在手机电脑登录来说这款工具实在是太方便了，并且，它是通过 P2P 直接从 A 设备传输到 B 设备文件没有储存在云端上，在安全性上也比较可靠。 Send Anywhere 目前拥有 Windows、 Mac、 Linux、 Android、 iOS 版本的传输软件，全部都可以免费下载，安装软件或 app 后，也不需要注册帐号就能直接使用！ 2、Reep.io以为免账号就最方便了？这款免软件就更打破你的一贯想法了。Reep.io 是一个直接利用网页，在不需登录、不需安装的情况下，就能通过 P2P 在两个人之间直接传送超大文件的服务，是不是很强大呢？ 3、Snapdrop一样同样是免软件免登录的一款工具，只需在同一 WIFI 环境下打开 Snapdrop 网页，就能侦测到彼此，并开始传输文件，十分方便。 4、AirMore相比于上述的工具，AirMore 这款工具最大的特点便是可以将安卓手机屏幕投影到电脑上，并进行传输文件。 5、Telegram相信很多人都以为，无限传输每次只能传输体积不大的文件，但是这款 Telegram 就不一样了，它可以一次传送 1.5GB 的大文件，普通一部电影不在话下，i 并且速度不仅快而且还十分稳定。 6、Portal除了 Telegram 之外，Portal 这款工具也可以快速地将大型文件在电脑与手机上进传输，只不过这款工具需要在手机上安装 App 才能使用。 7、XenderXender 同样是一款需要安装 App 才能使用的传输工具，但是好处是其提供了非常多样化的传输方式，可以帮助我们在安卓、iOS、任何系统电脑上进行文件的传输。 8、BT Sync提起 BT 传输，相信经常在电脑下载文件的小伙伴肯定不陌生了吧，这款 BitTorrent Sync 也是需要手机安装 App 来使用，不过好处是手机或是电脑中有新增文件的话，就会立刻传输到另一设备，十分方便。 9、file ai相比于上述的传输工具，这款 file ai 的特点便是可以同时传输给超过三人以上的朋友同事。，在远程办公中十分方便。 10、Pushbullet同样是主打群组文件传输的一个工具，在群组之间传送文件就会更加方便许多，不过有一点不好的便是需要账户登录，不比上述的工具方便。 看了以上这么多可以实现手机电脑文件互传的免费工具，是不是觉得该放弃已经 out 的微信 QQ 的文件传输呢？]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node配置]]></title>
    <url>%2F2017%2F12%2F10%2Fnode%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[标签： 插件 淘宝 npm 地址：http://npm.taobao.org/如何使用 有很多方法来配置 npm 的 registry 地址，下面根据不同情境列出几种比较常用的方法。以淘宝 npm 镜像举例： 1. 临时使用 npm –registry https://registry.npm.taobao.org install express 2. 持久使用 npm config set registry https://registry.npm.taobao.org 配置后可通过下面方式来验证是否成功 npm config get registry npm info express 3. 通过 cnpm 使用 npm install -g cnpm –registry=https://registry.npm.taobao.org 使用 cnpm install express 首先打开命令行终端 , 然后输入 npm config ls 这时你应该可以看到一个 prefix 属性 , 它表明了 npm 包的默认安装位置 , 因此可以通过改这个配置修改包安装位置 . 具体的命令如下 : npm config set prefix “your node_global path” 把引号内的内容改为你所希望的路径即可 . 比如我 : npm config ls; npm config set prefix “D:\configuration\nodeconfig\npm” npm config set cache “D:\configuration\nodeconfig\npm-cache”]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Config</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活]]></title>
    <url>%2F2017%2F12%2F10%2F%E6%B2%9F%E9%80%9A%E4%BA%A4%E6%B5%81%2F</url>
    <content type="text"><![CDATA[人生名言@RIchKing1，话别说太满，人别熟太快。 2，别人自嘲可以，但你千万别附和。 3，不要把别人想得太坏，也不要把别人想得太好，都是凡人。 4，可以嘲笑你的朋友，但不能嘲笑他喜欢的东西。 5，把每一句“我不会”都改成“我可以学”。 6，刚开始和对方不熟悉的时候，聊到晚上十点多对方发来消息就别回复了，第二天早晨再回复，这样又可以聊一天。 7，把“随便”改成“听你的”。 8，别人骂你你要听，别人夸你你别信。 9，请道歉而不是取笑别人开不起玩笑，你以为谁没有底线只不过还没到底而已。 10，聊天时别人发微笑，你不知道怎么回的话，就回，你笑得真好看。 11，能用表情包解决的就不要说脏话！ 12，恰到好处的装逼，适可而止的套路。 13，如果一个人不理你，有可能是对方的问题；如果大家都不理你，那你就要考虑自身问题了。 14，人前不应该说的话，背后也别说。 15，在最愤怒时忍住最伤人对方的那句话。 16，如果没有十足的把握和必要，就不要轻易说假话。 17，不要把负能量带给身边的人。 18，不要吝啬你的赞美和表达爱意的语言。 19，女孩子永远抗拒不了陪她通宵聊天的人。 20，刻薄嘴欠和幽默是两回事；口无遮拦和坦率是两回事；没有教养和随性是两回事；轻重不分和耿直是两回事。 21，真的不必把太多人请进生命里，太多热情总是不被珍惜。 22，如果遇到了傻 Ⅹ，不要与他争论，而且要同意他的一切观点，把他培养成大傻 Ⅹ。 23，把“听明白了吗”换成“我说明白了吗”。 24，不能侮辱别人的 idol，谨记！ 25，在拒绝这件事上，越简单越好，明明是别人需求自己帮忙，解释半天变成自己亏欠了别人的感觉，帮得上，想帮就帮，帮不上，就拒绝。人际交往，简单明了有时最恰当，懂得拒绝，才可以洒脱不纠结。 26，逢人只说三分话，未可全抛一片心。 27，不要在公众场合揭别人的短处，让别人难堪。 28，社交没那么容易，每个人都有他的手机。 29，看透不说透，还是好朋友。 30，当你往上爬的时候对别人好一点，因为你走下坡路的时候会遇到他们。 31，颜值要高，脾气要好，原则要有。 32，该叫阿姨的叫姐，该叫姐的叫美女该叫美女的叫妹子。 33，学会拒绝，没人会感激你的善良，他们只会得寸进尺。 34，自嘲是最高境界，而不是嘲笑别人。 35，请不要随意出卖一个朋友的隐私来取悦另一个不熟的朋友。 36，有分寸的信任，有理由的怀疑。 37，把身材练好，把妆化好。 38，不会讲话时别瞎说沉默微笑更好。 39，最印象的一句话，“交友不必言尽，言尽则无友”。 40，越是亲近的人越要用心对待，一句随意的话会伤害她。 41，修得豆腐嘴，藏得刀子心。 42，千万不要为了恋爱而淡了身边所有人。 43，清醒时做事，糊涂时读书，大怒时睡觉，独处时思考。 44，永远不要听信别人口中的他。 45，女生之间的嫉妒心太可怕，不要公开说这个女生比那个好看。 46，不要人后捅刀子嘴别贱。 47，践踏别人的梦想等同于谋杀。 48，常与同好争高下，不共傻瓜论短长。——出自《欢乐颂》]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>情商</tag>
        <tag>人际关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[压缩文件算法]]></title>
    <url>%2F2017%2F12%2F05%2F%E8%80%81%E5%8F%B8%E6%9C%BA%E5%91%8A%E8%AF%89%E4%BD%A0%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[老司机告诉你经常用到的压缩文件都是什么原理想必大家都用过压缩软件，这当然毫无争议。但一直在用的你，是否曾想过，文件压缩是怎样进行的？它利用了怎样的原理来进行压缩、加密的呢？ 今天，搞机百科就给你好好讲讲压缩文件的奥秘。 一、压缩原理 首先我们先来看看压缩原理，文件压缩分为有损压缩和无损压缩两种，我们常用的WinRAR、WinZip都是属于无损压缩，其基本原理都是一样的，简单地说也就是把文件中的重复数据用更简洁的方法表示，例如一个文件中有1000个字母A，那么这将占用1KB的数据空间，如果用压缩算法就可以用1000A来表示，那么它只需要5个字节的数据空间，压缩比达到了200倍，那么由此看来，1000倍甚至更高倍的压缩比是可以实现的，但要求源文件必须有足够多的重复数据。 不过，我们平时使用的文件都不可能是这样的，所以通常文件压缩比都在10倍以下，如果某个软件声称对任何文件都能够产生这种超高压缩比的话，那它肯定就是具有欺骗性质的了。 很多网上下载的文件只有300MB或400MB，但是解压后，居然可以达到2GB甚至更多，也许你会奇怪，为什么你用WinRAR压缩同样的文件，就没有这样的压缩效果呢？其实这是因为这些文件是用多款不同的压缩软件进行压缩的，用压缩音频最好的压缩软件压缩音频文件，用压缩动画最好的压缩软件压缩动画文件。而且在压缩时所选的参数也是最佳的，这样也就保证了最后生成的压缩文件是最小的。 二、加密原理 明白了压缩原理，接下来我们看看压缩文件的加密原理，通常的加密算法主要分为分组加密和序列加密。一般的数据加密可考虑采用3DES、AES等成熟的分组加密算法。 而各大压缩软件都会基于加组加密进行变种、特化的方式来形成自己的加密方式。比如WinRAR用的是自己修改过的AES（分组加密算法的一种），进行初始化加密，之后使用上一次加密的结果进行自定义的乱序加密。 下面我们就以WinRAR加密为例，说下压缩加密的原理。 Winrar加密文件时，步骤很简单，就两步：首先，先把源文件压缩，压成一段数据段。然后再将压缩完的数据段加密。 上文已经解释过压缩了，这里不再重复，那么如何加密“压缩完的数据段”呢？ 1、首先是获取密钥 获取密钥是明文的密码与Salt一起，通过HASH算法，生成两个16字节的密钥。（一个是KEY(AES算法的参数)，一个是initVector） 2、然后用Key和initVector来加密压缩数据 这是一个循环加密的结构，每16字节作为一个块，进行加密（这可能正是为什么加密完的文件长度总为16倍数的原因）。加密采用AES算法（RAR采用的是AES的rijndael的标准应用）。这里注意：AES加密前，有一个异或运算，是先将每16字节块与上一个16字节块加密结果进行异或，然后再进行AES算法的。 3、关于解密 由于AES算法是对称的，所以解密的过程，是加密过程的逆运算。但解密时AES算法过程与加密所用的不一样（是因为解密过程中由KEY生成的子密钥表不一样）。仍然需要我们将密码输入，与salt一起生成两个16字节密钥，KEY和initVector。 解密的过程是解密后的数据块进行解压缩，然后解成源文件，对该文件进行CRC校验，存在RAR文件中的源文件CRC校验码比较，相同则密码正确，不相同则密码错误。 三、压缩软件大搜罗 压缩软件是我们日常网络生活必备的工具之一，下面搞机百科就将目前市面上的多款压缩软件都搜罗来，让大家有更多的选择。 1、WinRAR 这个就不说了。 2、酷压：国产压缩先驱 作为国产压缩的革命先驱，酷压一直秉承着免费开源的理念，为后来大批的国产压缩软件的兴起提供了技术借鉴。但它不像其它厂商那样野蛮生长，在压缩格式上比较循规蹈矩，从不去触WinRAR的眉头。酷压发布之后，以其更小、更快、更好、更安全、更简洁迅速获得广大用户的青睐。但单一的功能性让酷压在国产压缩软件的围攻下逐渐销声匿迹，但它仍像一盏明灯，为国产压缩软件指引方向。 3、7-ZIP——老牌开源压缩软件 7-ZIP不用多说，是世界顶级开源跨平台压缩软件，曾经是WinRAR最大的对头。二者为到底是RAR格式优越，还是ZIP格式优越多年以来一直争执不休，也无法握手言和，相互兼容。但是唯独有点丑，所以常常被人忽略。其性能当然是强悍的。 ４、快压——生命力最旺盛的压缩软件 快压也是国产压缩软件大战时期诞生的，工具类软件普遍生存艰难，但是它却如此持久旺盛。如果在百度搜索压缩软件，排名第一的就是它的推广。还有它自己的装机联盟推广。而且还大有以其号称超高压缩比的KZ格式一统江湖之势。 快压广告较多，就它开展装机联盟来说，已经走了歪路，恐怕是打广告展示，主页锁定，流量劫持的歪主意。 ５、好压——全家桶大礼包 好压曾经是国内最好用的压缩软件没有之一，但是单纯工具类的软件生存艰难，最后只能寄人篱下。不仅令人扼腕。自被2345收购之后，可谓是得遇伯，春风得意，一副天际蓝把自己妆点的油头粉面。技术上在原有压缩功能的基础上开发了自解压和工具箱，工具箱集成了批量文件改名、虚拟光驱在内的小工具，也集成了2345浏览器，2345看图王，2345安全卫士在内的全家桶雷区。 ６、WinMount——不需要解压而直接使用压缩包内文件 WinMount是国人开发的一款压缩软件，说它是压缩软件不太准确，应该称之为可以不用解压而读取使用压缩包内文件的虚拟光驱。它同时也真的是一个虚拟光驱，可以加载使用ISO光盘文件。 它可以把 ZIP RAR ISO BIN MDF MNT 文件 mount 为一个新的盘符，这样你就可以直接使用里面的文件了， 不需要展开。节省时间，节省空间。WinMount 可以建一个空的2GB的盘，经常有人问这个有什么用。这个空盘实际上相当于一个 RAMDisk，就是在内存中的虚拟盘。所以它肯定速度快，但一关机就什么都没有了。它新建立的时候，即使是新建一个1GB的空盘，实际上不消耗什么内存。当有写操作时，才会逐渐申请内存。 ７、360压缩——带木马查杀的国产压缩软件 360总是有那么多鬼点子，当初凭借浏览器一个小小的收藏夹同步功能迅速占领广大用户。如今在压缩上也是以贴心的功能讨取用户欢心。独创的WinRAR界面和360界面无缝切换，使用户很快过度；贴心的木马查杀功能，让压缩软件内的病毒无处遁形。 在技术和功能上自不用说，依然全面而便捷。通过朝阳群众提供的RAR插件，能轻而易举对RAR格式进行各种操作。 ８、PeaZip——跨平台免费开源压缩软件 PeaZip是一款基于JAVA的开源跨平台软件，同时支持Windows和Linux系统。Windows自不用说，但是在Linux操作系统下要想找一款有头有脸的压缩软件，那就非它莫属了。 它支持除开RAR格式以外的大部分格式，还有自有格式PEA。操作上也与其它压缩软件大同小异。 9、FreeArc——强悍的加密功能 FreeArc同样是一款开源免费跨平台的压缩软件，它在汲取7-ZIP额优势基础上又有了很大的提升，速度上号称具有 WinRAR 、7-Zip 两倍以上的压缩速度，技术上集成了多种过滤器和压缩算法。它不仅支持数据恢复，还是支持AES+Twofish+Serpent算法加密，支持使用大于1GB的字典，支持使用外部压缩软件。 10、Bandizip——最美压缩软件 这是一款韩国公司Bandisoft开发的压缩软件，放在最后因为最近中韩关系紧张，但这的确是一款好软件。在国产压缩软件兴起之前，被认为是最好替代WinRAR的压缩软件之一。这款软件最近发布了6.0版本，颜值可谓是压缩软件巅峰的存在。 它有着漂亮的脸蛋，却不是中看不中用的花瓶。有着小巧的身材，全面的格式，便捷的操作。它支持WinZip、7-Zip 和 WinRAR 以及其它压缩格式。 看到这里，你是不是对压缩文件有了初步认识？你是否找到了心仪的压缩软件？如果这篇文章对你有点用处，希望继续关注智友搞机百科。]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>电脑</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常用代码合计]]></title>
    <url>%2F2017%2F12%2F02%2F%E5%89%8D%E7%AB%AF%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前端开发规范：命名规范、html规范、css规范、js规范ps:资料来自网络一个好的程序员肯定是要能书写可维护的代码，而不是一次性的代码，怎么能让团队当中其他人甚至一段时间时候你再看你某个时候写的代码也能看懂呢，这就需要规范你的代码了。我是有一点强迫症的人，上周我们后端给我了一个CanUsename的接口（该接口的目的是判断输入的目的地是否是4级目的地），我真的是崩溃的。我只是觉得这个名字不够语义化，但是让我自己想一个名字我又想不出来，于是我就在想，如果有一套命名规范的话，那么以后起名字就不用发愁了，直接按照规范来就好了~于是端午在家就百度了一下~ 命名驼峰式命名法介绍 Pascal Case 大驼峰式命名法：首字母大写。eg：StudentInfo、UserInfo、ProductInfo Camel Case 小驼峰式命名法：首字母小写。eg：studentInfo、userInfo、productInfo 文件资源命名 文件名不得含有空格 文件名建议只使用小写字母，不使用大写字母。( 为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。 ) 文件名包含多个单词时，单词之间建议使用半角的连词线 ( - ) 分隔。 引入资源使用相对路径，不要指定资源所带的具体协议 ( http:,https: ) ，除非这两者协议都不可用。 不推荐： 1&lt;script src=&quot;http://cdn.com/foundation.min.js&quot;&gt;&lt;/script&gt; 推荐 1&lt;script src=&quot;//cdn.com/foundation.min.js&quot;&gt;&lt;/script&gt; 变量命名命名方式 : 小驼峰式命名方法命名规范 : 类型+对象描述的方式，如果没有明确的类型，就可以使前缀为名词 类型 小写字母 array a boolean b function fn int i object o regular r string s 推荐 1var tableTitle = &quot;LoginTable&quot; 不推荐 1var getTitle = &quot;LoginTable&quot; 函数命名方式 : 小驼峰方式 ( 构造函数使用大驼峰命名法 )命名规则 : 前缀为动词 动词 含义 返回值 can 判断是否可执行某个动作 ( 权限 ) 函数返回一个布尔值。true：可执行；false：不可执行 has 判断是否含有某个值 函数返回一个布尔值。true：含有此值；false：不含有此值 is 判断是否为某个值 函数返回一个布尔值。true：为某个值；false：不为某个值 get 获取某个值 函数返回一个非布尔值 set 设置某个值 无返回值、返回是否设置成功或者返回链式对象 推荐： 123456789//是否可阅读function canRead()&#123; return true;&#125;//获取姓名function getName&#123; return this.name&#125; 常量命名方法 : 全部大写命名规范 : 使用大写字母和下划线来组合命名，下划线用以分割单词。推荐： 12var MAX_COUNT = 10;var URL = &apos;http://www.baidu.com&apos;; 类的成员 公共属性和方法 : 同变量命名方式 私有属性和方法 : 前缀为下划线(_)后面跟公共属性和方法一样的命名方式 推荐(将name换成this是不是更熟悉了呢) 12345678910111213141516function Student(name) &#123; var _name = name; // 私有成员 // 公共方法 this.getName = function () &#123; return _name; &#125; // 公共方式 this.setName = function (value) &#123; _name = value; &#125;&#125;var st = new Student(&apos;tom&apos;);st.setName(&apos;jerry&apos;);console.log(st.getName()); // =&gt; jerry：输出_name私有变量的值 注释规范单行注释 ( // ) 单独一行：//(双斜线)与注释文字之间保留一个空格 在代码后面添加注释：//(双斜线)与代码之间保留一个空格，并且//(双斜线)与注释文字之间保留一个空格。 注释代码：//(双斜线)与代码之间保留一个空格。 推荐 : 123456// 调用了一个函数；1)单独在一行setTitle();var maxCount = 10; // 设置最大量；2)在代码后面注释// setName(); // 3)注释代码 多行注释 ( / 注释说明 / ) 若开始(/*和结束(*/)都在一行，推荐采用单行注释 若至少三行注释时，第一行为/ 1* ，最后行为 1* /，其他行以 1* 开始，并且注释文字与 1* 保留一个空格。 推荐 : 12345/** 代码执行到这里后会调用setTitle()函数* setTitle()：设置title的值*/setTitle(); 函数 ( 方法 ) 注释函数(方法)注释也是多行注释的一种，但是包含了特殊的注释要求，参照 javadoc(百度百科)语法： 1234/** * 函数说明 * @关键字 */ 常用注释关键字 注释名 语法 含义 示例 @param @param 参数名 {参数类型} 描述信息 描述参数的信息 @param name {String} 传入名称 @return @return {返回类型} 描述信息 描述返回值的信息 @return {Boolean} true:可执行;false:不可执行 @author @author 作者信息 [附属信息：如邮箱、日期] 描述此函数作者的信息 @author 张三 2015/07/21 @version @version XX.XX.XX 描述此函数的版本号 @version 1.0.3 @example @example 示例代码 @example setTitle(‘测试’) 如下 推荐 : 12345678910111213141516171819/** - 合并Grid的行 - @param grid &#123;Ext.Grid.Panel&#125; 需要合并的Grid - @param cols &#123;Array&#125; 需要合并列的Index(序号)数组；从0开始计数，序号也包含。 - @param isAllSome &#123;Boolean&#125; ：是否2个tr的cols必须完成一样才能进行合并。true：完成一样；false(默认)：不完全一样 - @return void - @author polk6 2015/07/21 - @example - _________________ _________________ - | 年龄 | 姓名 | | 年龄 | 姓名 | - ----------------- mergeCells(grid,[0]) ----------------- - | 18 | 张三 | =&gt; | | 张三 | - ----------------- - 18 --------- - | 18 | 王五 | | | 王五 | - ----------------- -----------------*/function mergeCells(grid, cols, isAllSome) &#123; // Do Something&#125; HTML规范文档规范使用 HTML5 的文档声明类型 : &lt;!DOCTYPE html&gt; DOCTYPE标签是一种标准通用标记语言的文档类型声明，它的目的是要告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。 使用文档声明类型的作用是为了防止开启浏览器的怪异模式。 没有DOCTYPE文档类型声明会开启浏览器的怪异模式，浏览器会按照自己的解析方式渲染页面，在不同的浏览器下面会有不同的样式。 如果你的页面添加了&lt;!DOCTYP&gt;那么，那么就等同于开启了标准模式。浏览器会按照W3C标准解析渲染页面。 脚本加载说到js和css的位置，大家应该都知道js放在下面，css放在上面。但是，如果你的项目只需要兼容ie10+或者只是在移动端访问，那么可以使用HTML5的新属性async，将脚本文件放在&lt;head&gt;内兼容老旧浏览器(IE9-)时：脚本引用写在 body 结束标签之前，并带上 async 属性。这虽然在老旧浏览器中不会异步加载脚本，但它只阻塞了 body 结束标签之前的 DOM 解析，这就大大降低了其阻塞影响。而在现代浏览器中：脚本将在 DOM 解析器发现 body 尾部的 script 标签才进行加载，此时加载属于异步加载，不会阻塞 CSSOM（但其执行仍发生在 CSSOM 之后）。综上所述，所有浏览器中推荐: 12345678910&lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- body goes here --&gt; &lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 只兼容现代浏览器推荐: 123456789&lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt; &lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- body goes here --&gt; &lt;/body&gt;&lt;/html&gt; 语义化我们一直都在说语义化编程，语义化编程，但是在代码中很少有人完全使用正确的元素。使用语义化标签也是有理由SEO的。 语义化是指：根据元素其被创造出来时的初始意义来使用它。意思就是用正确的标签干正确的事，而不是只有div和span。 不推荐： 1234567891011121314151617181920212223242526272829&lt;b&gt;My page title&lt;/b&gt;&lt;div class=&quot;top-navigation&quot;&gt; &lt;div class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#home&quot;&gt;Home&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#news&quot;&gt;News&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;news-page&quot;&gt; &lt;div class=&quot;page-section news&quot;&gt; &lt;div class=&quot;title&quot;&gt;All news articles&lt;/div&gt; &lt;div class=&quot;news-article&quot;&gt; &lt;h2&gt;Bad article&lt;/h2&gt; &lt;div class=&quot;intro&quot;&gt;Introduction sub-title&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;This is a very bad example for HTML semantics&lt;/div&gt; &lt;div class=&quot;article-side-notes&quot;&gt;I think I&apos;m more on the side and should not receive the main credits&lt;/div&gt; &lt;div class=&quot;article-foot-notes&quot;&gt; This article was created by David &lt;div class=&quot;time&quot;&gt;2014-01-01 00:00&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;section-footer&quot;&gt; Related sections: Events, Public holidays &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;page-footer&quot;&gt; Copyright 2014&lt;/div&gt; 推荐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465html 代码:&lt;!-- The page header should go into a header element --&gt;&lt;header&gt; &lt;!-- As this title belongs to the page structure it&apos;s a heading and h1 should be used --&gt; &lt;h1&gt;My page title&lt;/h1&gt;&lt;/header&gt;&lt;!-- All navigation should go into a nav element --&gt;&lt;nav class=&quot;top-navigation&quot;&gt; &lt;!-- A listing of elements should always go to UL (OL for ordered listings) --&gt; &lt;ul&gt; &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#news&quot;&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;!-- The main part of the page should go into a main element (also use role=&quot;main&quot; for accessibility) --&gt;&lt;main class=&quot;news-page&quot; role=&quot;main&quot;&gt; &lt;!-- A section of a page should go into a section element. Divide a page into sections with semantic elements. --&gt; &lt;section class=&quot;page-section news&quot;&gt; &lt;!-- A section header should go into a section element --&gt; &lt;header&gt; &lt;!-- As a page section belongs to the page structure heading elements should be used (in this case h2) --&gt; &lt;h2 class=&quot;title&quot;&gt;All news articles&lt;/h2&gt; &lt;/header&gt; &lt;!-- If a section / module can be seen as an article (news article, blog entry, products teaser, any other re-usable module / section that can occur multiple times on a page) a article element should be used --&gt; &lt;article class=&quot;news-article&quot;&gt; &lt;!-- An article can contain a header that contains the summary / introduction information of the article --&gt; &lt;header&gt; &lt;!-- As a article title does not belong to the overall page structure there should not be any heading tag! --&gt; &lt;div class=&quot;article-title&quot;&gt;Good article&lt;/div&gt; &lt;!-- Small can optionally be used to reduce importance --&gt; &lt;small class=&quot;intro&quot;&gt;Introduction sub-title&lt;/small&gt; &lt;/header&gt; &lt;!-- For the main content in a section or article there is no semantic element --&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;This is a good example for HTML semantics&lt;/p&gt; &lt;/div&gt; &lt;!-- For content that is represented as side note or less important information in a given context use aside --&gt; &lt;aside class=&quot;article-side-notes&quot;&gt; &lt;p&gt;I think I&apos;m more on the side and should not receive the main credits&lt;/p&gt; &lt;/aside&gt; &lt;!-- Articles can also contain footers. If you have footnotes for an article place them into a footer element --&gt; &lt;footer class=&quot;article-foot-notes&quot;&gt; &lt;!-- The time element can be used to annotate a timestamp. Use the datetime attribute to specify ISO time while the actual text in the time element can also be more human readable / relative --&gt; &lt;p&gt;This article was created by David &lt;time datetime=&quot;2014-01-01 00:00&quot; class=&quot;time&quot;&gt;1 month ago&lt;/time&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/article&gt; &lt;!-- In a section, footnotes or similar information can also go into a footer element --&gt; &lt;footer class=&quot;section-footer&quot;&gt; &lt;p&gt;Related sections: Events, Public holidays&lt;/p&gt; &lt;/footer&gt; &lt;/section&gt;&lt;/main&gt;&lt;!-- Your page footer should go into a global footer element --&gt;&lt;footer class=&quot;page-footer&quot;&gt; Copyright 2014&lt;/footer&gt; alt标签不为空&lt;img&gt;标签的 alt 属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容。假设由于下列原因用户无法查看图像，alt 属性可以为图像提供替代的信息： 网速太慢 src 属性中的错误 浏览器禁用图像 用户使用的是屏幕阅读器 从SEO角度考虑，浏览器的爬虫爬不到图片的内容，所以我们要有文字告诉爬虫图片的内容 结构、表现、行为三者分离尽量在文档和模板中只包含结构性的 HTML；而将所有表现代码，移入样式表中；将所有动作行为，移入脚本之中。在此之外，为使得它们之间的联系尽可能的小，在文档和模板中也尽量少地引入样式和脚本文件。建议： 不使用超过一到两张样式表 不使用超过一到两个脚本（学会用合并脚本） 不使用行内样式（&lt;style&gt;.no-good {}&lt;/style&gt;） 不在元素上使用 style 属性（&lt;hr style=&quot;border-top: 5px solid black&quot;&gt;） 不使用行内脚本（&lt;script&gt;alert(&#39;no good&#39;)&lt;/script&gt;） 不使用表象元素（i.e. &lt;b&gt;, &lt;u&gt;, &lt;center&gt;, &lt;font&gt;, &lt;b&gt;） 不使用表象 class 名（i.e. red, left, center） HTML只关注内容 HTML只显示展示内容信息 不要引入一些特定的 HTML 结构来解决一些视觉设计问题 不要将img元素当做专门用来做视觉设计的元素 样式上的问题应该使用css解决 不推荐： 123456789101112&lt;!-- We should not introduce an additional element just to solve a design problem --&gt;&lt;span class=&quot;text-box&quot;&gt; &lt;span class=&quot;square&quot;&gt;&lt;/span&gt; See the square next to me?&lt;/span&gt;css 代码:.text-box &gt; .square &#123; display: inline-block; width: 1rem; height: 1rem; background-color: red;&#125; 推荐 1234567891011121314html 代码:&lt;!-- That&apos;s clean markup! --&gt;&lt;span class=&quot;text-box&quot;&gt; See the square next to me?&lt;/span&gt;css 代码:/* We use a :before pseudo element to solve the design problem of placing a colored square in front of the text content */.text-box:before &#123; content: &quot;&quot;; display: inline-block; width: 1rem; height: 1rem; background-color: red;&#125; 图片和 SVG 图形能被引入到 HTML 中的唯一理由是它们呈现出了与内容相关的一些信息。 不推荐 123456html 代码:&lt;!-- Content images should never be used for design elements! --&gt;&lt;span class=&quot;text-box&quot;&gt; &lt;img src=&quot;square.svg&quot; alt=&quot;Square&quot; /&gt; See the square next to me?&lt;/span&gt; 推荐 123456789101112131415html 代码:&lt;!-- That&apos;s clean markup! --&gt;&lt;span class=&quot;text-box&quot;&gt; See the square next to me?&lt;/span&gt;css 代码:/* We use a :before pseudo element with a background image to solve the problem */.text-box:before &#123; content: &quot;&quot;; display: inline-block; width: 1rem; height: 1rem; background: url(square.svg) no-repeat; background-size: 100%;&#125; js规范避免全局命名空间污染防止全局命名空间被污染，我们通常的做法是将代码包裹成一个 IIFE(Immediately-Invoked Function Expression)，创建独立隔绝的定义域。也使得内存在执行完后立即释放。 IIFE 还可确保你的代码不会轻易被其它全局命名空间里的代码所修改（i.e. 第三方库，window 引用，被覆盖的未定义的关键字等等）。不推荐: 123456var x = 10, y = 100;// Declaring variables in the global scope is resulting in global scope pollution. All variables declared like this// will be stored in the window object. This is very unclean and needs to be avoided.console.log(window.x + &apos; &apos; + window.y); 推荐 1234567891011// We declare a IIFE and pass parameters into the function that we will use from the global space(function(log, w, undefined)&#123; &apos;use strict&apos;; var x = 10, y = 100; // Will output &apos;true true&apos; log((w.x === undefined) + &apos; &apos; + (w.y === undefined));&#125;(window.console.log, window)); 推荐的IIFE写法: 123456(function()&#123; &apos;use strict&apos;; // Code goes here&#125;()); 如果你想引用全局变量或者是外层 IIFE 的变量，可以通过下列方式传参： 1234567(function($, w, d)&#123; &apos;use strict&apos;; $(function() &#123; w.alert(d.querySelectorAll(&apos;div&apos;).length); &#125;);&#125;(jQuery, window, document)); 严格模式ECMAScript 5 严格模式可在整个脚本或独个方法内被激活。它对应不同的 javascript 语境会做更加严格的错误检查。严格模式也确保了 javascript 代码更加的健壮，运行的也更加快速。 严格模式会阻止使用在未来很可能被引入的预留关键字。 你应该在你的脚本中启用严格模式，最好是在独立的 IIFE 中应用它。避免在你的脚本第一行使用它而导致你的所有脚本都启动了严格模式，这有可能会引发一些第三方类库的问题。 变量声明总是使用 var 来声明变量。如不指定 var，变量将被隐式地声明为全局变量，例如 1var a = b = 0; //b会被隐式的创建为全局变量 所以，请总是使用 var 来声明变量，并且使用单var模式（将所有的变量在函数最前面只使用一个var定义）。例如： 123456789(function ()&#123; &apos;use strict&apos; var a = 0, b = 0, c = 0, i, j, myObject();&#125;()) 采用严格模式带来的好处是，当你手误输入错误的变量名时，它可以通过报错信息来帮助你定位错误出处。 js声明提前javascript会自动将函数作用域内的变量和方法的定义提前（只是提前声明，赋值还是在原处）例如： 1234567891011121314151617181920212223(function(log)&#123; &apos;use strict&apos;; var a = 10; for(var i = 0; i &lt; a; i++) &#123; var b = i * i; log(b); &#125; if(a === 10) &#123; var f = function() &#123; log(a); &#125;; f(); &#125; function x() &#123; log(&apos;Mr. X!&apos;); &#125; x();&#125;(window.console.log)); 提升后的js 12345678910111213141516171819202122232425262728293031(function(log)&#123; &apos;use strict&apos;; // All variables used in the closure will be hoisted to the top of the function var a, i, b, f; // All functions in the closure will be hoisted to the top function x() &#123; log(&apos;Mr. X!&apos;); &#125; a = 10; for(i = 0; i &lt; a; i++) &#123; b = i * i; log(b); &#125; if(a === 10) &#123; // Function assignments will only result in hoisted variables but the function body will not be hoisted // Only by using a real function declaration the whole function will be hoisted with its body f = function() &#123; log(a); &#125;; f(); &#125; x();&#125;(window.console.log)); 使用严格等总是使用 === 精确的比较操作符，避免在判断的过程中，由 JavaScript 的强制类型转换所造成的困扰。例如： 1234567891011121314151617(function(log)&#123; &apos;use strict&apos;; log(&apos;0&apos; == 0); // true log(&apos;&apos; == false); // true log(&apos;1&apos; == true); // true log(null == undefined); // true var x = &#123; valueOf: function() &#123; return &apos;X&apos;; &#125; &#125;; log(x == &apos;X&apos;);&#125;(window.console.log)); 等同== 和严格等===的区别 ==， 两边值类型不同的时候，要先进行类型转换，再比较。 ===，不做类型转换，类型不同的一定不等。 ==等同操作符 如果两个值具有相同类型，会进行===比较，返回===的比较值 如果两个值不具有相同类型，也有可能返回true 如果一个值是null另一个值是undefined，返回true 如果一个值是string另个是number，会把string转换成number再进行比较 如果一个值是true，会把它转成1再比较，false会转成0 1234567891011121314151617console.log( false == null ) // falseconsole.log( false == undefined ) // falseconsole.log( false == 0 ) // trueconsole.log( false == &apos;&apos; ) // trueconsole.log( false == NaN ) // falseconsole.log( null == undefined ) // trueconsole.log( null == 0 ) // falseconsole.log( null == &apos;&apos; ) // falseconsole.log( null == NaN ) // falseconsole.log( undefined == 0) // falseconsole.log( undefined == &apos;&apos;) // falseconsole.log( undefined == NaN) // falseconsole.log( 0 == &apos;&apos; ) // trueconsole.log( 0 == NaN ) // false 总结一下== false 除了和自身比较为 true 外，和 0，”” 比较也为 true null 只和 undefined 比较时为 true， 反过来 undefined 也仅和 null 比较为 true，没有第二个 0 除了和 false 比较为 true，还有空字符串 ‘’” 和空数组 [] 空字符串 ‘’ 除了和 false 比较为 true，还有一个数字 0 ==, &gt;, &lt;, +, -, … 这些操作符所造成的隐式类型转换都是无副作用的，它不会改变变量本身保存的值。，但是，如果你覆写某个对象的 valueOf/toString的话，==就会产生副作用. 例如： 1234567Array.prototype.valueOf = function() &#123; this[0]++; return this;&#125;var x = [1, 2, 3];x == 0;console.log(x); // [2, 2, 3] ===操作符： 要是两个值类型不同，返回false 要是两个值都是number类型，并且数值相同，返回true 要是两个值都是stirng，并且两个值的String内容相同，返回true 要是两个值都是true或者都是false，返回true 要是两个值都是指向相同的Object，Arraya或者function，返回true 要是两个值都是null或者都是undefined，返回true 真假判断 js中以下内容为假： false null undefined 0 ‘’ (空字符串) NaN 设置默认参数辑操作符 || 和 &amp;&amp; 也可被用来返回布尔值。如果操作对象为非布尔对象，那每个表达式将会被自左向右地做真假判断。基于此操作，最终总有一个表达式被返回回来。这在变量赋值时，是可以用来简化你的代码的。例如:如果x不存在且y不存在，x=1；如果x存在y存在，x = y 1234567if(!x) &#123; if(!y) &#123; x = 1; &#125; else &#123; x = y; &#125;&#125; 等同于： 1x = x || y || 1; 这一小技巧经常用来给方法设定默认的参数。 12345678910111213141516(function(log)&#123; &apos;use strict&apos;; function multiply(a, b) &#123; a = a || 1; b = b || 1; log(&apos;Result &apos; + a * b); &#125; multiply(); // Result 1 multiply(10); // Result 10 multiply(3, NaN); // Result 3 multiply(9, 5); // Result 45&#125;(window.console.log)); 不使用eval()函数就如eval的字面意思来说，恶魔，使用eval()函数会带来安全隐患。eval()函数的作用是返回任意字符串，当作js代码来处理。 this关键字只在对象构造器、方法和在设定的闭包中使用 this 关键字。this 的语义在此有些误导。它时而指向全局对象（大多数时），时而指向调用者的定义域（在 eval 中），时而指向 DOM 树中的某一节点（当用事件处理绑定到 HTML 属性上时），时而指向一个新创建的对象（在构造器中），还时而指向其它的一些对象（如果函数被 call() 和 apply() 执行和调用时）。 正因为它是如此容易地被搞错，请限制它的使用场景： 在构造函数中 在对象的方法中（包括由此创建出的闭包内） 首选函数式风格函数式编程让你可以简化代码并缩减维护成本，因为它容易复用，又适当地解耦和更少的依赖。 接下来的例子中，在一组数字求和的同一问题上，比较了两种解决方案。第一个例子是经典的程序处理，而第二个例子则是采用了函数式编程和 ECMA Script 5.1 的数组方法。不推荐 123456789101112131415(function(log)&#123; &apos;use strict&apos;; var arr = [10, 3, 7, 9, 100, 20], sum = 0, i; for(i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; log(&apos;The sum of array &apos; + arr + &apos; is: &apos; + sum)&#125;(window.console.log)); 推荐(函数式编程)： 123456789101112(function(log)&#123; &apos;use strict&apos;; var arr = [10, 3, 7, 9, 100, 20]; var sum = arr.reduce(function(prevValue, currentValue) &#123; return prevValue + currentValue; &#125;, 0); log(&apos;The sum of array &apos; + arr + &apos; is: &apos; + sum);&#125;(window.console.log)); 修改内建对象的原型链修改内建的诸如 Object.prototype 和 Array.prototype 是被严厉禁止的。修改其它的内建对象比如 Function.prototype，虽危害没那么大，但始终还是会导致在开发过程中难以 debug 的问题，应当也要避免。 三元条件判断（if 的快捷方法）用三元操作符分配或返回语句。在比较简单的情况下使用，避免在复杂的情况下使用。没人愿意用 10 行三元操作符把自己的脑子绕晕。不推荐： 12345if(x === 10) &#123; return &apos;valid&apos;;&#125; else &#123; return &apos;invalid&apos;;&#125; 推荐： 1return x === 10 ? &apos;valid&apos; : &apos;invalid&apos; JSHint在js规范中，有很多规范都是样式上的规范而不是逻辑上的规范，比如尽量使用===而不是==，我们可以使用JSHint或者JSLint，Javascript代码验证工具，这种工具可以检查你的代码并提供相关的代码改进意见。我个人使用的是JSHint，所以就以这个为例 webstorm内置JSHint对于ws爱好者来说，我没有用过其他的编译器，ws基本上能满足你的所有需求（最新的ws集成了vue）。在Settings =&gt; language &amp; frameworks =&gt; JavaScript =&gt; Code Quality Tolls =&gt; JSHint webstorm中的jshint 官方文档 名称 含义 curly 循环或者条件语句必须使用花括号包住 eqeqeq 使用强制等=== newcap 对于首字母大写的函数（声明的类），强制使用new noarg 禁用arguments.caller和arguments.callee sub 对于属性使用aaa.bbb而不是aaa[‘bbb’] undef 查找所有未定义的变量 boss 查找类似与if(a = 0)这样的代码 node 指定运行环境为node strict 必须使用严格模式 asi 允许省略分号 bitwise 禁止使用位运算符，比如经常把&amp;&amp;写错&amp; 规避此错误 jquery 定义全局暴露的jQuery库 evil 禁止使用eval maxdepth 嵌套的最大深度 maxparams 参数的最大个数 css规范id和class的命名ID和class的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称不推荐 : 1234567.fw-800 &#123; font-weight: 800;&#125;.red &#123; color: red;&#125; 推荐 : 1234567.heavy &#123; font-weight: 800;&#125;.important &#123; color: red;&#125; 合理的使用ID一般情况下ID不应该被用于样式，并且ID的权重很高，所以不使用ID解决样式的问题，而是使用class不推荐： 123#content .title &#123; font-size: 2em;&#125; 推荐： 123.content .title &#123; font-size: 2em;&#125; css选择器中避免使用标签名从结构、表现、行为分离的原则来看，应该尽量避免css中出现HTML标签，并且在css选择器中出现标签名会存在潜在的问题。 使用子选择器很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到DOM末端的选择器， 你应该总是考虑直接子选择器。不推荐: 123.content .title &#123; font-size: 2rem;&#125; 推荐 123.content &gt; .title &#123; font-size: 2rem;&#125; 尽量使用缩写属性尽量使用缩写属性对于代码效率和可读性是很有用的，比如font属性。不推荐： 12345678border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0; 推荐： 123border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em; 0后面不带单位省略0后面的单位，不推荐： 12padding-bottom: 0px;margin: 0em; 推荐： 12padding-bottom: 0;margin: 0; 属性格式 为了保证一致性和可扩展性，每个声明应该用分号结束，每个声明换行。 属性名的冒号后使用一个空格。出于一致性的原因，属性和值（但属性和冒号之间没有空格）的之间始终使用一个空格。 每个选择器和属性声明总是使用新的一行。 属性选择器或属性值用双引号（””），而不是单引号（”）括起来。 URI值（url()）不要使用引号。 作为最佳实践，我们应该遵循以下顺序（应该按照下表的顺序）： 结构性属性： display position, left, top, right etc. overflow, float, clear etc. margin, padding 表现性属性： background, border etc. font, text 不推荐： 1234567891011121314 .box &#123; font-family: &apos;Arial&apos;, sans-serif; border: 3px solid #ddd; left: 30%; position: absolute; text-transform: uppercase; background-color: #eee; right: 30%; isplay: block; font-size: 1.5rem; overflow: hidden; padding: 1em; margin: 1em;&#125; 推荐： 1234567891011121314.box &#123; display: block; position: absolute; left: 30%; right: 30%; overflow: hidden; margin: 1em; padding: 1em; background-color: #eee; border: 3px solid #ddd; font-family: &apos;Arial&apos;, sans-serif; font-size: 1.5rem; text-transform: uppercase;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活]]></title>
    <url>%2F2017%2F12%2F01%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%8C%E5%BA%94%E5%BD%93%E6%8F%90%E5%89%8D%E6%8E%8C%E6%8F%A1DIV%2BCSS%E5%B8%83%E5%B1%80%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[编程零基础入门前端开发工程师，应当提前掌握 DIV+CSS 布局规范样式命名规范 id 选择器常用命名规范 类选择器常用命名规范 全局样式设置 1.全局样式置顶，并用注释标注为/全局样式/ 2.用一内容定义的样式写在一起，并用注释标注 3.一个样式里面，多个属性的定义建议写在一行，属性定义之间用”；”隔开 4.样式中类或者 id 选择器的命名建议使用样式命名规范来书写 5.自定义选择器名称建议都用小写、尽量使用英文单词，少用拼音，名称中建议少用”-“或者”_“,尽量少用英文缩写。 /_ 全局样式部分 _/123456789101112131415161718192021222324252627282930313233343536373839404142* &#123; padding: 0; margin: 0; font-size: 12px; font-family: "宋体";&#125;ul,li,dl,dt,dd,h1,h2,h3,h4,h5,h6,form,p &#123; padding: 0; margin: 0;&#125;ul &#123; list-style: none;&#125;img &#123; border: 0px;&#125;a &#123; text-decoration: none;&#125;.clearfloat &#123; clear: both; height: 0px; font-size: 1px; line-height: 0px;&#125; html 文档书写规范 1.html 标签代码书写应遵循 xhtml 规范： a.Html 标签要全部小写 b.标签嵌套要对应 c.成对标签必须关闭，单个标签也需要关闭，如”&lt;…./&gt;” d.标签属性需要用引号，且不能简写，如: 规范写法：&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt; 不规范写法：&lt;input type=&quot;checkbox&quot; checked /&gt; 2.同一模块的 html 代码用注释包含,如： 12345&lt;div id="logobar"&gt;.....&lt;/div&gt; 3.Html 通过首行缩进来体现代码结构，如： 12345678910&lt;div id="main_nav"&gt; &lt;ul&gt; &lt;li&gt; &lt;a href="#"&gt;首 页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;企业招聘&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 4.Img 标签需加上”alt”属性]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>编程</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理缓存]]></title>
    <url>%2F2017%2F12%2F01%2F%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[标签： 编程 在 web 项目开发过程中，我们经常会引用 css、js 文件，更新文件后常出现缓存问题（明明更改了代码，在浏览器上访问的时候却没有发生变化），这种情况我们通常采用以下两种解决方案： 手动清除浏览器缓存 添加版本号（如 layout.css?v=1）个人认为方法 2 更快，因为清除浏览器缓存还要等浏览器响应。但是每次更改版本号也很麻烦，所以需要想办法自动添加版本号，以下是本人收集的方法：方法一：可以通过 js 自动给 html 添加版本号 123 &lt;script type="text/javascript"&gt; document.write("&lt;link rel='stylesheet' type='text/css' href='/css/layout.css?v="+new Date().getTime()+"'&gt;");&lt;/script&gt; 方法二：若是 jsp 页面，可以使用 java 代码生成时间戳（若是 jsp 页面用方法一也行，但此方法更方便） 1&lt;link rel="stylesheet" type="text/css" href="/css/layout.css?v=&lt;%=System.currentTimeMillis() %&gt;"&gt; 方法三：使用其他的方法添加版本号，如用 node.js 自动配置等ps：我们清除缓存的目的是为了及时看到页面的更新情况，当我们将页面上线时（即部署到正式环境，不会再做更改），建议把版本号固定，因为有缓存的页面访问更快，需要更新的时候再更换下固定版本号。]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Programming</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jrebel插件]]></title>
    <url>%2F2017%2F11%2F30%2FJrebel%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Jrebel插件标签： 插件 IntelliJ IDEA 的 Java 热部署插件 JRebel 安装及使用JRebel 介绍在 Java Web 开发中， 一般更新了 Java 文件后要手动重启 Tomcat 服务器， 才能生效， 浪费不少生命啊， 自从有了 JRebel 这神器的出现， 不论是更新 class 类还是更新 Spring 配置文件都能做到立马生效，大大提高开发效率。 JRebel 安装 JRebel 的安装方法有两种， 一种是直接在 Tomcat 启动参数上面加上 JRebel 的参数， 另外一种是以插件的形式装到 IntelliJ IDEA 上， 比较推荐后者。 第一种安装方法：在 Tomcat 启动参数上加参数首先先介绍第一种安装方法， 先在硬盘某个位置把 JRebel 解压出来先配置一下本地tomcat 默认显示如图 几个关键的地方需要注意的， 就是首先要选择Deployment 这个选项卡 选择自己的项目， 建议选择带 exploded， 这个相当于改 Tomcat 的 CATALINA_HOME， 效率比较高选择好后， 删掉默认的Make， 提高效率 接下来返回 Server 选项卡， 会发现多了一项 On frame deactivation， 如果你刚才没有配置 Deployment 选项卡的话的这项是不会出现的 按如图所示的来配置， 特别需要注意的是 On &#39;Update&#39; action 和On frame deactivation这两项目一定要选择 Update classes and resources， 否则类修改热部署不生效， 或者第三方模版框架例如 Freemarker 热部署不生效 接下来就是很关键的需要引入 JRebel 的地方了， 在 VM options 的最右边有个箭头， 点进去Windows 输入:1-agentpath:D:/dev_env/jrebel/jrebel_running/lib/jrebel64.dll 第二种安装方法：使用 IntelliJ IDEA 插件下载安装jrebel 然后注册 Jrebel 激活方法 确保你可也访问国外网站（www.facebook.com）,并确保你有一个facebook账号或者Twitter账号(没有的话注册一个) 访问 https://my.jrebel.com/ 选择自己的facebook账号登录完成后 3 将激活码复制到Intellij Idea Rrebel激活4 查看当前Jrebel状态，绿色图标表示激活状态 激活完毕 ### 运行在原来运行项目的按钮边上会多出两个绿色的按钮， 如图， 前面那个是 Run， 后面那个是Debug 配置 Tomcat 的方法和直接上面说的直接调用配置方法一样， 同样需要注意的是On &#39;Update&#39; action和 On frame deactivation这两项目一定要选择Update classes and resources， 唯一不同的是VM options 这项不需要填， 放空就好 接下来直接启动项目， 一般选择后面那个Debug 按钮看到 Log 有 JRebel 输出的版本信息， 没有报错就是表示成功执行了 配置springboot先安装jrebel,配置好后: Idea中ctrl+alt+shift+/弹出 进入registry 进入如下界面 将compiler.automake.allow.when.app.running 选中,退出该界面 在项目的src/resources文件夹右键,弹出菜单最下边JReble&gt;rebel.xml 打开刚刚生成的rebel.xml文件,将classpath dir修改到你项目的build文件夹 在启动类中右键,使用Jrebel（Debug | run）进行启动配置该项目 启动后呢,修改了代码,直接编译Build&gt;build project,刷新一下网页就可以看到效果了,尽情的享受不重启服务器带来的快感吧！]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小工具]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%B0%8F%E5%B7%A7%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%EF%BC%8C%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84%E5%8A%9E%E5%85%AC%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[小巧好用的工具软件推荐，提升你的办公学习效率1. everythingeverything一款文件搜索神器。只要输入相应的关键字，Everything就实时把系统里所有匹配关键字的结果都显示出来，选中文件右键菜单操作即可执行打开文件等操作，方便快捷。 官网地址：http://www.voidtools.com/ 下载地址：① http://www.voidtools.com/downloads/ ② http://rj.baidu.com/soft/detail/17239.html 特点： Everything文件检索速度极快，实时显示检索结果。 快捷方便，支持正则表达式等搜索技巧。 文件小巧，占用资源小。 运行效果： everything 2. cloverClover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。 官网地址：http://cn.ejie.me/ 下载地址：① http://ejie.me/uploads/setup_clover@3.3.2.exe ② http://rj.baidu.com/soft/detail/17870.html 特点： 方便的 Tab 页功能 要掌握功能强大，操作简单的标签页，只需记住Ctrl+T新开页面，Ctrl+W关闭页面，Ctrl+Tab切 换页面，工作效率提高何止一倍！ 操作系统无缝集成 通过插件的形式集成到 Windows Explorer，保留您通常的使用习惯，无需学习新的文件管理操 作，马上就可以使用。 快如闪电的书签栏 按Ctrl+D添加当前路径，或者直接将文件夹拖入书签栏。再也不用到处寻找要访问的文件夹了， 瞬间到达，何等痛快！ 运行效果： clover 3. cmder一款好看并且好用的终端模拟器，可以很好的替换系统cmd命令窗口。 官网地址：http://cmder.net/ 下载地址：http://www.softpedia.com/get/Programming/Other-Programming-Files/Cmder.shtml 特点： 多窗口管理，支持Tab多页标签，一个窗体中可以创建多个cmd标签页； 窗体size大小便捷缩放； 复制粘贴文本方便 页面比系统cmd窗口更加美观，文字支持颜色区分 运行效果： cmder 4. Notepad++Notepad++ 是一款非常有特色的编辑器，并且是一款开源软件，可以免费使用。支持的语言: C, C++ , Java , C#, XML, HTML, PHP, Javascript！不论是日常使用还是手写编程代码，都能让你体会到它独有的优势和方便。 官网地址：https://notepad-plus-plus.org/ 下载地址：① https://notepad-plus-plus.org/download/v7.3.3.html ② http://rj.baidu.com/soft/detail/13478.html 源码地址：https://github.com/notepad-plus-plus/notepad-plus-plus 特点： 支持多种语法高亮度显示，也支持自定义语言； 支持自动检测文件类型，根据关键字显示节点，节点可自由折叠/打开，代码显示得非常有层次感； 支持打开双窗口，在分窗口中又可打开多个子窗口； 支持快捷切换全屏显示模式(F11)，支持鼠标滚轮改变文档显示比例； 运行效果： Notepad++ 5. ScreenToGifgif录制剪辑工具。一款能够把电脑屏幕上的动态视频/特效等内容，通过录制剪辑下来，然后转换为gif动态图片的工具。 官网及下载地址：http://screentogif.codeplex.com/ 特点： 录制屏幕指定区域，支持可自行选择录制区域，直接保存为gif动画文件； 支持暂停或继续录制； 在录制过程中可继续运行其他应用或窗口； 可删除边框； 选择一个文件夹来保存文件或直接将文件保存至桌面； 可在录制文件中添加系统光标； 运行效果： Screen To Gif主界面 Screen To Gif编辑界面 6. SnipasteSnipaste，根据字面意思就是“Snip + Paste ，截图 + 贴图”，是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上。 官网及下载地址：https://zh.snipaste.com/ 特点： 强大的截图功能； 把图片作为窗口置顶显示； 方便的编辑图像功能； 支持自定义设置； 运行效果： Snipaste 7. Typora一款极致简洁的markdown编辑器。 官网及下载地址：https://www.typora.io/ 特点： Typora 支持图片、列表、表格、代码、公式、目录等功能，并且有多种主题模板 运行效果： Typora—源码编辑模式 Typora—浏览编辑模式 8. Beyond CompareBeyond Compare是一套由Scooter Software推出的软件，主要用途是对比两个文件夹或者文件，并将差异以颜色标示。 对于程序猿来说，可以将其与svn、git等工具结合，对代码进行版本差异性比较。 官网及下载地址：http://www.scootersoftware.com/ 运行效果： Beyond Compare主界面 Beyond Compare文件列表界面 Beyond Compare文件差异比较界面 说明：以上所列出来的软件均为自己平时工作学习常用的一些软件，感觉还不错，推荐分享给大家。如果大家还有什么好的工具软件，欢迎留言补充，谢谢！ （人人必备）电脑增强工具精选马车夫 2017-02-10 12:07:15 Windows是现阶段大家用的最广泛的OS之一，但是它本身也有自己的不足或者说不方便的地方，这是我们就需要用第三方工具加以增强，让Windows拥有和Mac一样的易用性。以下是本人多年积累的经验成果。 1.鼠标手势工具——WGestures 这个工具非常强大，有很多功能，而且还支持自定义，让你的鼠标无比强大。无疑是增加效率的必备神器，鼠标党的福音。 2.文件预览工具——Seer 对于习惯了使用 Mac 的同学，平常可能并不会注意到「预览」这个贴心的小功能，但在切换到 Windows 系统工作时才会感觉到好像少了点什 么！！于是，终于有程序员对此“不满”，并为此特意为开发了Seer！ 3.文件浏览增强—— Listary Pro Listary Pro是一款由美利坚著名Bopsoft软件科技公司专注设计与制作开发的功能实用且体积小巧的视窗操作系统文件浏览与搜索增强工具，能够有效地 帮助用户为微软 Windows 系统的文件浏览对话框、资源管理器等添加非常便捷的文件快速定位、实时全盘搜索、常用文件夹收藏、打开历史、快速切换到 已 打开的路径、快捷右键菜单等一系列独树一帜、别具一格的拓展功能。【双击Ctrl即可唤醒，方便快捷】 4.文件批量重命名——FFRename Pro 功能强大的批量重命名工具，是我用过十几个同类工具中最好的。 5.hosts自动在线更新工具——Hozz 这款工具涉及墙不便多说，有意愿了解者。加微信公众号shareCHN，回复hozz即可获取详细资讯。 6.完全卸载工具——Total Uninstall Pro Total Uninstall (完全卸载) 是一个十分实用的软件安装监视器和卸载器，它可以监视软件安装程序对系统进行的所有更改，包括注册表和文件系统，在卸载软件时可以把系统恢复到软件安装之前的状态，不会留下任何垃圾。 7.PE工具——微PE 微PE相对其他同类工具易用，而且绝对纯净无残留。 Windows Mac 鼠标 笔记本电脑 程序员]]></content>
      <categories>
        <category>Tools, config, windows</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码库]]></title>
    <url>%2F2017%2F10%2F22%2F%E7%AC%BC%E7%BB%9F%E7%9A%84%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9A%84%E5%90%84%E7%A7%8D%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[笼统的前端——前端技术的各种知识点总结核心 Core HTML(HTML5) CSS(CSS3) JavaScript jQuery ES6 插件 包管理工具 Package Managers NPM Bower Yarn 前端性能 Front-End Performance WebPagetest PerfBudget CriticalCSS Picturefill 编辑器 Text Editors WebStorm VScode Sublime Text Atom HBuilder JS框架 JS Frameworks Backbone AngularJs React Vue UI框架 UI Frameworks Bootstrap Ionic Foundation FrozenUI materializecss mui Ant Design eleme JS预处理 JS Preprocessors TypeScript CoffeeScript Babel 响应式网页 Responsible WEB Design 渐进增强、可访问性 过程自动化 Process Automation Grunt Gulp 模板引擎 Templating Handlebars Haml Jade 代码质量 Code Quality JSCS ESLint 浏览器刷新 Browser Refreshing LiveReload Guard 构建工具 Build Tools RequireJS seajs Browserify Webpack CSS预处理器 CSS Preprocessors Sass Less stylus 后端 Back-End nodeJS PHP 版本控制 Version Control Git Svn 代码测试 Testing CSS设计模式 OOCSS &amp; Style Guides MVCSS 核心 Core HTML5 W3C http://www.w3school.com.cn/html5/ W3C https://www.w3.org/html/ig/zh/wiki/HTML5 菜鸟教程 http://www.runoob.com/html/html5-intro.html HTML5中文门户 http://www.html5cn.org/ CSS3 W3C CSS教程 http://www.w3school.com.cn/css/index.asp W3C CSS3教程 http://www.w3school.com.cn/css3/index.asp 菜鸟教程CSS教程 http://www.runoob.com/css/css-tutorial.html 菜鸟教程CSS3教程 http://www.runoob.com/css3/css3-tutorial.html CSS参考手册 http://css.doyoe.com/ JS W3C http://www.w3school.com.cn/js/ 菜鸟教程 http://www.runoob.com/js/js-tutorial.html 廖雪峰js教程 http://www.liaoxuefeng.com js标准参考教程-阮一峰http://javascript.ruanyifeng.com/ jQuery W3C http://www.w3school.com.cn/jquery/ 菜鸟教程 http://www.runoob.com/jquery/jquery-tutorial.html 极客学院 http://wiki.jikexueyuan.com/project/jquery-tutorial/ 廖雪峰 http://www.liaoxuefeng.com/wiki/ 参考手册 http://www.css88.com/jqapi-1.9/ 参考手册 http://www.runoob.com/manual/jquery/ ES6 阮一峰ES6 http://es6.ruanyifeng.com/ 极客学院 http://wiki.jikexueyuan.com/project/es6/ JavaScript 标准参考 阮一峰http://javascript.ruanyifeng.com/advanced/ecmascript6.html 插件 parallel.js: 前后端通用的一个并行库 zepto: 用于现代浏览器的兼容 jQuery 的库 totoro: 稳定的跨浏览器测试工具 TheaterJS: 一个用于模拟人输入状态的 JS 库 stellar.js: 前端用于实现异步滚动效果的库，现已不再维护 skrollr: 另一款实现一步滚动的开源库，使用人数众多，可实现各种狂拽酷炫掉渣天的前端效果，看真相 Framework7: 前端框架，是开发人员可以基于 web 技术构建 IOS7 程序 regulex: 用于生成 正则表达式 的可视化流程图 markdown-it: 新型 Markdown 解析器，快速，支持插件 multiline: 用于 Javascript 中的多行文本，类似于 Ruby 的 HERE Doc screenfull.js: 全屏插件，支持各大浏览器 lunr.js: 类似于 Solr, 但是用于浏览器上的全文搜索引擎，可以为 JSON 创建索引，离线也可以使用 jquery.hotkeys: jQuery 插件，用于绑定热键 breach_core: Javascript 编写的 Browser (浏览器) octocard: 用于生成 Github 信息卡片的库 github-cards: 用于生成 Github 信息卡片的库 money.js: 轻量级货币转换库，web 和 node 皆可用 accounting.js: 轻量级的数字、货币转换库 javascript-algorithms: Javascript 实现的各种算法集合 lazy.js: 类似于 underscore, 但是会延迟执行，某些场景下，性能会有很大的提升 seajs: 前端模块加载器，解决模块化、依赖等问题 jQuery-One-Page-Nav: 单页应用中一个用于处理导航栏的库 js.js: Javascript 实现的 javascript JIT jquery-ui: jQuery 团队开发的 UI 相关的前端库，功能强大 todomvc: 分别基于 AngularJS/EmberJS/Backbone等实现的 TODO List, 帮助开发者选择前端 MVC 库 localForage: Mozilla 出品，用于离线存储，基于IndexedDB, WebSQL 或者 localStorage, 提供一致的接口 EventEmitter: 浏览器版的 EventEmitter jquery.serializeJSON: jQuery 插件，用于将 form 表单序列化成 JSON 数据 knockout: 前端 MVVM 框架，用于开发富前端应用 mermaid: 可以根据文本生成流程图，类似于 Markdown 的语法 js-sequence-diagrams: 另一款可以根据文本生成流程图的库，类似于 Markdown 的语法 flow: 一个用来检测 Javascript 语法错误的库， Facebook 出品 zoomooz: jQuery 插件，用来处理浏览器缩放 fancyBox: 一个用于放大缩小图片、Web 内容或者多媒体元素的库，优雅大方 mithril.js: 轻量型前端 MVC 框架，部分使用场景下性能优于 Angular.js 和 React backbone: 强大的前端 MVC 库，鼻祖级前端库，最初为了配合 Rails 来模块化前端应用，兼容性良好 (兼容到 IE6)，插件丰富，性能良好 jquery.smartbanner: smartbanner 是从 IOS6 开始支持的一个新特性, 这个插件提供了对早期 IOS4/5 和 Android 的支持 jquery.scrollTo: 在页面上以一个元素为起始以动画的方式移动(ScrollTo)到另一个元素， 支持回退等 jScrollPane: 自定义的滚动条，让所有浏览器都显示一样的滚动条 onepage-scroll: 提供类似于 iPhone6 展示页类似的效果，适用于单页应用，兼容到 IE8 scrollMonitor: 前端插件用来监控元素的滚动事件(进入、退出等)，性能很好 ScrollMagic: 神奇的滚动交互效果插件，可以在滚动的过程中设置各种各样的动态效果 infinite-scroll: 滚动加载，滚动到最下到自动加载， Paul Irish 大神之作 animatable: 仅仅依靠 border-width 和 background-position 实现的各种动态效果，看真相 Fluidbox: 页面上内嵌图片的放大缩小效果，类似于 Medium 中的效果 jquery-validation: jQuery 的一个插件，用于校验 Form 表单 BigVideo.js: jQuery 的一个插件, 用于实现大背景(视频、图片)效果 emscripten: 一款基于 LLVM, 可以将 C/C++ 转换成 Javascript 的工具，使得 Javascript 可以近乎 Native 的速度 qrcode-generator: 各种语言的二维码生成工具 device.js: 一个可以检测设备类型的工具，可以让我们根据不同的设备来为其定制响应的 Javascript 和 CSS jquery-qrcode: jQuery 插件，用来生成二维码 Wookmark-jQuery: jQuery 的一个插件，可以用来实现瀑布流的效果 isotope: 可以用来过滤、排列布局，实现美观的动态布局切换效果，Demo lazysizes: 功能强大的图片延迟加载工具，可以首先加载一个低质量的图片，然后再加载高质量的图片 progressbar.js: 简洁美观的进度条，扁平化 pigshell: 一个由 Javascript 实现的Shell, 将互联网当做一个大的文件系统, 通过 cd/ls/cat…..等命令, 可以访问 Facebook/Twitter/Google Drive 等网络服务 spectrum: Js实现的颜色选择器 (Colorpicker) jQuery.countdown: jQuery 倒计时插件 summernote: WYSIWYG 富文本编辑器 awesomplete: 非常轻型的一个自动补全 JS 库, 没有任何依赖, 配置简单, 美观 switchery: IOS 7 上 Switch 的 JS 实现, 支持 IE8 及以上浏览器 trix: Basecamp 公司出品的富文本编辑器，简洁小巧 sensor.js: 在智能移动设备浏览器上，通过HTML5的api使用移动设备的功能。定位、运动、倾斜等 hyhyhy: 用于创建 基于 HTML5 的 演示文稿 swipebox: jQuery 插件，用于处理移动端的触摸事件 FileAPI: 前端用户处理文件（拖放、多文件上传等） Sortable: 现代浏览器上用于实现元素拖拽排序的功能，支持 Meteor, AngularJS, React，不依赖 jQuery Swiper: 用于实现浏览器上的滑动切换效果，支持硬件加速 matter-js: 2D 物理效果引擎，碰撞、弹跳等 jQTouch: 用于辅助创建手机端的 Web 应用，支持主题、Zepto.js 等 snabbt.js: 一个利用 Javascript 和 CSS transform 的 animation 库 c3: 基于 D3 的图表库 echarts: 企业级图表库，百度开发 parallax.js: 一个用于响应智能手机 orientation 的库 jQuery-Animate-Enhanced: jQuery 动画库的一个增强，用于现代浏览器 wysihtml: 富文本编辑器，适用于现代浏览器 slip: 一个通过滑动或者拖拽来操控列表的库 evil-icons: 一个矢量图库，提供 Ruby/Node 等支持 PhotoSwipe: JS 的一个图片展示库 focusable: 是页面上一个元素高亮的库，有图有真相 firefox.html: Firefox 在浏览器端的实现 —— HTML 版的 Firefox jquery-mobile: jQuery 团队开发的用于辅助手机端 web app 开发的库，基于 HTML5 mobile-angular-ui: 基于angularjs和bootstarp的web app开发框架 interact.js: 一个适用于现代浏览器的，用于处理 手势、拖放、缩放等的库 rebound-js: 实现部分物理效果，Facebook 出品 basket.js: 基于 LocalStorage 的资源加载器，可以用来缓存 script 和 css, 手机端使用速度快于浏览器直接缓存 iscroll: 高性能的滚动(scroll)处理库，功能强大，支持各种事件，不依赖任何的库，且插件丰富, 大众点评的手机端列表滚动就是用这个库处理的 metrics-graphics: 基于 D3 的图表库，简洁、高效，Mozilla 出品 accessible-html5-video-player: Paypal 出品的 Video 播放器 loading: 几种 Loading 效果，基于 SVG flippant.js: 一款能够漂亮的网页元素翻转效果库，代码许久不更新，不过作为源码学习还是不错的 move.js: 基于 CSS3 的前端动画框架 scrollReveal.js: 使元素以非常酷帅的方式进入画布 (Viewpoint)，看 Demo Modernizr: 一个用来检测 HTML5 和 CSS3 支持情况的库 foundation: 另一款前端模版框架，类似于 Bootstrap Flat-UI: Bootstrap 的一款主题，简洁美观 iCheck: 一款漂亮的 Checkbox 插件 Swipe: 非常轻量级的一个图片滑动切换效果库, 性能良好, 尤其是对手机的支持, 压缩后的大小约 5kb slick: 功能异常强大的一个图片滑动切换效果库 SocialButtons: 漂亮的社交按钮 sweetalert: 一个非常美观的用于替换浏览器默认 alert 的库 web-animations-js: Javascript 实现的 Web Animation API vivus: 可以动态描绘 SVG 的 JS 库, 支持多种动画 plyr: 轻量, 小巧, 美观的 HTML5 视频播放器 timesheet.js: 基于 HTML5 &amp; CSS3 时间表 slideout: 一个非常美观的侧滑菜单 包管理工具 Package Managers NPM 菜鸟教程NPM 使用介绍 http://www.runoob.com/nodejs/nodejs-npm.html 淘宝 NPM 镜像 https://npm.taobao.org/ npm 模块安装机制简介 http://www.ruanyifeng.com/blog/2016/01/npm-install.html npm包搜索地址 https://www.npmjs.com/ Bower Bower中文网 http://www.bowercn.com/ Bower：客户端库管理工具-阮一峰 http://javascript.ruanyifeng.com/tool/bower.html Yarn yarn中文网 https://yarnpkg.com/zh-Hans/快速、可靠、安全的依赖管理 YARN 简介 https://www.ibm.com/developerworks/cn/data/library/bd-yarn-intro/ 编辑器 Text Editors WebStorm 官网下载 http://www.jetbrains.com/webstorm/download 前端网破解版下载 http://www.qdfuns.com/tools VScode 官网下载 https://code.visualstudio.com/ vscode 插件精选 - 献给所有前端工程师https://segmentfault.com/a/1190000006697219 SublimeText 官网下载 https://www.sublimetext.com/ 前端网破解版插件版下载 http://www.qdfuns.com/tools SublimeCodeIntel: Sublime Text 的代码补全工具，支持多种语言 Emmet：一个用于提高开发效率的编辑器插件，前身是Zen coding SublimeLinter: 一个提供代码质量检测的插件 SublimeTmpl：快速新建指定的模版文件 Syntax-highlighting-for-Sass：sass代码高亮插件 MarkdownEditing: Sublime Text 强大的 Markdown 扩展, 提供快捷键, 主题等 ApplySyntax: 辅助检测语法插件 CTags: Sublime Text Ctags 支持插件, 需要安装 ctags sublime-react: React 代码高亮 Atom 官网下载 https://atom.io/ HBuilder 官网下载 http://www.dcloud.io/ JS框架 JS Frameworks Backbone Backbone.js API中文文档http://www.css88.com/doc/backbone/ AngularJs 中文官方文档https://angular.cn/ angularjs中文网http://www.apjs.net/ angularjs教程http://www.angularjs.net.cn/ Angular 基础入门http://www.cnblogs.com/micua/p/angular-essential.html angular-masonry: Masonry 的 AngularJS 插件，用于瀑布流 angular-schema-form: 根据 JSON 生成响应的 Form 表单 restangular: Angular 中用来处理 RESTful API 的插件，可替代 $resource ng-cordova: Cordova 常用组件的 Angular 版本 angular-translate: Angular 的国际化 (I18n) ng-inspector: Chrome 插件，用于调试 Angular angularjs-style-guide: AngularJS 代码风格 ngReact: React 的 Angular 插件，可以在 Angular 中使用 React Components material: Google Material Design 效果的 Angular 实现 angular-local-storage: Angular 插件, 提供了对 localStorage 的友好支持, 并对不支持的浏览器使用 cookie 优雅降级 angular-filter: 一组有用的 Angular Filters bindonce: Angular 插件, 用于减少 Watcher 的数量, 提升性能 React 英文官方文档https://facebook.github.io/react/docs/hello-world.html 中文官方文档http://reactjs.cn/react/docs/getting-started-zh-CN.html gitbooks手册https://hulufei.gitbooks.io/react-tutorial/content/introduction.html 阮一峰react入门http://www.ruanyifeng.com/blog/2015/03/react.html 阮一峰React Router入门http://www.ruanyifeng.com/blog/2016/05/react_router.html React Router 中文文档https://react-guide.github.io/react-router-cn/ react-redux 中文文档http://cn.redux.js.org/docs/react-redux/index.html 阮一峰Redux 入门教程http://www.ruanyifeng.com/blog react: React 框架源代码 react-native: Facebook 出品的使用 React 开发 IOS 原生应用的框架 react-hot-loader: 实时调整 React 组件效果 grunt-react: React 的 Grunt 组件, 用于将 JSX 编译成 JS touchstonejs: 基于 React 的手机应用前端框架 essential-react: 基于 React, ES6, React-Router的一个应用脚手架 react-router: React 路由解决方案 Vue vue官方http://cn.vuejs.org/ vuex官方http://vuex.vuejs.org/zh-cn/ vue-router官方https://router.vuejs.org/zh-cn/ UI框架 UI Frameworks Bootstrap 最受欢迎的 HTML、CSS 和 JS 框架 http://v3.bootcss.com/ Ionic 一款接近原生的Html5移动App开发框架 会html css js就可以开发apphttp://www.ionic.wang/ Foundation Foundation 中文网 迄今为止最好的响应式前端框架http://www.foundcss.com FrozenUI 移动端服务的前端框架http://frozenui.github.io/ materializecss 基于Material Design的主流前端响应式框架http://www.materializecss.cn/ mui 最接近原生APP体验的高性能前端框架http://dev.dcloud.net.cn/mui/ AntDesign 和react配合的UI框架https://ant.design eleme 和vue配合的UI框架http://element.eleme.io/ JS预处理 JS Preprocessors TypeScript TypeScript 入门教程 菜鸟教程http://www.runoob.com/ TypeScript中文网https://www.tslang.cn/ TypeScript教程gitbookhttps://www.gitbook.com/ CoffeeScript CoffeeScript 中文http://coffee-script.org/ CoffeeScript 实用手册 极客学院http://wiki.jikexueyuan.com/project/coffeescript/ 过程自动化 Process Automation Grunt Grunt中文网http://www.gruntjs.net/ Gulp gulp.js 中文网http://www.gulpjs.com.cn/ gulp详细入门教程http://www.ydcss.com/ 前端构建工具gulpjs的使用介绍及技巧http://www.cnblogs.com/2050/p/4198792.html Gulp开发教程https://www.w3ctech.com/topic/134 模板引擎 Templating Handlebars handlebarsjs官网http://handlebarsjs.com/ Handlebars中文文档http://www.360doc.com/content/ Handlebars.js 中文文档http://keenwon.com/992.html Handlebars的使用方法文档整理http://www.tuicool.com/articles/fqQFN3 Haml haml官方文档https://github.com/haml/haml haml入门http://blog.csdn.net/napoay/article/details/50491363 Jade Jade 官方的英文文档http://www.w3cplus.com/html/how-to-use-jade.html Jade的使用http://www.w3cplus.com/html/how-to-use-jade.html 带你学习Jade模板引擎视频http://www.imooc.com/learn/259 构建工具 Build Tools RequireJS RequireJS 英文网http://requirejs.org/ RequireJS 中文网http://requirejs.cn/ require.js的用法-阮一峰http://www.ruanyifeng.com/blog seajs seajs文档http://seajs.org/docs/ SeaJS从入门到原理http://www.tuicool.com/articles/FfEJv2u Browserify 官网http://browserify.org/ githubhttps://github.com/substack/node-browserify/ Webpack Webpack 中文指南http://webpackdoc.com/ webpack的实例http://www.vichily.com webpack的入门http://www.vichily.com 一小时包教会 —— webpack 入门指南http://www.w2bc.com/Article/50764 CSS预处理器 CSS Preprocessors Sass sass入门http://www.w3cplus.com/sassguide/ sass参考手册http://sass.bootcss.com/docs/sass-reference/ SASS用法指南-阮一峰http://www.ruanyifeng.com/blog/ Less less中文网http://lesscss.cn/ less快速入门http://less.bootcss.com/ stylus stylus中文文档-张鑫旭http://www.zhangxinxu.com/jq/stylus/ 版本控制 Version Control Git Git教程-廖雪峰http://www.liaoxuefeng.com/wiki/ Svn 史上最简单的SVN使用教程和注意事项http://blog.csdn.net/fwzkj/article/details/47988885 SVN 教程 极客学院http://wiki.jikexueyuan.com/project/svn/ SVN 教程 菜鸟教程http://www.runoob.com/svn/svn-tuto]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码库]]></title>
    <url>%2F2017%2F10%2F18%2F%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93%EF%BC%88javascript%E5%B8%B8%E7%94%A8%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%B0%81%E8%A3%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[编写自己的代码库（javascript常用实例的实现与封装）1.前言大家在开发的时候应该知道，有很多常见的实例操作。比如数组去重，关键词高亮，打乱数组等。这些操作，代码一般不会很多，实现的逻辑也不会很难，下面的代码，我解释就不解释太多了，打上注释，相信大家就会懂了。但是，用的地方会比较，如果项目有哪个地方需要用，如果重复写的话，就是代码沉余，开发效率也不用，复用基本就是复制粘贴！这样是一个很不好的习惯，大家可以考虑一下把一些常见的操作封装成函数，调用的时候，直接调用就好！源码都放在github上了，大家想以后以后有什么修改或者增加的，欢迎大家来star一下ec-do。 1.下面代码，我放的是es5版本的，如果大家需要看es6版本的，请移步ec-do2.0.0.js 2.想看完整代码的，或者部分实例的demo，建议去github看！ 3.下面的代码，都是封装在ecDo这个对象里面，如果里面有this，除了特别说明的，都是指向ecDo 2.字符串操作2-1去除字符串空格123456789101112131415161718//去除空格 type 1-所有空格 2-前后空格 3-前空格 4-后空格//ecDo.trim(&apos; 1235asd&apos;,1)//result：1235asd//这个方法有原生的方案代替，但是考虑到有时候开发PC站需要兼容IE8，所以就还是继续保留trim: function (str, type) &#123; switch (type) &#123; case 1: return str.replace(/\s+/g, &quot;&quot;); case 2: return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); case 3: return str.replace(/(^\s*)/g, &quot;&quot;); case 4: return str.replace(/(\s*$)/g, &quot;&quot;); default: return str; &#125;&#125; 2-2字母大小写切换12345678910111213141516171819202122232425262728293031323334353637383940414243/*type 1:首字母大写 2：首页母小写 3：大小写转换 4：全部大写 5：全部小写 * *///ecDo.changeCase(&apos;asdasd&apos;,1)//result：AsdasdchangeCase: function (str, type) &#123; function ToggleCase(str) &#123; var itemText = &quot;&quot; str.split(&quot;&quot;).forEach( function (item) &#123; if (/^([a-z]+)/.test(item)) &#123; itemText += item.toUpperCase(); &#125; else if (/^([A-Z]+)/.test(item)) &#123; itemText += item.toLowerCase(); &#125; else &#123; itemText += item; &#125; &#125;); return itemText; &#125; switch (type) &#123; case 1: return str.replace(/\b\w+\b/g, function (word) &#123; return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase(); &#125;); case 2: return str.replace(/\b\w+\b/g, function (word) &#123; return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase(); &#125;); case 3: return ToggleCase(str); case 4: return str.toUpperCase(); case 5: return str.toLowerCase(); default: return str; &#125;&#125; 2-3字符串循环复制12345678910//repeatStr(str-&gt;字符串, count-&gt;次数)//ecDo.repeatStr(&apos;123&apos;,3)//&quot;result：123123123&quot;repeatStr: function (str, count) &#123; var text = &apos;&apos;; for (var i = 0; i &lt; count; i++) &#123; text += str; &#125; return text;&#125; 2-4字符串替换123456//ecDo.replaceAll(&apos;这里是上海，中国第三大城市，广东省省会，简称穗，&apos;,&apos;上海&apos;,&apos;广州&apos;)//result：&quot;这里是广州，中国第三大城市，广东省省会，简称穗，&quot;replaceAll: function (str, AFindText, ARepText) &#123; raRegExp = new RegExp(AFindText, &quot;g&quot;); return str.replace(raRegExp, ARepText);&#125; 2-5替换*1234567891011121314151617181920212223242526272829303132333435363738394041//字符替换*//replaceStr(字符串,字符格式, 替换方式,替换的字符（默认*）)//ecDo.replaceStr(&apos;18819322663&apos;,[3,5,3],0)//result：188*****663//ecDo.replaceStr(&apos;asdasdasdaa&apos;,[3,5,3],1)//result：***asdas***//ecDo.replaceStr(&apos;1asd88465asdwqe3&apos;,[5],0)//result：*****8465asdwqe3//ecDo.replaceStr(&apos;1asd88465asdwqe3&apos;,[5],1,&apos;+&apos;)//result：&quot;1asd88465as+++++&quot;replaceStr: function (str, regArr, type, ARepText) &#123; var regtext = &apos;&apos;, Reg = null, replaceText = ARepText || &apos;*&apos;; //repeatStr是在上面定义过的（字符串循环复制），大家注意哦 if (regArr.length === 3 &amp;&amp; type === 0) &#123; regtext = &apos;(\\w&#123;&apos; + regArr[0] + &apos;&#125;)\\w&#123;&apos; + regArr[1] + &apos;&#125;(\\w&#123;&apos; + regArr[2] + &apos;&#125;)&apos; Reg = new RegExp(regtext); var replaceCount = this.repeatStr(replaceText, regArr[1]); return str.replace(Reg, &apos;$1&apos; + replaceCount + &apos;$2&apos;) &#125; else if (regArr.length === 3 &amp;&amp; type === 1) &#123; regtext = &apos;\\w&#123;&apos; + regArr[0] + &apos;&#125;(\\w&#123;&apos; + regArr[1] + &apos;&#125;)\\w&#123;&apos; + regArr[2] + &apos;&#125;&apos; Reg = new RegExp(regtext); var replaceCount1 = this.repeatStr(replaceText, regArr[0]); var replaceCount2 = this.repeatStr(replaceText, regArr[2]); return str.replace(Reg, replaceCount1 + &apos;$1&apos; + replaceCount2) &#125; else if (regArr.length === 1 &amp;&amp; type === 0) &#123; regtext = &apos;(^\\w&#123;&apos; + regArr[0] + &apos;&#125;)&apos; Reg = new RegExp(regtext); var replaceCount = this.repeatStr(replaceText, regArr[0]); return str.replace(Reg, replaceCount) &#125; else if (regArr.length === 1 &amp;&amp; type === 1) &#123; regtext = &apos;(\\w&#123;&apos; + regArr[0] + &apos;&#125;$)&apos; Reg = new RegExp(regtext); var replaceCount = this.repeatStr(replaceText, regArr[0]); return str.replace(Reg, replaceCount) &#125;&#125; 2-6检测字符串12345678910111213141516171819202122232425262728//检测字符串//ecDo.checkType(&apos;165226226326&apos;,&apos;phone&apos;)//result：false//大家可以根据需要扩展checkType: function (str, type) &#123; switch (type) &#123; case &apos;email&apos;: return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str); case &apos;phone&apos;: return /^1[3|4|5|7|8][0-9]&#123;9&#125;$/.test(str); case &apos;tel&apos;: return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str); case &apos;number&apos;: return /^[0-9]$/.test(str); case &apos;english&apos;: return /^[a-zA-Z]+$/.test(str); case &apos;text&apos;: return /^\w+$/.test(str); case &apos;chinese&apos;: return /^[\u4E00-\u9FA5]+$/.test(str); case &apos;lower&apos;: return /^[a-z]+$/.test(str); case &apos;upper&apos;: return /^[A-Z]+$/.test(str); default: return true; &#125;&#125; 2-7 检测密码强度123456789101112131415161718192021//ecDo.checkPwd(&apos;12asdASAD&apos;)//result：3(强度等级为3)checkPwd: function (str) &#123; var nowLv = 0; if (str.length &lt; 6) &#123; return nowLv &#125; if (/[0-9]/.test(str)) &#123; nowLv++ &#125; if (/[a-z]/.test(str)) &#123; nowLv++ &#125; if (/[A-Z]/.test(str)) &#123; nowLv++ &#125; if (/[\.|-|_]/.test(str)) &#123; nowLv++ &#125; return nowLv;&#125; 2-8随机码（toString详解）12345678910//count取值范围0-36//ecDo.randomWord(10)//result：&quot;2584316588472575&quot;//ecDo.randomWord(14)//result：&quot;9b405070dd00122640c192caab84537&quot;//ecDo.randomWord(36)//result：&quot;83vhdx10rmjkyb9&quot;randomWord: function (count) &#123; return Math.random().toString(count).substring(2);&#125; 2-9查找字符串可能标题会有点误导，下面我就简单说明一个需求，在字符串&#39;sad44654blog5a1sd67as9dablog4s5d16zxc4sdweasjkblogwqepaskdkblogahseiuadbhjcibloguyeajzxkcabloguyiwezxc967&#39;中找出’blog’的出现次数。代码如下 123456//var strTest=&apos;sad44654blog5a1sd67as9dablog4s5d16zxc4sdweasjkblogwqepaskdkblogahseiuadbhjcibloguyeajzxkcabloguyiwezxc967&apos;//ecDo.countStr(strTest,&apos;blog&apos;)//result：6countStr: function (str, strSplit) &#123; return str.split(strSplit).length - 1&#125; 2-10 过滤字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//过滤字符串(html标签，表情，特殊字符)//字符串，替换内容（special-特殊字符,html-html标签,emjoy-emjoy表情,word-小写字母，WORD-大写字母，number-数字,chinese-中文），要替换成什么，默认&apos;&apos;,保留哪些特殊字符//如果需要过滤多种字符，type参数使用,分割，如下栗子//过滤字符串的html标签，大写字母，中文，特殊字符，全部替换成*,但是特殊字符&apos;%&apos;，&apos;?&apos;，除了这两个，其他特殊字符全部清除//var str=&apos;asd 654a大蠢sasdasdASDQWEXZC6d5#%^*^&amp;*^%^&amp;*$\\&quot;\&apos;#@!()*/-())_\&apos;&quot;:&quot;&#123;&#125;?&lt;div&gt;&lt;/div&gt;&lt;img src=&quot;&quot;/&gt;啊实打实大蠢猪自行车这些课程&apos;;// ecDo.filterStr(str,&apos;html,WORD,chinese,special&apos;,&apos;*&apos;,&apos;%?&apos;)//result：&quot;asd 654a**sasdasd*********6d5#%^*^&amp;*^%^&amp;*$\&quot;&apos;#@!()*/-())_&apos;&quot;:&quot;&#123;&#125;?*****************&quot;filterStr: function (str, type, restr, spstr) &#123; var typeArr = type.split(&apos;,&apos;), _str = str; for (var i = 0, len = typeArr.length; i &lt; len; i++) &#123; //是否是过滤特殊符号 if (typeArr[i] === &apos;special&apos;) &#123; var pattern, regText = &apos;$()[]&#123;&#125;?\|^*+./\&quot;\&apos;+&apos;; //是否有哪些特殊符号需要保留 if (spstr) &#123; var _spstr = spstr.split(&quot;&quot;), _regText = &quot;[^0-9A-Za-z\\s&quot;; for (var j = 0, len1 = _spstr.length; j &lt; len1; j++) &#123; if (regText.indexOf(_spstr[j]) === -1) &#123; _regText += _spstr[j]; &#125; else &#123; _regText += &apos;\\&apos; + _spstr[j]; &#125; &#125; _regText += &apos;]&apos; pattern = new RegExp(_regText, &apos;g&apos;); &#125; else &#123; pattern = new RegExp(&quot;[^0-9A-Za-z\\s]&quot;, &apos;g&apos;) &#125; &#125; var _restr = restr || &apos;&apos;; switch (typeArr[i]) &#123; case &apos;special&apos;: _str = _str.replace(pattern, _restr); break; case &apos;html&apos;: _str = _str.replace(/&lt;\/?[^&gt;]*&gt;/g, _restr); break; case &apos;emjoy&apos;: _str = _str.replace(/[^\u4e00-\u9fa5|\u0000-\u00ff|\u3002|\uFF1F|\uFF01|\uff0c|\u3001|\uff1b|\uff1a|\u3008-\u300f|\u2018|\u2019|\u201c|\u201d|\uff08|\uff09|\u2014|\u2026|\u2013|\uff0e]/g, _restr); break; case &apos;word&apos;: _str = _str.replace(/[a-z]/g, _restr); break; case &apos;WORD&apos;: _str = _str.replace(/[A-Z]/g, _restr); break; case &apos;number&apos;: _str = _str.replace(/[0-9]/g, _restr); break; case &apos;chinese&apos;: _str = _str.replace(/[\u4E00-\u9FA5]/g, _restr); break; &#125; &#125; return _str;&#125; 2-11格式化处理字符串123456789101112//ecDo.formatText(&apos;1234asda567asd890&apos;)//result：&quot;12,34a,sda,567,asd,890&quot;//ecDo.formatText(&apos;1234asda567asd890&apos;,4,&apos; &apos;)//result：&quot;1 234a sda5 67as d890&quot;//ecDo.formatText(&apos;1234asda567asd890&apos;,4,&apos;-&apos;)//result：&quot;1-234a-sda5-67as-d890&quot;formatText: function (str, size, delimiter) &#123; var _size = size || 3, _delimiter = delimiter || &apos;,&apos;; var regText = &apos;\\B(?=(\\w&#123;&apos; + _size + &apos;&#125;)+(?!\\w))&apos;; var reg = new RegExp(regText, &apos;g&apos;); return str.replace(reg, _delimiter);&#125; 2-12找出最长单词12345678910111213141516//ecDo.longestWord(&apos;Find the Longest word in a String&apos;)//result：7//ecDo.longestWord(&apos;Find|the|Longest|word|in|a|String&apos;,&apos;|&apos;)//result：7longestWord: function (str, splitType) &#123; var _splitType = splitType || /\s+/g, _max = 0,_item=&apos;&apos;; var strArr = str.split(_splitType); strArr.forEach(function (item) &#123; if (_max &lt; item.length) &#123; _max = item.length _item=item; &#125; &#125;) return &#123;el:_item,max:_max&#125;;&#125; 2-13句中单词首字母大写123456789101112//这个我也一直在纠结，英文标题，即使是首字母大写，也未必每一个单词的首字母都是大写的，但是又不知道哪些应该大写，哪些不应该大写//ecDo.titleCaseUp(&apos;this is a title&apos;)//&quot;This Is A Title&quot;titleCaseUp: function (str, splitType) &#123; var _splitType = splitType || /\s+/g; var strArr = str.split(_splitType), result = &quot;&quot;, _this = this strArr.forEach(function (item) &#123; result += _this.changeCase(item, 1) + &apos; &apos;; &#125;) return this.trim(result, 4)&#125; 3.数组操作3-1数组去重12345removeRepeatArray: function (arr) &#123; return arr.filter(function (item, index, self) &#123; return self.indexOf(item) === index; &#125;);&#125; 3-2数组顺序打乱12345upsetArr: function (arr) &#123; return arr.sort(function () &#123; return Math.random() - 0.5 &#125;);&#125;, 3-3数组最大值最小值12345678//数组最大值maxArr: function (arr) &#123; return Math.max.apply(null, arr);&#125;,//数组最小值minArr: function (arr) &#123; return Math.min.apply(null, arr);&#125; 3-4数组求和，平均值1234567891011//这一块的封装，主要是针对数字类型的数组//求和sumArr: function (arr) &#123; return arr.reduce(function (pre, cur) &#123; return pre + cur &#125;)&#125;//数组平均值,小数点可能会有很多位，这里不做处理，处理了使用就不灵活！covArr: function (arr) &#123; return this.sumArr(arr) / arr.length;&#125;, 3-5从数组中随机获取元素1234567891011//ecDo.randomOne([1,2,3,6,8,5,4,2,6])//2//ecDo.randomOne([1,2,3,6,8,5,4,2,6])//8//ecDo.randomOne([1,2,3,6,8,5,4,2,6])//8//ecDo.randomOne([1,2,3,6,8,5,4,2,6])//1randomOne: function (arr) &#123; return arr[Math.floor(Math.random() * arr.length)];&#125; 3-6返回数组（字符串）一个元素出现的次数12345678910111213//ecDo.getEleCount(&apos;asd56+asdasdwqe&apos;,&apos;a&apos;)//result：3//ecDo.getEleCount([1,2,3,4,5,66,77,22,55,22],22)//result：2getEleCount: function (obj, ele) &#123; var num = 0; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; if (ele === obj[i]) &#123; num++; &#125; &#125; return num;&#125; 3-7返回数组（字符串）出现最多的几次元素和出现次数1234567891011121314151617181920212223242526272829303132333435363738394041//arr, rank-&gt;长度，默认为数组长度，ranktype，排序方式，默认降序//返回值：el-&gt;元素，count-&gt;次数//ecDo.getCount([1,2,3,1,2,5,2,4,1,2,6,2,1,3,2])//默认情况，返回所有元素出现的次数//result：[&#123;&quot;el&quot;:&quot;2&quot;,&quot;count&quot;:6&#125;,&#123;&quot;el&quot;:&quot;1&quot;,&quot;count&quot;:4&#125;,&#123;&quot;el&quot;:&quot;3&quot;,&quot;count&quot;:2&#125;,&#123;&quot;el&quot;:&quot;4&quot;,&quot;count&quot;:1&#125;,&#123;&quot;el&quot;:&quot;5&quot;,&quot;count&quot;:1&#125;,&#123;&quot;el&quot;:&quot;6&quot;,&quot;count&quot;:1&#125;]//ecDo.getCount([1,2,3,1,2,5,2,4,1,2,6,2,1,3,2],3)//传参（rank=3），只返回出现次数排序前三的//result：[&#123;&quot;el&quot;:&quot;2&quot;,&quot;count&quot;:6&#125;,&#123;&quot;el&quot;:&quot;1&quot;,&quot;count&quot;:4&#125;,&#123;&quot;el&quot;:&quot;3&quot;,&quot;count&quot;:2&#125;]//ecDo.getCount([1,2,3,1,2,5,2,4,1,2,6,2,1,3,2],null,1)//传参（ranktype=1,rank=null），升序返回所有元素出现次数//result：[&#123;&quot;el&quot;:&quot;6&quot;,&quot;count&quot;:1&#125;,&#123;&quot;el&quot;:&quot;5&quot;,&quot;count&quot;:1&#125;,&#123;&quot;el&quot;:&quot;4&quot;,&quot;count&quot;:1&#125;,&#123;&quot;el&quot;:&quot;3&quot;,&quot;count&quot;:2&#125;,&#123;&quot;el&quot;:&quot;1&quot;,&quot;count&quot;:4&#125;,&#123;&quot;el&quot;:&quot;2&quot;,&quot;count&quot;:6&#125;]//ecDo.getCount([1,2,3,1,2,5,2,4,1,2,6,2,1,3,2],3,1)//传参（rank=3，ranktype=1），只返回出现次数排序（升序）前三的//result：[&#123;&quot;el&quot;:&quot;6&quot;,&quot;count&quot;:1&#125;,&#123;&quot;el&quot;:&quot;5&quot;,&quot;count&quot;:1&#125;,&#123;&quot;el&quot;:&quot;4&quot;,&quot;count&quot;:1&#125;]getCount: function (arr, rank, ranktype) &#123; var obj = &#123;&#125;, k, arr1 = [] //记录每一元素出现的次数 for (var i = 0, len = arr.length; i &lt; len; i++) &#123; k = arr[i]; if (obj[k]) &#123; obj[k]++; &#125; else &#123; obj[k] = 1; &#125; &#125; //保存结果&#123;el-&apos;元素&apos;，count-出现次数&#125; for (var o in obj) &#123; arr1.push(&#123;el: o, count: obj[o]&#125;); &#125; //排序（降序） arr1.sort(function (n1, n2) &#123; return n2.count - n1.count &#125;); //如果ranktype为1，则为升序，反转数组 if (ranktype === 1) &#123; arr1 = arr1.reverse(); &#125; var rank1 = rank || arr1.length; return arr1.slice(0, rank1);&#125; 3-8得到n1-n2下标的数组1234567//ecDo.getArrayNum([0,1,2,3,4,5,6,7,8,9],5,9)//result：[5, 6, 7, 8, 9]//getArrayNum([0,1,2,3,4,5,6,7,8,9],2) //不传第二个参数,默认返回从n1到数组结束的元素//result：[2, 3, 4, 5, 6, 7, 8, 9]getArrayNum: function (arr, n1, n2) &#123; return arr.slice(n1, n2);&#125; 3-9筛选数组12345678910//删除值为&apos;val&apos;的数组元素//ecDo.removeArrayForValue([&apos;test&apos;,&apos;test1&apos;,&apos;test2&apos;,&apos;test&apos;,&apos;aaa&apos;],&apos;test&apos;,&apos;)//result：[&quot;aaa&quot;] 带有&apos;test&apos;的都删除//ecDo.removeArrayForValue([&apos;test&apos;,&apos;test1&apos;,&apos;test2&apos;,&apos;test&apos;,&apos;aaa&apos;],&apos;test&apos;)//result：[&quot;test1&quot;, &quot;test2&quot;, &quot;aaa&quot;] //数组元素的值全等于&apos;test&apos;才被删除removeArrayForValue: function (arr, val, type) &#123; return arr.filter(function (item) &#123; return type ? item.indexOf(val) === -1 : item !== val &#125;)&#125; 3-10 获取对象数组某些项123456789101112131415161718192021222324252627//var arr=[&#123;a:1,b:2,c:9&#125;,&#123;a:2,b:3,c:5&#125;,&#123;a:5,b:9&#125;,&#123;a:4,b:2,c:5&#125;,&#123;a:4,b:5,c:7&#125;]//ecDo.getOptionArray(arr,&apos;a,c&apos;)//result：[&#123;a:1,c:9&#125;,&#123;a:2,c:5&#125;,&#123;a:5,c:underfind&#125;,&#123;a:4,c:5&#125;,&#123;a:4,c:7&#125;]//ecDo.getOptionArray(arr,&apos;b&apos;)//result：[2, 3, 9, 2, 5]getOptionArray: function (arr, keys) &#123; var newArr = [] if (!keys) &#123; return arr &#125; var _keys = keys.split(&apos;,&apos;), newArrOne = &#123;&#125;; //是否只是需要获取某一项的值 if (_keys.length === 1) &#123; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; newArr.push(arr[i][keys]) &#125; return newArr; &#125; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; newArrOne = &#123;&#125;; for (var j = 0, len1 = _keys.length; j &lt; len1; j++) &#123; newArrOne[_keys[j]] = arr[i][_keys[j]] &#125; newArr.push(newArrOne); &#125; return newArr&#125; 3-11 排除对象数组某些项1234567891011121314151617181920//var arr=[&#123;a:1,b:2,c:9&#125;,&#123;a:2,b:3,c:5&#125;,&#123;a:5,b:9&#125;,&#123;a:4,b:2,c:5&#125;,&#123;a:4,b:5,c:7&#125;]//ecDo.filterOptionArray(arr,&apos;a&apos;)//result：[&#123;b:2,c:9&#125;,&#123;b:3,c:5&#125;,&#123;b:9&#125;,&#123;b:2,c:5&#125;,&#123;b:5,c:7&#125;]//ecDo.filterOptionArray(arr,&apos;a,c&apos;)//result：[&#123;b:2&#125;,&#123;b:3&#125;,&#123;b:9&#125;,&#123;b:2&#125;,&#123;b:5&#125;]filterOptionArray: function (arr, keys) &#123; var newArr = [] var _keys = keys.split(&apos;,&apos;), newArrOne = &#123;&#125;; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; newArrOne = &#123;&#125;; for (var key in arr[i]) &#123; //如果key不存在排除keys里面,添加数据 if (_keys.indexOf(key) === -1) &#123; newArrOne[key] = arr[i][key]; &#125; &#125; newArr.push(newArrOne); &#125; return newArr&#125; 3-12 对象数组排序123456789101112131415//var arr=[&#123;a:1,b:2,c:9&#125;,&#123;a:2,b:3,c:5&#125;,&#123;a:5,b:9&#125;,&#123;a:4,b:2,c:5&#125;,&#123;a:4,b:5,c:7&#125;]//ecDo.arraySort(arr,&apos;a,b&apos;)a是第一排序条件，b是第二排序条件//result：[&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:9&#125;,&#123;&quot;a&quot;:2,&quot;b&quot;:3,&quot;c&quot;:5&#125;,&#123;&quot;a&quot;:4,&quot;b&quot;:2,&quot;c&quot;:5&#125;,&#123;&quot;a&quot;:4,&quot;b&quot;:5,&quot;c&quot;:7&#125;,&#123;&quot;a&quot;:5,&quot;b&quot;:9&#125;]arraySort: function (arr, sortText) &#123; if (!sortText) &#123; return arr &#125; var _sortText = sortText.split(&apos;,&apos;).reverse(), _arr = arr.slice(0); for (var i = 0, len = _sortText.length; i &lt; len; i++) &#123; _arr.sort(function (n1, n2) &#123; return n1[_sortText[i]] - n2[_sortText[i]] &#125;) &#125; return _arr;&#125; 3-13 数组扁平化12345678910111213141516//ecDo.steamroller([1,2,[4,5,[1,23]]])//[1, 2, 4, 5, 1, 23]steamroller: function (arr) &#123; var newArr = [],_this=this; for (var i = 0; i &lt; arr.length; i++) &#123; if (Array.isArray(arr[i])) &#123; // 如果是数组，调用(递归)steamroller 将其扁平化 // 然后再 push 到 newArr 中 newArr.push.apply(newArr, _this.steamroller(arr[i])); &#125; else &#123; // 不是数组直接 push 到 newArr 中 newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 4.基础DOM操作这个部分代码其实参考jquery的一些函数写法，唯一区别就是调用不用，参数一样.比如下面的栗子 123456//设置对象内容jquery：$(&apos;#xxx&apos;).html(&apos;hello world&apos;);现在：ecDo.html(document.getElementById(&apos;xxx&apos;),&apos;hello world&apos;)//获取对象内容jquery：$(&apos;#xxx&apos;).html();现在：ecDo.html(document.getElementById(&apos;xxx&apos;)) 4-1检测对象是否有哪个类名12345678910//检测对象是否有哪个类名hasClass: function (obj, classStr) &#123; if (obj.className &amp;&amp; this.trim(obj.className, 1) !== &quot;&quot;) &#123; var arr = obj.className.split(/\s+/); //这个正则表达式是因为class可以有多个,判断是否包含 return (arr.indexOf(classStr) == -1) ? false : true; &#125; else &#123; return false; &#125;&#125; 4-2 添加类名1234567891011121314addClass: function (obj, classStr) &#123; if ((this.istype(obj, &apos;array&apos;) || this.istype(obj, &apos;elements&apos;)) &amp;&amp; obj.length &gt;= 1) &#123; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; if (!this.hasClass(obj[i], classStr)) &#123; obj[i].className += &quot; &quot; + classStr; &#125; &#125; &#125; else &#123; if (!this.hasClass(obj, classStr)) &#123; obj.className += &quot; &quot; + classStr; &#125; &#125;&#125; 4-3删除类名12345678910111213141516removeClass: function (obj, classStr) &#123; if ((this.istype(obj, &apos;array&apos;) || this.istype(obj, &apos;elements&apos;)) &amp;&amp; obj.length &gt; 1) &#123; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; if (this.hasClass(obj[i], classStr)) &#123; var reg = new RegExp(&apos;(\\s|^)&apos; + classStr + &apos;(\\s|$)&apos;); obj[i].className = obj[i].className.replace(reg, &apos;&apos;); &#125; &#125; &#125; else &#123; if (this.hasClass(obj, classStr)) &#123; var reg = new RegExp(&apos;(\\s|^)&apos; + classStr + &apos;(\\s|$)&apos;); obj.className = obj.className.replace(reg, &apos;&apos;); &#125; &#125;&#125; 4-4替换类名(“被替换的类名”,”替换的类名”)1234replaceClass: function (obj, newName, oldName) &#123; this.removeClass(obj, oldName); this.addClass(obj, newName);&#125; 4-5获取兄弟节点12345678910111213141516171819202122232425262728293031323334353637383940//ecDo.siblings(obj,&apos;#id&apos;)siblings: function (obj, opt) &#123; var a = []; //定义一个数组，用来存o的兄弟元素 var p = obj.previousSibling; while (p) &#123; //先取o的哥哥们 判断有没有上一个哥哥元素，如果有则往下执行 p表示previousSibling if (p.nodeType === 1) &#123; a.push(p); &#125; p = p.previousSibling //最后把上一个节点赋给p &#125; a.reverse() //把顺序反转一下 这样元素的顺序就是按先后的了 var n = obj.nextSibling; //再取o的弟弟 while (n) &#123; //判断有没有下一个弟弟结点 n是nextSibling的意思 if (n.nodeType === 1) &#123; a.push(n); &#125; n = n.nextSibling; &#125; if (opt) &#123; var _opt = opt.substr(1); var b = [];//定义一个数组，用于储存过滤a的数组 if (opt[0] === &apos;.&apos;) &#123; b = a.filter(function (item) &#123; return item.className === _opt &#125;); &#125; else if (opt[0] === &apos;#&apos;) &#123; b = a.filter(function (item) &#123; return item.id === _opt &#125;); &#125; else &#123; b = a.filter(function (item) &#123; return item.tagName.toLowerCase() === opt &#125;); &#125; return b; &#125; return a;&#125; 4-6设置样式12345css: function (obj, json) &#123; for (var attr in json) &#123; obj.style[attr] = json[attr]; &#125;&#125; 4-7设置文本内容1234567891011121314html: function (obj) &#123; if (arguments.length === 1) &#123; return obj.innerHTML; &#125; else if (arguments.length === 2) &#123; obj.innerHTML = arguments[1]; &#125;&#125;text: function (obj) &#123; if (arguments.length === 1) &#123; return obj.innerHTML; &#125; else if (arguments.length === 2) &#123; obj.innerHTML = this.filterStr(arguments[1],&apos;html&apos;); &#125;&#125; 4-8显示隐藏123456789101112show: function (obj) &#123; var blockArr=[&apos;div&apos;,&apos;li&apos;,&apos;ul&apos;,&apos;ol&apos;,&apos;dl&apos;,&apos;table&apos;,&apos;article&apos;,&apos;h1&apos;,&apos;h2&apos;,&apos;h3&apos;,&apos;h4&apos;,&apos;h5&apos;,&apos;h6&apos;,&apos;p&apos;,&apos;hr&apos;,&apos;header&apos;,&apos;footer&apos;,&apos;details&apos;,&apos;summary&apos;,&apos;section&apos;,&apos;aside&apos;,&apos;&apos;] if(blockArr.indexOf(obj.tagName.toLocaleLowerCase())===-1)&#123; obj.style.display =&apos;inline&apos;; &#125; else&#123; obj.style.display =&apos;block&apos;; &#125;&#125;,hide: function (obj) &#123; obj.style.display = &quot;none&quot;;&#125; 5.其他操作5-1cookie12345678910111213141516171819202122//cookie//设置cookiesetCookie: function (name, value, iDay) &#123; var oDate = new Date(); oDate.setDate(oDate.getDate() + iDay); document.cookie = name + &apos;=&apos; + value + &apos;;expires=&apos; + oDate;&#125;,//获取cookiegetCookie: function (name) &#123; var arr = document.cookie.split(&apos;; &apos;); for (var i = 0; i &lt; arr.length; i++) &#123; var arr2 = arr[i].split(&apos;=&apos;); if (arr2[0] == name) &#123; return arr2[1]; &#125; &#125; return &apos;&apos;;&#125;,//删除cookieremoveCookie: function (name) &#123; this.setCookie(name, 1, -1);&#125;, 5-2清除对象中值为空的属性1234567891011//ecDo.filterParams(&#123;a:&quot;&quot;,b:null,c:&quot;010&quot;,d:123&#125;)//Object &#123;c: &quot;010&quot;, d: 123&#125;filterParams: function (obj) &#123; var _newPar = &#123;&#125;; for (var key in obj) &#123; if ((obj[key] === 0 ||obj[key] === false|| obj[key]) &amp;&amp; obj[key].toString().replace(/(^\s*)|(\s*$)/g, &apos;&apos;) !== &apos;&apos;) &#123; _newPar[key] = obj[key]; &#125; &#125; return _newPar;&#125; 5-3现金额大写转换函数1234567891011121314151617181920212223242526272829303132//ecDo.upDigit(168752632)//result：&quot;人民币壹亿陆仟捌佰柒拾伍万贰仟陆佰叁拾贰元整&quot;//ecDo.upDigit(1682)//result：&quot;人民币壹仟陆佰捌拾贰元整&quot;//ecDo.upDigit(-1693)//result：&quot;欠人民币壹仟陆佰玖拾叁元整&quot;upDigit: function (n) &#123; var fraction = [&apos;角&apos;, &apos;分&apos;, &apos;厘&apos;]; var digit = [&apos;零&apos;, &apos;壹&apos;, &apos;贰&apos;, &apos;叁&apos;, &apos;肆&apos;, &apos;伍&apos;, &apos;陆&apos;, &apos;柒&apos;, &apos;捌&apos;, &apos;玖&apos;]; var unit = [ [&apos;元&apos;, &apos;万&apos;, &apos;亿&apos;], [&apos;&apos;, &apos;拾&apos;, &apos;佰&apos;, &apos;仟&apos;] ]; var head = n &lt; 0 ? &apos;欠人民币&apos; : &apos;人民币&apos;; n = Math.abs(n); var s = &apos;&apos;; for (var i = 0; i &lt; fraction.length; i++) &#123; s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &apos;&apos;); &#125; s = s || &apos;整&apos;; n = Math.floor(n); for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) &#123; var p = &apos;&apos;; for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) &#123; p = digit[n % 10] + unit[1][j] + p; n = Math.floor(n / 10); &#125; s = p.replace(/(零.)*零$/, &apos;&apos;).replace(/^$/, &apos;零&apos;) + unit[0][i] + s; //s = p + unit[0][i] + s; &#125; return head + s.replace(/(零.)*零元/, &apos;元&apos;).replace(/(零.)+/g, &apos;零&apos;).replace(/^整$/, &apos;零元整&apos;);&#125; 5-4获取，设置url参数12345678910111213141516171819202122232425262728293031//设置url参数//ecDo.setUrlPrmt(&#123;&apos;a&apos;:1,&apos;b&apos;:2&#125;)//result：a=1&amp;b=2setUrlPrmt: function (obj) &#123; var _rs = []; for (var p in obj) &#123; if (obj[p] != null &amp;&amp; obj[p] != &apos;&apos;) &#123; _rs.push(p + &apos;=&apos; + obj[p]) &#125; &#125; return _rs.join(&apos;&amp;&apos;);&#125;,//获取url参数//ecDo.getUrlPrmt(&apos;test.com/write?draftId=122000011938&apos;)//result：Object&#123;draftId: &quot;122000011938&quot;&#125;getUrlPrmt: function (url) &#123; url = url ? url : window.location.href; var _pa = url.substring(url.indexOf(&apos;?&apos;) + 1), _arrS = _pa.split(&apos;&amp;&apos;), _rs = &#123;&#125;; for (var i = 0, _len = _arrS.length; i &lt; _len; i++) &#123; var pos = _arrS[i].indexOf(&apos;=&apos;); if (pos == -1) &#123; continue; &#125; var name = _arrS[i].substring(0, pos), value = window.decodeURIComponent(_arrS[i].substring(pos + 1)); _rs[name] = value; &#125; return _rs;&#125; 5-5随机返回一个范围的数字1234567891011121314151617//ecDo.randomNumber(5,10)//返回5-10的随机整数，包括5，10//ecDo.randomNumber(10)//返回0-10的随机整数，包括0，10//ecDo.randomNumber()//返回0-255的随机整数，包括0，255randomNumber: function (n1, n2) &#123; if (arguments.length === 2) &#123; return Math.round(n1 + Math.random() * (n2 - n1)); &#125; else if (arguments.length === 1) &#123; return Math.round(Math.random() * n1) &#125; else &#123; return Math.round(Math.random() * 255) &#125;&#125; 5-6随进产生颜色123456789101112131415randomColor: function () &#123; //randomNumber是下面定义的函数 //写法1 //return &apos;rgb(&apos; + this.randomNumber(255) + &apos;,&apos; + this.randomNumber(255) + &apos;,&apos; + this.randomNumber(255) + &apos;)&apos;; //写法2 return &apos;#&apos; + Math.random().toString(16).substring(2).substr(0, 6); //写法3 //var color=&apos;#&apos;,_index=this.randomNumber(15); //for(var i=0;i&lt;6;i++)&#123; //color+=&apos;0123456789abcdef&apos;[_index]; //&#125; //return color;&#125;//这种写法，偶尔会有问题。大家得注意哦//Math.floor(Math.random()*0xffffff).toString(16); 5-7Date日期时间部分12345678910111213141516171819//到某一个时间的倒计时//ecDo.getEndTime(&apos;2017/7/22 16:0:0&apos;)//result：&quot;剩余时间6天 2小时 28 分钟20 秒&quot;getEndTime: function (endTime) &#123; var startDate = new Date(); //开始时间，当前时间 var endDate = new Date(endTime); //结束时间，需传入时间参数 var t = endDate.getTime() - startDate.getTime(); //时间差的毫秒数 var d = 0, h = 0, m = 0, s = 0; if (t &gt;= 0) &#123; d = Math.floor(t / 1000 / 3600 / 24); h = Math.floor(t / 1000 / 60 / 60 % 24); m = Math.floor(t / 1000 / 60 % 60); s = Math.floor(t / 1000 % 60); &#125; return &quot;剩余时间&quot; + d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot; 分钟&quot; + s + &quot; 秒&quot;;&#125; 5-8适配rem这个适配的方法很多，我就写我自己用的方法。大家也可以去我回答过得一个问题那里看更详细的说明！移动端适配问题 123456789101112131415161718192021222324252627282930getFontSize: function (_client) &#123; var doc = document, win = window; var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;, recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; //如果屏幕大于750（750是根据我效果图设置的，具体数值参考效果图），就设置clientWidth=750，防止font-size会超过100px if (clientWidth &gt; _client) &#123; clientWidth = _client &#125; //设置根元素font-size大小 docEl.style.fontSize = 100 * (clientWidth / _client) + &apos;px&apos;; &#125;; //屏幕大小改变，或者横竖屏切换时，触发函数 win.addEventListener(resizeEvt, recalc, false); //文档加载完成时，触发函数 doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);&#125;//ecDo.getFontSize(750)//使用方式很简单，比如效果图上，有张图片。宽高都是100px;//750是设计图的宽度//样式写法就是img&#123; width:1rem; height:1rem;&#125;//这样的设置，比如在屏幕宽度大于等于750px设备上，1rem=100px；图片显示就是宽高都是100px//比如在iphone6(屏幕宽度：375)上，375/750*100=50px;就是1rem=50px;图片显示就是宽高都是50px; 5-9ajax12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 封装ajax函数 * @param &#123;string&#125;obj.type http连接的方式，包括POST和GET两种方式 * @param &#123;string&#125;obj.url 发送请求的url * @param &#123;boolean&#125;obj.async 是否为异步请求，true为异步的，false为同步的 * @param &#123;object&#125;obj.data 发送的参数，格式为对象类型 * @param &#123;function&#125;obj.success ajax发送并接收成功调用的回调函数 * @param &#123;function&#125;obj.error ajax发送失败或者接收失败调用的回调函数 */// ecDo.ajax(&#123;// type:&apos;get&apos;,// url:&apos;xxx&apos;,// data:&#123;// id:&apos;111&apos;// &#125;,// success:function(res)&#123;// console.log(res)// &#125;// &#125;)ajax: function (obj) &#123; obj = obj || &#123;&#125;; obj.type = obj.type.toUpperCase() || &apos;POST&apos;; obj.url = obj.url || &apos;&apos;; obj.async = obj.async || true; obj.data = obj.data || null; obj.success = obj.success || function () &#123; &#125;; obj.error = obj.error || function () &#123; &#125;; var xmlHttp = null; if (XMLHttpRequest) &#123; xmlHttp = new XMLHttpRequest(); &#125; else &#123; xmlHttp = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); &#125; var params = []; for (var key in obj.data) &#123; params.push(key + &apos;=&apos; + obj.data[key]); &#125; var postData = params.join(&apos;&amp;&apos;); if (obj.type.toUpperCase() === &apos;POST&apos;) &#123; xmlHttp.open(obj.type, obj.url, obj.async); xmlHttp.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded;charset=utf-8&apos;); xmlHttp.send(postData); &#125; else if (obj.type.toUpperCase() === &apos;GET&apos;) &#123; xmlHttp.open(obj.type, obj.url + &apos;?&apos; + postData, obj.async); xmlHttp.send(null); &#125; xmlHttp.onreadystatechange = function () &#123; if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; obj.success(xmlHttp.responseText); &#125; else &#123; obj.error(xmlHttp.responseText); &#125; &#125;;&#125; 5-10图片懒加载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//图片没加载出来时用一张图片代替aftLoadImg: function (obj, url, errorUrl,cb) &#123; var oImg = new Image(), _this = this; oImg.src = url; oImg.onload = function () &#123; obj.src = oImg.src; if (cb &amp;&amp; _this.istype(cb, &apos;function&apos;)) &#123; cb(obj); &#125; &#125; oImg.onerror=function () &#123; obj.src=errorUrl; if (cb &amp;&amp; _this.istype(cb, &apos;function&apos;)) &#123; cb(obj); &#125; &#125;&#125;,//图片滚动懒加载//@className &#123;string&#125; 要遍历图片的类名//@num &#123;number&#125; 距离多少的时候开始加载 默认 0//比如，一张图片距离文档顶部3000，num参数设置200，那么在页面滚动到2800的时候，图片加载。不传num参数就滚动，num默认是0，页面滚动到3000就加载//html代码//&lt;p&gt;&lt;img data-src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot; class=&quot;load-img&quot; width=&apos;528&apos; height=&apos;304&apos; /&gt;&lt;/p&gt;//&lt;p&gt;&lt;img data-src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot; class=&quot;load-img&quot; width=&apos;528&apos; height=&apos;304&apos; /&gt;&lt;/p&gt;//&lt;p&gt;&lt;img data-src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot; class=&quot;load-img&quot; width=&apos;528&apos; height=&apos;304&apos; /&gt;&lt;/p&gt;....//data-src储存src的数据，到需要加载的时候把data-src的值赋值给src属性，图片就会加载。//详细可以查看testLoadImg.html//window.onload = function() &#123;// loadImg(&apos;load-img&apos;,100);// window.onscroll = function() &#123;// ecDo.loadImg(&apos;load-img&apos;,100);// &#125;//&#125;loadImg: function (className, num, errorUrl) &#123; var _className = className || &apos;ec-load-img&apos;, _num = num || 0, _this = this,_errorUrl=errorUrl||null; var oImgLoad = document.getElementsByClassName(_className); for (var i = 0, len = oImgLoad.length; i &lt; len; i++) &#123; //如果图片已经滚动到指定的高度 if (document.documentElement.clientHeight + document.documentElement.scrollTop &gt; oImgLoad[i].offsetTop - _num &amp;&amp; !oImgLoad[i].isLoad) &#123; //记录图片是否已经加载 oImgLoad[i].isLoad = true; //设置过渡，当图片下来的时候有一个图片透明度变化 oImgLoad[i].style.cssText = &quot;transition: &apos;&apos;; opacity: 0;&quot; if (oImgLoad[i].dataset) &#123; this.aftLoadImg(oImgLoad[i], oImgLoad[i].dataset.src, _errorUrl, function (o) &#123; //添加定时器，确保图片已经加载完了，再把图片指定的的class，清掉，避免重复编辑 setTimeout(function () &#123; if (o.isLoad) &#123; _this.removeClass(o, _className); o.style.cssText = &quot;&quot;; &#125; &#125;, 1000) &#125;); &#125; else &#123; this.aftLoadImg(oImgLoad[i], oImgLoad[i].getAttribute(&quot;data-src&quot;), _errorUrl, function (o) &#123; //添加定时器，确保图片已经加载完了，再把图片指定的的class，清掉，避免重复编辑 setTimeout(function () &#123; if (o.isLoad) &#123; _this.removeClass(o, _className); o.style.cssText = &quot;&quot;; &#125; &#125;, 1000) &#125;); &#125; (function (i) &#123; setTimeout(function () &#123; oImgLoad[i].style.cssText = &quot;transition:all 1s; opacity: 1;&quot;; &#125;, 16) &#125;)(i); &#125; &#125;&#125; 5-11关键词加标签12345678910111213141516171819202122232425262728293031323334//这两个函数多用于搜索的时候，关键词高亮//创建正则字符//ecDo.createKeyExp([前端，过来])//result:(前端|过来)/gcreateKeyExp: function (strArr) &#123; var str = &quot;&quot;; for (var i = 0; i &lt; strArr.length; i++) &#123; if (i != strArr.length - 1) &#123; str = str + strArr[i] + &quot;|&quot;; &#125; else &#123; str = str + strArr[i]; &#125; &#125; return &quot;(&quot; + str + &quot;)&quot;;&#125;,//关键字加标签（多个关键词用空格隔开）//ecDo.findKey(&apos;守侯我oaks接到了来自下次你离开快乐吉祥留在开城侯&apos;,&apos;守侯 开&apos;,&apos;i&apos;)//&quot;&lt;i&gt;守侯&lt;/i&gt;我oaks接到了来自下次你离&lt;i&gt;开&lt;/i&gt;快乐吉祥留在&lt;i&gt;开&lt;/i&gt;城侯&quot;findKey: function (str, key, el) &#123; var arr = null, regStr = null, content = null, Reg = null, _el = el || &apos;span&apos;; arr = key.split(/\s+/); //alert(regStr); // 如：(前端|过来) regStr = this.createKeyExp(arr); content = str; //alert(Reg);// /如：(前端|过来)/g Reg = new RegExp(regStr, &quot;g&quot;); //过滤html标签 替换标签，往关键字前后加上标签 content = content.replace(/&lt;\/?[^&gt;]*&gt;/g, &apos;&apos;) return content.replace(Reg, &quot;&lt;&quot; + _el + &quot;&gt;$1&lt;/&quot; + _el + &quot;&gt;&quot;);&#125; 5-12数据类型判断123456789101112131415161718192021222324252627282930313233//ecDo.istype([],&apos;array&apos;)//true//ecDo.istype([])//&apos;[object Array]&apos;istype: function (o, type) &#123; if (type) &#123; var _type = type.toLowerCase(); &#125; switch (_type) &#123; case &apos;string&apos;: return Object.prototype.toString.call(o) === &apos;[object String]&apos;; case &apos;number&apos;: return Object.prototype.toString.call(o) === &apos;[object Number]&apos;; case &apos;boolean&apos;: return Object.prototype.toString.call(o) === &apos;[object Boolean]&apos;; case &apos;undefined&apos;: return Object.prototype.toString.call(o) === &apos;[object Undefined]&apos;; case &apos;null&apos;: return Object.prototype.toString.call(o) === &apos;[object Null]&apos;; case &apos;function&apos;: return Object.prototype.toString.call(o) === &apos;[object Function]&apos;; case &apos;array&apos;: return Object.prototype.toString.call(o) === &apos;[object Array]&apos;; case &apos;object&apos;: return Object.prototype.toString.call(o) === &apos;[object Object]&apos;; case &apos;nan&apos;: return isNaN(o); case &apos;elements&apos;: return Object.prototype.toString.call(o).indexOf(&apos;HTML&apos;) !== -1 default: return Object.prototype.toString.call(o) &#125;&#125; 5-13手机类型判断1234567891011121314browserInfo: function (type) &#123; switch (type) &#123; case &apos;android&apos;: return navigator.userAgent.toLowerCase().indexOf(&apos;android&apos;) !== -1 case &apos;iphone&apos;: return navigator.userAgent.toLowerCase().indexOf(&apos;iphone&apos;) !== -1 case &apos;ipad&apos;: return navigator.userAgent.toLowerCase().indexOf(&apos;ipad&apos;) !== -1 case &apos;weixin&apos;: return navigator.userAgent.toLowerCase().indexOf(&apos;micromessenger&apos;) !== -1 default: return navigator.userAgent.toLowerCase() &#125;&#125; 5-14函数节流1234567891011121314151617181920212223242526272829303132//多用于鼠标滚动，移动，窗口大小改变等高频率触发事件// var count=0;// function fn1()&#123;// count++;// console.log(count)// &#125;// //100ms内连续触发的调用，后一个调用会把前一个调用的等待处理掉，但每隔200ms至少执行一次// document.onmousemove=ecDo.delayFn(fn1,100,200)delayFn: function (fn, delay, mustDelay) &#123; var timer = null; var t_start; return function () &#123; var context = this, args = arguments, t_cur = +new Date(); //先清理上一次的调用触发（上一次调用触发事件不执行） clearTimeout(timer); //如果不存触发时间，那么当前的时间就是触发时间 if (!t_start) &#123; t_start = t_cur; &#125; //如果当前时间-触发时间大于最大的间隔时间（mustDelay），触发一次函数运行函数 if (t_cur - t_start &gt;= mustDelay) &#123; fn.apply(context, args); t_start = t_cur; &#125; //否则延迟执行 else &#123; timer = setTimeout(function () &#123; fn.apply(context, args); &#125;, delay); &#125; &#125;;&#125; 6.封装成形 可能有小伙伴会有疑问，这样封装，调用有点麻烦，为什么不直接在原型上面封装，调用方便。比如下面的栗子！ 123456789101112131415161718String.prototype.trim=function(type)&#123; switch (type)&#123; case 1:return this.replace(/\s+/g,&quot;&quot;); case 2:return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); case 3:return this.replace(/(^\s*)/g, &quot;&quot;); case 4:return this.replace(/(\s*$)/g, &quot;&quot;); default:return this; &#125;&#125;//&apos; 12345 6 8 96 &apos;.trim(1)//&quot;123456896&quot;//比这样trim(&apos; 12345 6 8 96 &apos;,1)调用方便。//但是，这样是不推荐的做法，这样就污染了原生对象String,别人创建的String也会被污染，造成不必要的开销。//更可怕的是，万一自己命名的跟原生的方法重名了，就被覆盖原来的方法了//String.prototype.substr=function()&#123;console.log(&apos;asdasd&apos;)&#125; //&apos;asdasdwe46546&apos;.substr()//asdasd //substr方法有什么作用，大家应该知道，不知道的可以去w3c看下 所以在原生对象原型的修改很不推荐！至少很多的公司禁止这样操作！ 所以建议的封装姿势是 1234var ecDo=&#123; trim:function()&#123;..&#125;, changeCase:function()&#123;..&#125;...&#125; 7.小结这篇文章，写了很久了，几个小时了，因为我写这篇文章，我也是重新改我以前代码的，因为我以前写的代码，功能一样，代码比较多，现在是边想边改边写，还要自己测试（之前的代码for循环很多，现在有很多简洁的写法代替）。加上最近公司比较忙，所以这一篇文章也是花了几天才整理完成。源码都放在github上了，大家想以后以后有什么修改或者增加的，欢迎大家来star一下ec-do。我自己封装这个，并不是我有造轮子的习惯，而是： 1，都是一些常用，但是零散的小实例，网上基本没有插件。 2，因为零散的小实例，涉及到的有字符串，数组，对象等类型，就算找到插件，在项目引入的很有可能不止一个插件。 3.都是简单的代码，封装也不难。维护也简单。 其他的不多说了，上面的只是我自己在开发中常用到，希望能帮到小伙伴们，最理想就是这篇文章能起到一个 抛砖引玉 的作用，就是说，如果觉得还有什么操作是常用的，或者觉得我哪里写得不好的，也欢迎指出，让大家相互帮助，相互学习。 JavaScript 前端 GitHub jQuery]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css内容属性]]></title>
    <url>%2F2017%2F10%2F16%2FCSS%E7%9A%84%E5%86%85%E5%AE%B9%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%A4%9A%E7%A7%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8F%96%E5%80%BC%EF%BC%8C%E8%AE%A9%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%9B%B4%E5%8A%A0%E4%B8%B0%E5%AF%8C%2F</url>
    <content type="text"><![CDATA[css 内容属性CSS 的内容属性，多种可能的取值，让样式设置更加丰富CSS 技术提供了一个名为 content 的属性，该属性被翻译为“内容”。该属性的使用必须配合伪元素选择器::before 或者::after 结合起来使用。该属性在容器中设置了一个内联元素，可以使用其他的 CSS 属性来对这个新增的内联元素进行设置。 承接文章：CSS3**伪装元素，尽管没有得到完美的兼容，仍有很强的用途**技术等级：中级 | 适合有一定的 CSS 基础的人士阅读。 希望收藏了这篇文章的你同时也可以关注一下“小海前端”的头条号，因为这些文章都是连载的，并且是经过系统的归纳和总结的。塌下心来认真阅读，你一定会学到对你有用的知识。 CSS3 所提供的增强用户界面的属性以及与此相关的属性比较多，小海前端（头条号）将分几次对其进行讲解。所包含的所有增强用户界面的属性包括： box-shadow box-sizing overflow-x overflow-y resize outline outline-width outline-style outline-color outline-offset pointer-events user-select appearance content counter-increment counter-reset quotes 本篇文章为大家讲解与 content 属性相关的属性的用法。 一、content 属性的设置： CSS 技术使用 content 属性来设置有关内容的效果 content 属性可以作用于任意的容器元素中，结合伪元素选择器::before 和::after 共同使用。该属性有多种取值，可以使用的取值包括： normal，默认值，表示没有任何内容在容器中被创建。 ，字符串，表示创建内容为指定字符串的内联元素在容器内部。 &lt;url()&gt;，url 地址，表示创建内容为 url 地址指定的对象的内联元素在容器内部。 &lt;attr()&gt;，HTML 属性名，表示创建内容为指定的 HTML 属性的取值的内联元素在容器内部。 ，表示创建内容为 quotes 属性的前标记的内联元素在容器内部。 ，表示创建内容为 quotes 属性的后标记的内联元素在容器内部。 &lt;counter()&gt;，计数器，表示创建计数器内容的内联元素在容器内部。 接下来让我们依次来学习 content 属性的各个取值的用法。为了更好的演示 content 属性的各种取值，首先我们在页面中创建一个无序列表： 白羊座金牛座双子座巨蟹座狮子座处女座 二、content 属性取值为： 例 1：在页面中创建一个无序列表，利用 content 属性为无序列表的每一列表项前面添加指定的字符串内容。 1234ul li::before &#123; content: "十二星座：; color: #ff5857;&#125; 这样，就可以在每一个列表项（即标记对）的内部的最前面添加指定的字符串内容。最终的显示效果如下图所示：左侧为原列表项，右侧为使用了 content 属性之后的列表项。 指定 content 属性取值为字符串 请小伙伴们打开浏览器的“开发人员工具”，查看“十二星座：”这几个字在 HTML 文档结构中的位置。具体的“开发人员工具”的界面如下图所示。 可以看出 content 属性添加的内容是容器内部的内联元素 从上图中可以看出，在的内部结构中，出现了一个“::before”结构，这个结构就是利用 content 属性添加到每一个无序列表项内部的字符串。 若需要在每一个列表项内部的后面添加指定的字符串内容，可以使用::after 伪元素选择器。 三、content 属性取值为&lt;url()&gt;： 例 2：利用 content 属性为无序列表的每一列表项后面添加一个指定的图片。 123ul li::after &#123; content: url(../images/xz.jpg);&#125; 最终的现实效果如下图所示： 指定 content 属性取值为 url()的文件路径 四、content 属性取值为&lt;attr()&gt;： 例 3：为每一个列表项标记对设置一个名为 data-li 的属性，并设置不同的内容。可以利用 content 属性的 attr()取值将这个名为 data-li 的属性取值作为内容添加到每一个列表项的前面。 HTML 中无序列表的代码如下所示： 12345678&lt;ul&gt; &lt;li data-li=”BaiYang”&gt;白羊座&lt;/li&gt; &lt;li data-li=”JinNiu”&gt;金牛座&lt;/li&gt; &lt;li data-li=”ShuangZi”&gt;双子座&lt;/li&gt; &lt;li data-li=”JuXie”&gt;巨蟹座&lt;/li&gt; &lt;li data-li=”ShiZi”&gt;狮子座&lt;/li&gt; &lt;li data-li=”ChuNv”&gt;处女座&lt;/li&gt; &lt;/ul&gt; CSS 代码如下所示： 1234ul li::before &#123; content: attr(data-li); color: #ff5857;&#125; 最终的现实效果如下图所示： 指定 content 属性取值为 attr()的 HTML 属性值 五:、content 属性取值为或：** 该取值会涉及到一个名为 quotes 的属性，该属性可以取两个利用空格隔开的字符串，空格之前的字符串被称为“前标记”，空格之后的字符串被称为“后标记”。 例 4: 为每一个列表项的前面添加一个左大括号{，后面添加一个右大括号}。 ul li{quotes:”{” ”}”;} ul li::before{content:open-quote;} ul li::after{content:close-quote;} 最终的现实效果如下图所示： 指定 content 属性取值为 quotes 属性的前标记或右标记 小海声明 在头条上发表的这些文章都是从前端开发的基础开始一步一步讲起的。我非常希望能有更多的前端开发初学者通过我写的文章，逐步学到一定的知识，甚至慢慢有了入门的感觉。这些文章都是我这几年教学过程中的经验，每写一篇时我都尽量把握好措辞，用简单易懂的语言描述，同时精心设计版面，让版面更加丰富，激发阅读兴趣。所以，每一篇文章可能篇幅不长，但是都要耗费小海老师很久的时间。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端类库]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Particles.js — 一个用来在 web 中创建炫酷的浮动粒子的库 Three.js — 一个用来在 web 中创建 3d 物体和 3d 空间的库 Fullpage.js— 快速实现全屏滚动特性 Typed.js — 打字机效果 Waypoints.js — 滚动到某个元素位置时触发一个功能 Highlight.js — web 语法高亮 Chart.js — 使用 JavaScript 创建漂亮的图表Instantclick — 能够明显加速网站加载时间，鼠标 hover 时预加载资源 Chartist — 另一个图表库 Motio — 一个基于动画和平移的雪碧图库 Animsition — CSS 实现动画过渡的 jQuery 插件 Barba.js — 流式页面过渡 TwentyTwenty — 一个对比图片的可视化 diff 工具 Vivus.js — 在 SVG 上绘制动画 Wow.js — 滚动时展现动画 Scrolline.js — 页面滚动时显示滚动进度 Velocity.js — 快速流畅的 JavaScript 动画 Animate on scroll — 漂亮的页面滚动元素动画 Handlebars.js — Javascript 模板 jInvertScroll — 视差滚动 One page scroll — 又一个页面滚动库 Parallax.js — 对智能设备方向变化做出响应的视差引擎 Typeahead.js — 搜索补全 Dragdealer.js — 炫酷拖拽 Bounce.js — 创建炫酷的 CSS3 动画 Pagepiling.js — 全屏滚动 Multiscroll.js — 两列垂直反向滚动 Favico.js — 动态 favicon Midnight.js — 固定头部切换效果 Anime.js — 动画库 Keycode — 获取键盘按键的 JavaScript keycode Sortable — 拖拽插件 Flexdatalist — 自动补全 Slideout.js — 移动应用侧滑导航 Jquerymy — 使用 jQuery 实现双向数据绑定 Cleave.js — 实时格式化输入内容 Page — 客户端单页应用路由 Selectize.js — 用来添加 tag 的 Hybrid 选择框 Nice select — 创建漂亮的选择框的 jQuery 库 Tether — 使用固定定位来创建相关元素 Shepherd.js — 为应用创建新手引导 Tooltip — tooltip 提示框 Select2 — Jquery 选择框插件 IziToast — 通知弹窗实现 IziModal — 模态框实现 CSS 类库特效 Animate.css — 动画库 Flat UI Colors — 扁平化设计配色 Material design lite— 基于 Google material design 的框架 Colorrrs — 随机颜色生成器 Section separators — CSS 实现区域分割 Topcoat — 框架 Create ken burns effect — 使用 CSS3 动画实现 Ken burns 特效 DynCSS — 给 CSS 添加 function，动态化 CSS Magic animations — CSS3 实现动画特效 CSSpin — css spinners 合集 Feather icons — Icon 集合 Ion icons — Icon 集合 Font awesome — Icon 集合 Font generator — 组合多个字体创建混合字体 On/Off switch — 使用 CSS 创建 on/off 开关、radio 按钮 UI Kit — 框架 Bootstrap — 框架 Foundation — 框架前端面试必知必会的十点： 1、常见的浏览器内核有哪些？ IE浏览器的内核：Trident、 Mozilla的Gecko、 Chrome的Blink（WebKit的分支）、 Opera内核原为Presto，现为Blink 2、行内元素有哪些?块级元素有哪些?CSS的盒模型? 块级元素：div p h1 h2 h3 h4 form ul 行内元素: a b br i span input select Css盒模型:内容，border ,margin，padding 3、简述一下你对HTML语义化的理解？ HTML语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 HTML语义化的主要目的是： 1).为了在没有css的情况下，页面也能呈现出很好地内容结构、代码结构 2).有利于用户体验 3).有利于SEO和搜索引擎建立良好的沟通。 4).方便其他设备解析以意义的方式来渲染网页、 5).便于团队开发和维护，增加可读性。 4、前端页面有哪三层构成，分别是什么？作用是什么？ 最准确的网页设计思路是把网页分成三个层次，即：结构层、表示层、行为层。 网页的结构层（structural layer）由 HTML 或 XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。” 网页的表示层（presentation layer）由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。 网页的行为层（behavior layer）负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM 主宰的领域。 5、HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websockt, Geolocation 移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式。 6、请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会 sessionStorage和localStorage的存储空间更大； sessionStorage和localStorage有更多丰富易用的接口； sessionStorage和localStorage各自独立的存储空间。 7、CSS引入的方式有哪些? link和@import的区别是? 内联 内嵌 外链 导入 区别 ：同时加载 前者无兼容性，后者CSS2.1以下浏览器不支持 Link 支持使用javascript改变样式，后者不可 8、CSS清除浮动的几种方法（至少两种） 使用带clear属性的空元素 使用CSS的overflow属性； 使用CSS的:after伪元素； 使用邻接元素处理。 9、谈一谈JavaScript作用域链 当执行一段JavaScript代码（全局代码或函数）时，JavaScript引擎会创建为其创建一个作用域又称为执行上下文（Execution Context），在页面加载后会首先创建一个全局的作用域，然后每执行一个函数，会建立一个对应的作用域，从而形成了一条作用域链。每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。 作用域链的作用是用于解析标识符，当函数被创建时（不是执行），会将this、arguments、命名参数和该函数中的所有局部变量添加到该当前作用域中，当JavaScript需要查找变量X的时候（这个过程称为变量解析），它首先会从作用域链中的链尾也就是当前作用域进行查找是否有X属性，如果没有找到就顺着作用域链继续查找，直到查找到链头，也就是全局作用域链，仍未找到该变量的话，就认为这段代码的作用域链上不存在x变量，并抛出一个引用错误（ReferenceError）的异常。 10、如何理解JavaScript原型链 JavaScript中的每个对象都有一个prototype属性，我们称之为原型，而原型的值也是一个对象，因此它也有自己的原型，这样就串联起来了一条原型链，原型链的链头是object,它的prototype比较特殊，值为null。 原型链的作用是用于对象继承，函数A的原型属性(prototype property)是一个对象，当这个函数被用作构造函数来创建实例时，该函数的原型属性将被作为原型赋值给所有对象实例，比如我们新建一个数组，数组的方法便从数组的原型上继承而来。 当访问对象的一个属性时, 首先查找对象本身, 找到则返回; 若未找到, 则继续查找其原型对象的属性(如果还找不到实际上还会沿着原型链向上查找, 直至到根). 只要没有被覆盖的话, 对象原型的属性就能在所有的实例中找到，若整个原型链未找到则返回undefined。]]></content>
      <categories>
        <category>前端, css, 编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 开发人员需要知道的简写技巧]]></title>
    <url>%2F2017%2F10%2F01%2Fjs%E7%AE%80%E5%86%99%E6%8A%80%E5%B7%A7%20%2F</url>
    <content type="text"><![CDATA[标签： 编程 初级篇1、三目运算符下面是一个很好的例子，将一个完整的 if 语句，简写为一行代码。 1234567const x = 20;let answer;if (x &gt; 10) &#123; answer = "greater than 10";&#125; else &#123; answer = "less than 10";&#125; 简写为： 1const answer = x &gt; 10 ? "greater than 10" : "less than 10"; 2、循环语句当使用纯 JavaScript（不依赖外部库，如 jQuery 或 lodash）时，下面的简写会非常有用。 1for (let i = 0; i &lt; allImgs.length; i++) 简写为: 1for (let index of allImgs) 下面是遍历数组 forEach 的简写示例： 12345678function logArrayElements(element, index, array) &#123; console.log("a[" + index + "] = " + element);&#125;[2, 5, 9].forEach(logArrayElements);// logs:// a[0] = 2// a[1] = 5// a[2] = 9 3、声明变量在函数开始之前，对变量进行赋值是一种很好的习惯。在申明多个变量时： 123let x;let y;let z = 3; 可以简写为: 1let x, y, z=3; 4、if 语句使用 if 进行判断时可以省略赋值运算符 1if(likeJavaScript===true) 简写为: 1if(likeJavaScipt) 5、十进制数可以使用科学计数法来代替较大的数据，如可以将 10000000 简写为 1e7。 1for (let i = 0; i &lt; 10000; i++) &#123; &#125; 简写为: 1for (let i = 0; i &lt; 1e7; i++) &#123; &#125; 6、多行字符串如果需要在代码中编写多行字符串，就像下面这样： 12345678910111213141516const lorem = 'Lorem ipsum dolor sit amet, consectetur\n\t' + 'adipisicing elit, sed do eiusmod tempor incididunt\n\t' + 'ut labore et dolore magna aliqua. Ut enim ad minim\n\t' + 'veniam, quis nostrud exercitation ullamco laboris\n\t' + 'nisi ut aliquip ex ea commodo consequat. Duis aute\n\t' + 'irure dolor in reprehenderit in voluptate velit esse.\n\t'但是还有一个更简单的方法，只使用引号：const lorem = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse.\` 高级篇1、变量赋值当将一个变量的值赋给另一个变量时，首先需要确保原值不是 null、未定义的或空值。 可以通过编写一个包含多个条件的判断语句来实现： 123if (variable1 !== null || variable1 !== undefined || variable1 !== '') &#123; let variable2 = variable1;&#125; 或者简写为以下的形式： 1const variable2 = variable1 || 'new'; 可以将下面的代码粘贴到 es6console 中，自己测试： 123456let variable1;let variable2 = variable1 || '';console.log(variable2 === ''); // prints truevariable1 = 'foo';variable2 = variable1 || '';console.log(variable2); // prints foo 2、默认值赋值如果预期参数是 null 或未定义，则不需要写六行代码来分配默认值。我们可以只使用一个简短的逻辑运算符，只用一行代码就能完成相同的操作。 123456let dbHost;if (process.env.DB_HOST) &#123; dbHost = process.env.DB_HOST;&#125; else &#123; dbHost = 'localhost';&#125; 简写为： 1const dbHost = process.env.DB_HOST || 'localhost'; 3、对象属性ES6 提供了一个很简单的办法，来分配属性的对象。如果属性名与 key 名相同，则可以使用简写。 1const obj = &#123; x:x, y:y &#125;; 简写为： 1const obj = &#123; x, y &#125;; 4、箭头函数经典函数很容易读写，但是如果把它们嵌套在其它函数中进行调用时，整个函数就会变得有些冗长和混乱。这时候可以使用箭头函数来简写： 1234567891011function sayHello(name) &#123; console.log('Hello', name);&#125;setTimeout(function() &#123; console.log('Loaded')&#125;, 2000);list.forEach(function(item) &#123; console.log(item);&#125;); 简写为： 123sayHello = name =&gt; console.log('Hello', name);setTimeout(() =&gt; console.log('Loaded'), 2000);list.forEach(item =&gt; console.log(item)); 5、隐式返回值返回值是我们通常用来返回函数最终结果的关键字。只有一个语句的箭头函数，可以隐式返回结果（函数必须省略括号（{ }），以便省略返回关键字）。 要返回多行语句（例如对象文本），需要使用（）而不是{ }来包裹函数体。这样可以确保代码以单个语句的形式进行求值。 123function calcCircumference(diameter) &#123; return Math.PI * diameter&#125; 简写为： 123calcCircumference = diameter =&gt; ( Math.PI * diameter;) 6、默认参数值可以使用 if 语句来定义函数参数的默认值。ES6 中规定了可以在函数声明中定义默认值。 1234567function volume(l, w, h) &#123; if (w === undefined) w = 3; if (h === undefined) h = 4; return l * w * h;&#125; 简写为： 12volume = (l, w = 3, h = 4 ) =&gt; (l * w * h);volume(2) //output: 24 7、模板字符串过去我们习惯了使用“+”将多个变量转换为字符串，但是有没有更简单的方法呢？ ES6 提供了相应的方法，我们可以使用反引号和 $ { } 将变量合成一个字符串。 12const welcome = 'You have logged in as ' + first + ' ' + last + '.'const db = 'http://' + host + ':' + port + '/' + database; 简写为： 12const welcome = `You have logged in as $&#123;first&#125; $&#123;last&#125;`;const db = `http://$&#123;host&#125;:$&#123;port&#125;/$&#123;database&#125;`; 8、解构赋值解构赋值是一种表达式，用于从数组或对象中快速提取属性值，并赋给定义的变量。 在代码简写方面，解构赋值能达到很好的效果。 12345678const observable = require('mobx/observable');const action = require('mobx/action');const runInAction = require('mobx/runInAction');const store = this.props.store;const form = this.props.form;const loading = this.props.loading;const errors = this.props.errors;const entity = this.props.entity; 简写为： 12import &#123; observable, action, runInAction &#125; from 'mobx';const &#123; store, form, loading, errors, entity &#125; = this.props; 甚至可以指定自己的变量名： 1const &#123; store, form, loading, errors, entity:contact &#125; = this.props; 9、展开运算符展开运算符是在 ES6 中引入的，使用展开运算符能够让 JavaScript 代码更加有效和有趣。 使用展开运算符可以替换某些数组函数。 1234567// joining arraysconst odd = [1, 3, 5];const nums = [2 ,4 , 6].concat(odd);// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = arr.slice( ) 简写为： 12345678// joining arraysconst odd = [1, 3, 5 ];const nums = [2 ,4 , 6, ...odd];console.log(nums); // [ 2, 4, 6, 1, 3, 5 ]// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = [...arr]; 和 concat( ) 功能不同的是，用户可以使用扩展运算符在任何一个数组中插入另一个数组。 12const odd = [1, 3, 5 ];const nums = [2, ...odd, 4 , 6]; 也可以将展开运算符和 ES6 解构符号结合使用： 1234const &#123; a, b, ...z &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;console.log(a) // 1console.log(b) // 2console.log(z) // &#123; c: 3, d: 4 &#125; 10、强制参数默认情况下，如果不向函数参数传值，那么 JavaScript 会将函数参数设置为未定义。其它一些语言则会发出警告或错误。要执行参数分配，可以使用 if 语句抛出未定义的错误，或者可以利用“强制参数”。 123456function foo(bar) &#123;if(bar === undefined) &#123;throw new Error('Missing parameter!');&#125;return bar;&#125; 简写为： 123456mandatory = ( ) =&gt; &#123;throw new Error('Missing parameter!');&#125;foo = (bar = mandatory( )) =&gt; &#123;return bar;&#125; 11、Array.find如果你曾经编写过普通 JavaScript 中的 find 函数，那么你可能使用了 for 循环。在 ES6 中，介绍了一种名为 find（）的新数组函数，可以实现 for 循环的简写。 123456789101112const pets = [&#123; type: 'Dog', name: 'Max'&#125;,&#123; type: 'Cat', name: 'Karl'&#125;,&#123; type: 'Dog', name: 'Tommy'&#125;,]function findDog(name) &#123;for(let i = 0; i&lt;pets.length; ++i) &#123;if(pets[i].type === 'Dog' &amp;&amp; pets[i].name === name) &#123;return pets[i];&#125;&#125;&#125; 简写为： 12pet = pets.find(pet =&gt; pet.type ==='Dog' &amp;&amp; pet.name === 'Tommy');console.log(pet); // &#123; type: 'Dog', name: 'Tommy' &#125; 12、Object [key]虽然将 foo.bar 写成 foo [‘bar’] 是一种常见的做法，但是这种做法构成了编写可重用代码的基础。 请考虑下面这个验证函数的简化示例： 12345678function validate(values) &#123;if(!values.first)return false;if(!values.last)return false;return true;&#125;console.log(validate(&#123;first:'Bruce',last:'Wayne'&#125;)); // true 上面的函数完美的完成验证工作。但是当有很多表单，则需要应用验证，此时会有不同的字段和规则。如果可以构建一个在运行时配置的通用验证函数，会是一个好选择。 1234567891011121314151617181920212223// object validation rulesconst schema = &#123;first: &#123;required:true&#125;,last: &#123;required:true&#125;&#125;// universal validation functionconst validate = (schema, values) =&gt; &#123;for(field in schema) &#123;if(schema[field].required) &#123;if(!values[field]) &#123;return false;&#125;&#125;&#125;return true;&#125;console.log(validate(schema, &#123;first:'Bruce'&#125;)); // falseconsole.log(validate(schema, &#123;first:'Bruce',last:'Wayne'&#125;)); // true 现在有了这个验证函数，我们就可以在所有窗体中重用，而无需为每个窗体编写自定义验证函数。 13、双位操作符位操作符是 JavaScript 初级教程的基本知识点，但是我们却不常使用位操作符。因为在不处理二进制的情况下，没有人愿意使用 1 和 0。 但是双位操作符却有一个很实用的案例。你可以使用双位操作符来替代 Math.floor( )。双否定位操作符的优势在于它执行相同的操作运行速度更快。 1Math.floor(4.9) === 4 //true 简写为： 1~~4.9 === 4 //true JavaScript 开发工具推荐 SpreadJS 纯前端表格控件是基于 HTML5 的 JavaScript 电子表格和网格功能控件，提供了完备的公式引擎、排序、过滤、输入控件、数据可视化、Excel 导入/导出等功能，适用于 .NET、Java 和移动端等各平台在线编辑类 Excel 功能的表格程序开发。]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Programming</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuejs教程]]></title>
    <url>%2F2017%2F09%2F28%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%AD%A6%E6%A1%86%E6%9E%B6Vue.js%2F</url>
    <content type="text"><![CDATA[前端开发必学框架Vue.js我们都知道 Vue 是一个非常典型的 MVVM 框架，它的核心功能： 双向数据绑定系统 组件化开发系统 本文我们就聊聊双向数据绑定，不管你是学过或者没学过，我相信看完本文你都会对 vue 有一个比较简单明确的了解。不过如果哪块有错误，还望指出。很多朋友说自己读不懂，索性就“不敢”去读。要我说凡事均要去尝试，不尝试永远没有读懂的机会，如果你试着读了，并且坚持了，那你就真的能读懂。 读源码也是有技巧的，我的技巧就是： 抓住主线，从宏观到微观。 我们不能一开始就要求自己读懂所有的细节，基本不现实；最好是能找到一条主线，先把大体流程结构摸清楚，再深入到细节，逐项击破，形成对源码整体的认识。 比如，我们都知道 Vue 中更新数据后会采用 virtual DOM（虚拟dom）的方式更新 dom。 这个时候，如果你不了解 virtual DOM，那么听我一句“暂且不要去研究内部具体实现，因为这会使你丧失主线”，而你仅仅需要知道 virtual DOM 分为三个步骤： createElement( ): 用 JavaScript 对象(虚拟树) 描述 真实 DOM 对象(真实树) diff(oldNode, newNode) : 对比新旧两个虚拟树的区别，收集差异 patch( ) : 将差异应用到真实 DOM 树 回过头我们再去研究这个分支，仅此而已。 上图对于学习过 Vue 的朋友来说应该不陌生吧，来自 Vue 官网深入响应式原理，建议先看图一分钟。 为了说明原理，我们会把虚拟 dom 这块用 fragment 来代替（这个是1.x版本的实现）。 并且只考虑数据为对象的情况。记住今天的主线：搞清楚响应式原理，实现一个简单的 MVVM 框架。 由一个例子开始： template： javascript： 我们要解决的问题有： 如何将 data 中的数据渲染到真实的宿主环境中？ template 是如何被编译成真实环境中可用的 HTML 的？ 如何通过“响应式”修改数据？ 计算属性 getWeChatblog 如何和 data 中的数据绑定的？ 带着这些问题开始我们 Vues 的开发。尽量和 Vue 代码保持一致。下面是目录结构： 入口文件： export 构造函数 Vues，不清楚 ES6 中 module 可以可以点这里 初始化 进入到 ./instance/index.js 就可以看到 Vues 构造函数 其实就是调用 this._init(options)，我们先不看这个函数是做什么的，这里有一个疑惑点，我们并没有在 Vues 构造函数内部申明 _init() 函数呀，那是因为我们调用了一个 initMixin 函数，我们来看看此函数： ok，原来 _init() 是在这里定义的，在 Vues 的原型上扩展了此方法。Vue也用了这种形式。 在 _init() 首先调用了 initState（this） ： 但是这里有个问题，从代码中可看出监听的数据对象是 $options.data，每次需要更新视图，则必须通过 vm._data.dsx= ‘前端开发大师兄’;这样的方式来改变数据。 这显然不符合 Vue 中的赋值方式，我们所期望的调用方式应该是这样的： vm.dsx = ‘前端开发大师兄’; 所以这里需要给 Vues 实例添加一个属性代理的方法 _proxyData()，使访问 vm 的属性代理为访问 vm._data 的属性，方法代码如下： 我们初始化计算属性 computed，具体就是调用了函数 _initComputed(vm)，来看看代码： 我们可以看出我们已经两次用到同一个方法——Object.defineProperty()，这就是 Vue 实现响应式数据的利器之一。举个栗子来说明。 我们为对象a 通过该方法定义了一个b属性，然后定义了 set 和 get 属性，这样我们给b 赋值就会触发它的 set 属性，我们获取值就会触发它的 get 属性。 这样我们就可以劫持数据，然后执行我们的操作。详细点可以看这里。 observe 这是我们第一个重点，observe 很明显我们会用到观察者模式，事实上Vue也是这么干的。我们看一下 observe() 做了什么？ 就是做了类型判断，之后就直接实例化 Oberver ，参数为 data 对象。 官网的 Reactivity in Depth 上有这么句话： When you pass a plain JavaScript object to a Vue instance as its data option, Vue.js will walk through all of its properties and convert them to getter/setters The getter/setters are invisible to the user, but under the hood they enable Vue.js to perform dependency-tracking and change-notification when properties are accessed or modified observe 使 data 变成“发布者”，watcher 是订阅者，订阅 data 的变化。那如何使 data 变为“发布者”呢？ 当然是我们的利器—-Object.defineProperty() ，将数据对象 data 的属性转换为访问器属性。看看我们的代码： 我们遍历 data 对象的所有可配置属性，最终调用了 defineReactive() 函数。 将需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 set 和 get 。 先看看 defineReactive() 的我们是怎么实现的： 这个地方有一个值得思考的点，如果修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。 但这时候出现了一个问题，如果我们进行 pop、push 等操作的时候，push 进去的对象根本没有进行过双向绑定，更别说 pop 了，那么我们如何监听数组的这些变化呢？ Vue.js 提供的方法是重写 push、pop、shift、unshift、splice、sort、reverse 这七个数组方法。 修改数组原型方法的代码可以参考observer/array.js 以及 observer/index.js。 还有就是利用 vue.set() ,借用官方的 API get 的方法主要用来进行依赖收集，就是添加订阅者。 所以我们只要在最开始进行一次 render，那么所有被渲染所依赖的 data 中的数据就会被 getter 收集到 Dep 的 subs 中去。 set 方法会在对象被修改的时候触发（不存在添加属性的情况，添加属性请用Vue.set），这时候 set 会通知闭包中的 Dep，Dep 中有一些订阅了这个对象改变的 Watcher 观察者对象，Dep 会通知 Watcher 对象更新视图。 我们用一个简单的栗子来说明观察者模式： 那应用到我们这里就是：每个 data 属性值在 defineReactive 函数监听处理的时候，添加一个主题对象，当 data 属性发生改变,通过 set 函数去通知所有的观察者们。 那么如何添加观察者们呢，就是在 complie 函数编译 template 时，通过初始化 value 值，触发 set 函数，在 set 函数中为主题对象添加观察者。有点难理解？直接看代码就明白了。 ok，我们继续。看看我们的 Dep ： 那么你可能有疑问了。。谁是订阅者。。对，没错就是 Watcher。。一旦 dep.notify() 就遍历订阅者，也就是 Watcher，并调用他的 update() 方法。 Watcher 如何实现一个 Watcher，通过上面的分析我可以确定得要一个 update() 方法。见下图： 很关键的一个地方就是 this.value = this.get() ,这个就是我们之前说的最开始要进行一次 render，我们看 get() 实现： 这个最关键了，主要做了以下几件事： 把当前 watcher 赋值给 Dep.target 获取 value 值就会触发 Oberver 中定义的 get 执行 dep.append() 添加订阅者 重新将 Dep.target 赋值为 null 返回 vaule 值 关于 notify 当监听的数据赋值就会被 set 拦截，然后执行 dep.notify() ，遍历订阅者（watcher）执行其 update() 方法，update 调用的其实是 this.run() 自己的 run 方法。我们看看： 有一个值得注意的地方，this.cb.call(this.vm, value, oldVal); 这个 cb 是什么？没错就是我们在编译 template 的时候为每一个指令绑定的更新 dom 的函数 。 最后对 watcher 做一个总结： 每次调用 run() 的时候会触发相应属性的 get get 里面会触发 dep.depend()，继而触发这里的 addDep 假如相应属性的 dep.id 已经在当前 watcher 的 depIds 里，说明不是一个新的属性，仅仅是改变了其值而已。 则不需要将当前 watcher 添加到该属性的 dep 里 假如相应属性是新的属性，则将当前watcher添加到新属性的dep里，如通过 vm.child = {name: ‘a’} 改变了 child.name 的值，child.name 就是个新属性。 则需要将当前watcher(child.name)加入到新的 child.name 的 dep 里，因为此时 child.name 是个新值，之前的 set，dep 都已经失效，如果不把 watcher 加入到新的 child.name 的dep中。 通过 child.name = xxx 赋值的时候，对应的 watcher 就收不到通知，等于失效了。 每个子属性的 watcher 在添加到子属性的 dep 的同时，也会添加到父属性的 dep。 监听子属性的同时监听父属性的变更，这样，父属性改变时，子属性的 watcher 也能收到通知进行 update。 这一步是在 this.get() –&gt; this.getVMVal() 里面完成，forEach 时会从父级开始取值，间接调用了它的 get，触发 addDep()，在整个 forEach 过程，当前 wacher 都会加入到每个父级过程属性的 dep。 例如：当前 watcher 的是 ‘child.child.name’, 那么 child, child.child, child.child.name 这三个属性的 dep 都会加入当前watcher。 到时候看看 Compile 了。 Compile 还记得在 _init() 函数最后那行代码吗？ new Compile ,看看做了什么？ 注释说的很明白，就不做解释。看看如何转化 fragment : 就是遍历子节点添加到 fragment 。 接下来我们就会对 fragment 节点包括子节点遍历，判断其节点类型，然后调用对应的解析函数解析其中的指令。 我们只看一个 compile： 内置的指令处理方法： 最终都调用同一个方法bind() ，我们先看看它是做了什么？ 获取对应指令的更新方法，并执行 new Watcher，在回调函数执行 updaterFn 对于第一条，在执行 updaterFn 的时候会调用 this._getVMVal(vm, exp) : 很简单，就是获取对应的数据返回。我们看一个text类型的更新函数： 这个也是没毛病吧？ok。 第二条，new Watcher，在回调函数执行 updaterFn。还记得之前讲Watcher时提过一句： 还没记住，我就再贴一次图了 哈哈哈，明白了吧。那这个cb啥时执行呢？ 当我们修改了数据就会触发对应的set ，然后就会调用 dep.notify();，通知订阅者，再调用订阅者的 update() 方法，update() 方法就会调用 this.run( ) ，run() 就会执行下面这一句： 最后补充，input 的 v-model 双向数据绑定，其实就是监听了 input 事件，还是贴代码： 在 input 事件回调执行 _setVMVal() 方法重新设置一次值。最后再贴一次代码，感觉我贴了好多，不过都是为了把事情说清楚。 到这我们就完成了一个缩减版的 Vue，当然 Vue 功能远远不止这些。我们这只是凤毛麟角。 学会这个对于你看真正的 Vue 源码帮助绝对很大，因为逻辑都是相似的。最后再看看下图，回味一下整个过程。 篇幅比较长，有时还很罗嗦，当然我只是想更清楚的讲解，真怕漏掉那个难点。]]></content>
      <categories>
        <category>前端, css, 编程, js</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题2]]></title>
    <url>%2F2017%2F09%2F26%2F%E6%AD%A3%E7%A1%AE%E9%9D%A2%E5%AF%B9%E8%B7%A8%E5%9F%9F%EF%BC%8C%E5%88%AB%E6%85%8C%2F</url>
    <content type="text"><![CDATA[正确面对跨域，别慌 前端开发中，跨域使我们经常遇到的一个问题，也是面试中经常被问到的一些问题，所以，这里，我们做个总结。小小问题，不足担心 原文地址：YOU-SHOULD-KNOW-JS 什么是跨域跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。 同源策略限制了一下行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 JS 对象无法获取 Ajax请求发送不出去 常见的跨域场景所谓的同源是指，域名、协议、端口均为相同。 1234567891011http://www.nealyang.cn/index.html 调用 http://www.nealyang.cn/server.php 非跨域http://www.nealyang.cn/index.html 调用 http://www.neal.cn/server.php 跨域,主域不同http://abc.nealyang.cn/index.html 调用 http://def.neal.cn/server.php 跨域,子域名不同http://www.nealyang.cn:8080/index.html 调用 http://www.nealyang.cn/server.php 跨域,端口不同https://www.nealyang.cn/index.html 调用 http://www.nealyang.cn/server.php 跨域,协议不同localhost 调用 127.0.0.1 跨域 跨域的解决办法jsonp跨域jsonp跨域其实也是JavaScript设计模式中的一种代理模式。在html页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信 12345678910//原生的实现方式let script = document.createElement(&apos;script&apos;);script.src = &apos;http://www.nealyang.cn/login?username=Nealyang&amp;callback=callback&apos;;document.body.appendChild(script);function callback(res) &#123; console.log(res);&#125; 当然，jquery也支持jsonp的实现方式 123456789$.ajax(&#123; url:&apos;http://www.nealyang.cn/login&apos;, type:&apos;GET&apos;, dataType:&apos;jsonp&apos;,//请求方式为jsonp jsonpCallback:&apos;callback&apos;, data:&#123; &quot;username&quot;:&quot;Nealyang&quot; &#125;&#125;) 虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求 document.domain + iframe 跨域这种跨域的方式最主要的是要求主域名相同。什么是主域名相同呢？ www.nealyang.cn aaa.nealyang.cn ba.ad.nealyang.cn 这三个主域名都是nealyang.cn,而主域名不同的就不能用此方法。 假设目前a.nealyang.cn 和 b.nealyang.cn 分别对应指向不同ip的服务器。 a.nealyang.cn 下有一个test.html文件 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;html&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src = &quot;jquery-1.12.1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;A页面&lt;/div&gt; &lt;iframe style = &quot;display : none&quot; name = &quot;iframe1&quot; id = &quot;iframe&quot; src=&quot;http://b.nealyang.cn/1.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; try&#123; document.domain = &quot;nealyang.cn&quot; &#125;catch(e)&#123;&#125; $(&quot;#iframe&quot;).load(function()&#123; var jq = document.getElementById(&apos;iframe&apos;).contentWindow.$ jq.get(&quot;http://nealyang.cn/test.json&quot;,function(data)&#123; console.log(data); &#125;); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用 iframe 加载 其他域下的文件（nealyang.cn/1.html）, 同时 document.domain 设置成 nealyang.cn ，当 iframe 加载完毕后就可以获取 nealyang.cn 域下的全局对象， 此时尝试着去请求 nealyang.cn 域名下的 test.json （此时可以请求接口），就会发现数据请求失败了~~ 惊不惊喜，意不意外！！！！！！！ 数据请求失败，目的没有达到，自然是还少一步： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;html&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src = &quot;jquery-1.12.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; try&#123; document.domain = &quot;nealyang.com&quot; &#125;catch(e)&#123;&#125; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id = &quot;div1&quot;&gt;B页面&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 此时在进行刷新浏览器，就会发现数据这次真的是成功了~ window.name + iframe 跨域window.name属性可设置或者返回存放窗口名称的一个字符串。他的神器之处在于name值在不同页面或者不同域下加载后依旧存在，没有修改就不会发生变化，并且可以存储非常长的name(2MB) 假设index页面请求远端服务器上的数据，我们在该页面下创建iframe标签，该iframe的src指向服务器文件的地址（iframe标签src可以跨域），服务器文件里设置好window.name的值，然后再在index.html里面读取改iframe中的window.name的值。完美~ 12345678910&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; iframe = document.createElement(&apos;iframe&apos;), iframe.src = &apos;http://localhost:8080/data.php&apos;; document.body.appendChild(iframe); iframe.onload = function() &#123; console.log(iframe.contentWindow.name) &#125;; &lt;/script&gt;&lt;/body&gt; 当然，这样还是不够的。 因为规定如果index.html页面和和该页面里的iframe框架的src如果不同源，则也无法操作框架里的任何东西，所以就取不到iframe框架的name值了，告诉你我们不是一家的，你也休想得到我这里的数据。 既然要同源，那就换个src去指，前面说了无论怎样加载window.name值都不会变化，于是我们在index.html相同目录下，新建了个proxy.html的空页面，修改代码如下： 1234567891011&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; iframe = document.createElement(&apos;iframe&apos;), iframe.src = &apos;http://localhost:8080/data.php&apos;; document.body.appendChild(iframe); iframe.onload = function() &#123; iframe.src = &apos;http://localhost:81/cross-domain/proxy.html&apos;; console.log(iframe.contentWindow.name) &#125;; &lt;/script&gt;&lt;/body&gt; 理想似乎很美好，在iframe载入过程中，迅速重置iframe.src的指向，使之与index.html同源，那么index页面就能去获取它的name值了！但是现实是残酷的，iframe在现实中的表现是一直不停地刷新， 也很好理解，每次触发onload时间后，重置src，相当于重新载入页面，又触发onload事件，于是就不停地刷新了（但是需要的数据还是能输出的）。修改后代码如下： 1234567891011121314151617181920212223&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; iframe = document.createElement(&apos;iframe&apos;); iframe.style.display = &apos;none&apos;; var state = 0; iframe.onload = function() &#123; if(state === 1) &#123; var data = JSON.parse(iframe.contentWindow.name); console.log(data); iframe.contentWindow.document.write(&apos;&apos;); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125; else if(state === 0) &#123; state = 1; iframe.contentWindow.location = &apos;http://localhost:81/cross-domain/proxy.html&apos;; &#125; &#125;; iframe.src = &apos;http://localhost:8080/data.php&apos;; document.body.appendChild(iframe); &lt;/script&gt;&lt;/body&gt; 所以如上，我们就拿到了服务器返回的数据，但是有几个条件是必不可少的： iframe标签的跨域能力 window.names属性值在文档刷新后依然存在的能力 location.hash + iframe 跨域此跨域方法和上面介绍的比较类似，一样是动态插入一个iframe然后设置其src为服务端地址，而服务端同样输出一端js代码，也同时通过与子窗口之间的通信来完成数据的传输。 关于锚点相信大家都已经知道了，其实就是设置锚点，让文档指定的相应的位置。锚点的设置用a标签，然后href指向要跳转到的id，当然，前提是你得有个滚动条，不然也不好滚动嘛是吧。 而location.hash其实就是url的锚点。比如http://www.nealyang.cn#Nealyang的网址打开后，在控制台输入location.hash就会返回#Nealyang的字段。 基础知识补充完毕，下面我们来说下如何实现跨域 如果index页面要获取远端服务器的数据，动态的插入一个iframe，将iframe的src执行服务器的地址，这时候的top window 和包裹这个iframe的子窗口是不能通信的，因为同源策略，所以改变子窗口的路径就可以了，将数据当做改变后的路径的hash值加载路径上，然后就可以通信了。将数据加在index页面地址的hash上， index页面监听hash的变化，h5的hashchange方法 123456789101112131415161718192021222324&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function getData(url, fn) &#123; var iframe = document.createElement(&apos;iframe&apos;); iframe.style.display = &apos;none&apos;; iframe.src = url; iframe.onload = function() &#123; fn(iframe.contentWindow.location.hash.substring(1)); window.location.hash = &apos;&apos;; document.body.removeChild(iframe); &#125;; document.body.appendChild(iframe); &#125; // get data from server var url = &apos;http://localhost:8080/data.php&apos;; getData(url, function(data) &#123; var jsondata = JSON.parse(data); console.log(jsondata.name + &apos; &apos; + jsondata.age); &#125;); &lt;/script&gt;&lt;/body&gt; 补充说明：其实location.hash和window.name都是差不多的，都是利用全局对象属性的方法，然后这两种方法和jsonp也是一样的，就是只能够实现get请求 postMessage跨域这是由H5提出来的一个炫酷的API，IE8+，chrome,ff都已经支持实现了这个功能。这个功能也是非常的简单，其中包括接受信息的Message时间，和发送信息的postMessage方法。 发送信息的postMessage方法是向外界窗口发送信息 1otherWindow.postMessage(message,targetOrigin); otherWindow指的是目标窗口，也就是要给哪一个window发送消息，是window.frames属性的成员或者是window.open方法创建的窗口。 Message是要发送的消息，类型为String，Object(IE8、9不支持Obj)，targetOrigin是限定消息接受范围，不限制就用星号 * 接受信息的message事件 12345678910var onmessage = function(event) &#123; var data = event.data; var origin = event.origin;&#125;if(typeof window.addEventListener != &apos;undefined&apos;)&#123; window.addEventListener(&apos;message&apos;,onmessage,false);&#125;else if(typeof window.attachEvent != &apos;undefined&apos;)&#123; window.attachEvent(&apos;onmessage&apos;, onmessage);&#125; 举个栗子 a.html(http://www.nealyang.cn/a.html) 12345678910111213141516&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.neal.cn/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); iframe.onload = function() &#123; var data = &#123; name: &apos;aym&apos; &#125;; // 向neal传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.neal.cn&apos;); &#125;; // 接受domain2返回数据 window.addEventListener(&apos;message&apos;, function(e) &#123; alert(&apos;data from neal ---&gt; &apos; + e.data); &#125;, false);&lt;/script&gt; b.html(http://www.neal.cn/b.html) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener(&apos;message&apos;, function(e) &#123; alert(&apos;data from nealyang ---&gt; &apos; + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回nealyang window.parent.postMessage(JSON.stringify(data), &apos;http://www.nealyang.cn&apos;); &#125; &#125;, false);&lt;/script&gt; 跨域资源共享 CORS因为是目前主流的跨域解决方案。所以这里多介绍点。 简介CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 两种请求说起来很搞笑，分为两种请求，一种是简单请求，另一种是非简单请求。只要满足下面条件就是简单请求 请求方式为HEAD、POST 或者 GET http头信息不超出一下字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type(限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain) 为什么要分为简单请求和非简单请求，因为浏览器对这两种请求方式的处理方式是不同的。 简单请求基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 1234567GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。 浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。 注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头 Access-Control-Allow-Origin :该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求 Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Expose-Headers:该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 另一方面，开发者必须在AJAX请求中打开withCredentials属性。 123456789101112131415161718192021222324var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open(&apos;post&apos;, &apos;http://www.domain2.com:8080/login&apos;, true);xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);xhr.send(&apos;user=admin&apos;);xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;;// jquery$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 12345var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send(); 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 12345678 OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 服务器回应的其他CORS相关字段如下： 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 Access-Control-Allow-Methods：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers：如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Allow-Credentials： 该字段与简单请求时的含义相同。 Access-Control-Max-Age： 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 浏览器正常请求回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 浏览器的正常CORS请求。上面头信息的Origin字段是浏览器自动添加的。下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin字段是每次回应都必定包含的 结束语CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 前端代码： 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var socket = io(&apos;http://www.domain2.com:8080&apos;);// 连接成功处理socket.on(&apos;connect&apos;, function() &#123; // 监听服务端消息 socket.on(&apos;message&apos;, function(msg) &#123; console.log(&apos;data from server: ---&gt; &apos; + msg); &#125;); // 监听服务端关闭 socket.on(&apos;disconnect&apos;, function() &#123; console.log(&apos;Server socket has closed.&apos;); &#125;);&#125;);document.getElementsByTagName(&apos;input&apos;)[0].onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; node Server 123456789101112131415161718192021222324252627var http = require(&apos;http&apos;);var socket = require(&apos;socket.io&apos;);// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;text/html&apos; &#125;); res.end();&#125;);server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;);// 监听socket连接socket.listen(server).on(&apos;connection&apos;, function(client) &#123; // 接收信息 client.on(&apos;message&apos;, function(msg) &#123; client.send(&apos;hello：&apos; + msg); console.log(&apos;data from client: ---&gt; &apos; + msg); &#125;); // 断开处理 client.on(&apos;disconnect&apos;, function() &#123; console.log(&apos;Client socket has closed.&apos;); &#125;);&#125;); node代理跨域node中间件实现跨域代理，是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 利用node + express + http-proxy-middleware搭建一个proxy服务器 前端代码 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:3000/login?user=admin&apos;, true);xhr.send(); 后端代码 123456789101112131415161718192021var express = require(&apos;express&apos;);var proxy = require(&apos;http-proxy-middleware&apos;);var app = express();app.use(&apos;/&apos;, proxy(&#123; // 代理跨域目标接口 target: &apos;http://www.domain2.com:8080&apos;, changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) &#123; res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://www.domain1.com&apos;); res.header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;); &#125;, // 修改响应信息中的cookie域名 cookieDomainRewrite: &apos;www.domain1.com&apos; // 可以为false，表示不修改&#125;));app.listen(3000);console.log(&apos;Proxy server is listen at port 3000...&apos;); nginx代理跨域NGINX其实个人没有怎么玩过，所以暂且也就不能误人子弟了，原谅笔者才疏尚浅~ 有机会学习研究再回来补充~~]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>编程</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js表单]]></title>
    <url>%2F2017%2F09%2F22%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%EF%BC%9A%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%20JavaScript%20%E8%A1%A8%E6%A0%BC%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前端开发：非常好用的 JavaScript 表格控件此文为大家整理出几款非常好用的JavaScript 表格控件分享给大家，希望对大家有所帮助！ 1.Handsontable（用纯JavaScript，也可与 AngularJS指令 和聚合物组成。） 2.JsGrid（基于jQuery的轻量级客户端数据网格控件。它支持基本的网格操作，如插入、过滤、编辑、删除、分页和排序。jsgrid是灵活的，允许自定义其外观和部件。） 3.FancyGrid（一个插件的免费图书馆，它没有依赖但jQuery和AngularJS集成。fancygrid还包括样品数量、专业支持、优雅的API，当然详细的文件，方便使用。） 4.jqGrid（是一个支持Ajax的JavaScript控件，它提供了在Web上表示和操作表格数据的解决方案。） 5.W2ui（图书馆一体化解决方案。它包含所有最常见的UI小部件：布局、网格、边栏、制表符、工具栏、弹出框、字段控件和窗体。你不需要拼凑一个不匹配的插件来完成你的目标。） 6.dhtmlxGrid（一个功能全面的JavaScript网格控件，它提供了尖端的功能、强大的数据绑定和大数据集的快速性能。丰富而直观的JavaScript API使网格具有高度的可定制性和易用性。） 7.jQWidgets（是一个专业的触摸功能完整的框架使jQuery插件、主题、输入验证、拖放插件，数据适配器，内置WAI-ARIA可达性、国际化和MVVM支持。）]]></content>
      <categories>
        <category>前端, css, 编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读源码]]></title>
    <url>%2F2017%2F09%2F18%2F%E8%AF%BB%E6%87%82%E6%BA%90%E7%A0%81%EF%BC%9A%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20Vue%2F</url>
    <content type="text"><![CDATA[读懂源码：一步一步实现一个 Vue源码阅读：究竟怎样才算是读懂了？ 市面上有很多源码分析的文章，就我看到的而言，基本的套路就是梳理流程，讲一讲每个模块的功能，整篇文章有一大半都是直接挂源码。我不禁怀疑，作者真的看懂了吗？为什么我看完后还是什么都不懂呢？ 事实上一个经过无数次版本迭代的框架源码并不适合初学者直接阅读，因为里面有太多细节，太多噪点，太多枝枝蔓蔓。要想真正理解框架的核心逻辑，必须剥茧抽丝，还原出一个纯净的雏形。如同 jQuery 最早的版本只有六百多行，我相信 Vue 的核心功能也只需要几百行就能实现。所以，读懂源码的标志就是还原，码越薄，真相就越清晰。 如何还原雏形？ 一开始我设想的还原过程就是先删后拆。什么报错信息、参数校验、非核心功能全部砍掉，八千行变成了五千行。然后再拆，按功能模块将一个 Vue.js 拆分成 util.js, observer.js, watcher.js … 理想状态下，我应该能够理解源码了吧，可做完解剖手术后，我发现里面的逻辑依然纷繁复杂，剪不断，理还乱，草蛇灰线，伏脉千里，即便换了一个更早期更简短的版本，仍然很快又陷入了永无止境的细节中。 最终我得出结论：与其根据源码还原雏形，不如参考源码自己从头实现一个雏形。 定义核心 Version：2.0.4 只考虑 runtime 版本，不考虑模板编译，不考虑服务端渲染。 核心功能：响应式的数据绑定、虚拟 DOM、diff 算法、patch 方法（用于更新真实 DOM） 如果你对上述基础概念完全不熟，建议先积累一些背景知识：关于响应式绑定参考这篇文章，关于 virtual dom 和 diff 算法参考这个视频。当然，这些并不是必须的。 目标 事实上，Vue-cli 生成的项目中， 标签中的内容都会被编译为 render 函数，render 函数返回整棵虚拟节点树。我们最终要实现一个 Vue，来完成上面的示例。 当 new Vue() 的时候发生了什么？ 我们的实现会参考源码的套路，但会大量的简化其中的细节。为了理解源码的结构，最好的突破口就是了解程序的起点 new Vue() 的背后究竟发生了什么。 简单梳理下源码的执行流： =&gt; 初始化生命周期 =&gt; 初始化事件系统 =&gt; 初始化state，依次处理 props、data、computed … =&gt; 开始渲染 _mount() =&gt; _render() 返回 vdom=&gt; _update() =&gt; patch() 更新真实DOM 更详细的说明可以参考这篇文章，我们只会实现其中最核心的部分 第一步：将虚拟 DOM 树渲染到真实的 DOM 每一个 DOM 节点都是一个 node 对象，这个对象含有大量的属性与方法，虚拟 DOM 其实就是超轻量版的 node 对象。 我们要生成的 DOM 树看上去是这样的： 关于 data 参数的属性，请参考官方文档 随后我们会通过 createElm 方法和 createChildren 方法的相互调用，遍历整棵虚拟节点树，生成真实的 DOM 节点树，最后替换到挂载点。 完整代码 第二步：修改数据，执行 diff 算法，并将变化的部分 patch 到真实 DOM diff 算法的逻辑比较复杂，可以单独摘出来研究，由于我们的目的是理解框架的核心逻辑，因此代码实现里只考虑了最简单的情形。 完整代码 第三步：对数据做响应式处理，当数据变化时，自动执行更新方法 data 中的每一个属性都会被处理为存取器属性，同时每一个属性都会在闭包中维护一个属于自己的 dep 对象，用于存放该属性的依赖项。当属性被赋予新的值时，就会触发 set 方法，并通知所有依赖项进行更新。 完整代码 Vue 渐进式的特点，使其上手极其容易，我相信，渐进式的展现框架逻辑的实现过程，也会使理解变得更容]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>js</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows优化]]></title>
    <url>%2F2017%2F09%2F16%2Fwindows10%E5%8D%87%E7%BA%A7%E5%90%8E%E5%BF%85%E5%81%9A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[windows10 升级后必做优化标签：windows ,优化,系统 windows10 升级后必做优化1.需要关闭的服务 HomeGroupListener（家庭组服务） HomeGroupProvider（家庭组服务） ip helper(ipv6 服务) Computer Browser(默认手动) 可以被网络和共享中心的网络发现功能取代，设置为手动 Distributed Link Tracking Client 个人用户一般用不到，设置为手动 Distributed Transaction Coordinator(默认手动) 个人用户一般用不到，也容易受到远程拒绝服务攻击，设置为手动 Remote Registry 这个服务是必停的服务之一，设置为禁用 Secondary Logon(默认手动) 对于多用户，可以给某用户分配临时的管理员权限，一般不会用到，设置为手动 Superfetch I/O 操作频繁的功能，如果不需要这个功能，设置为禁用 TCP/IP NetBIOS Helper 如果网络不使用 NetBIOS 或是 WINS，设置为手动 Windows Defender Service I/O 操作频繁的功能，如果不需要这个功能，设置为禁用 Windows Search I/O 操作频繁的功能，如果不需要这个功能，设置为禁用 Security Center Windows 安全中心服务，可以禁用 Distributed Link Tracking Client: 这个功能一般都用不上，完全可以放心禁用。 Fax 利用计算机或网络上的可用传真资源发送和接收传真。不用我说了吧，很明显就能看出来是和传真有关的。手动或禁用 Windows Backup 提供 Windows 备份和还原功能。Windows 备份和版本恢复功能，一直都不好使，可以关掉 Windows Error Reporting Service 没人喜欢错误，对你和微软而言，错误报告传送过去都没什么用。关了它。 下面演示如何关闭服务： 按 win+r 按键-&gt;出现运行窗口-&gt;输入 cmd-&gt;回车-&gt;输入 services.msc-&gt;回车 输入 services.msc 找到所示的服务-&gt;右键属性 选择禁用后确定 2.关闭 Internet 协议 6 TCP/IPv6 :网络-&gt;属性-&gt;适配器配置-&gt;选择你使用的适配器-&gt;属性-&gt;勾选掉 ipv6-&gt;保存**** 最后确定保存 3.清理产生的 Windows.old 文件夹（针对直接升级的系统）操作方法：进入我的电脑 -&gt;c 盘-&gt;磁盘清理-&gt;系统文件清理 确定后会自动清理]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>优化</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端中的居中（八种方法）]]></title>
    <url>%2F2017%2F09%2F13%2Fweb%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E5%B1%85%E4%B8%AD%EF%BC%88%E5%85%AB%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[web前端中的居中（八种方法）一、水平居中（后续总结所有垂直居中方法，好像也是八种） 若是行内元素, 给其父元素设置 text-align:center,即可实现行内元素水平居中. 若是块级元素, 该元素设置 margin:0 auto即可. 若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置: fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器. 4.使用flex 2012年版本布局, 可以轻松的实现水平居中, 子元素设置如下: 5.使用flex 2009年版本, 父元素display: box;box-pack: center;如下设置: 6.使用CSS3中新增的transform属性, 子元素设置如下: 7.使用绝对定位方式, 以及负值的margin-left, 子元素设置如下: 8.使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下: Firefox Chrome]]></content>
      <categories>
        <category>前端, 编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>优化</tag>
        <tag>编程</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端—css面试题]]></title>
    <url>%2F2017%2F09%2F11%2F%E5%89%8D%E7%AB%AF%E2%80%94css%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前端—css面试题小海dedede 2017-03-17 16:31:18 1、CSS 选择符有哪些？ 2、CSS 优先级的选择过程？ 优先级复合就近原则，同权重的情况下有限选择最近的属性。 载入样式的话是以最后载入的定位为准。 优先级： !important &gt; id &gt; class &gt; tag（important要优先于内联样式） 3、阐述一下CSS3的新增伪类。 4、如何居中 div？如何居中一个浮动元素？如何让绝对定位的div居中？ div居中：给div一个宽度，然后添加margin: 0 auto;属性即可。 浮动元素居中： 绝对定位的div居中： 5、属性display 有哪些值？说明他们的作用。 6、position 的值 relative 和 absolute 定位原理？ 7、用纯CSS 创建一个三角形的过程？ 8、li 与 li 之间有看不见的空白间隔如何形成的？相应的解决办法？ 9、为什么要初始化CSS样式？ 因为浏览器的兼容性问题，不同的浏览器对某些标签有自己的默认值，如果没有实现css的初始化，也就是没有解决浏览器的兼容性问题，那么会造成页面在不同浏览器下显示差异的问题。 10、CSS3 有哪些新特性？ CSS 科技]]></content>
      <categories>
        <category>面试</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>编程</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题解决]]></title>
    <url>%2F2017%2F09%2F11%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82api%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前端跨域请求api的几种常用解决方案简单印象 2017-11-30 07:56:01 总结一下，前端跨域请求后端api的几种常用方法： 1.iframe 随着近年来前端技术的飞跃发展以及移动互联网时代的洗礼，iframe的使用渐渐的不被建议，虽然也是一种跨域请求的解决方案，但这里就不再讲述，请读者自行查阅网上资料。 2.jsonp jsonp是比较常用的方法，我们假设a.com域名需要向b.com发起一个api请求（jsonp的一个缺点是，仅能接受GET方式），则使用JSONP完成该过程的实例可以这样： a.com/jsonp.html b.com/jsonp.php 3. 通过请求同域下的api，间接获取它域的数据 我们仍以域名a.com/demo.html需获取b.com下的数据为例，这时候只要在a.com下创建一个demo.php，由demo.php通过curl的方式向b.com发起数据请求，并包装请求结果返回给a.com/demo.html页面。这里主要是通过与a.com/demo.html同域下的a.com/demo.php做了一层数据请求代理，避免了前端跨域请求。 4.使用web服务器的反向代理设置 同样是使用代理的思维，但与2不同的是，我们这里使用web服务器的反向代理配置： Nginx反向代理可以使用 proxy_pass Apache2的反向代理的配置可以使用ProxyPass 5.设置header头（CORS） 在你要跨域请求的api里，设置header头Access-Control-Allow-Origin: *，以php为例，在api代码的入口方法处加入如下一行：]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端—css面试题]]></title>
    <url>%2F2017%2F09%2F11%2F%E5%89%8D%E7%AB%AFHR%E7%86%AC%E5%A4%9C%E6%95%B4%E7%90%86%EF%BC%8C2017%E5%B9%B4BAT%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E9%9B%86%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%B6%E8%97%8F%E4%BA%86%EF%BC%8C%E5%8F%AA%E5%8F%91%E4%B8%80%E6%AC%A1%EF%BC%81%2F</url>
    <content type="text"><![CDATA[标签： 编程 前端HR熬夜整理，2017年BAT面试题大全集，程序员收藏了，只发一次！ 2016年BAT公司常见的Web前端面试题整理这篇文章分享之前我还是要推荐下我自己的前端群：595549645，不管你是小白还是大牛，小编我都挺欢迎，不定期分享干货，包括我自己整理的一份2017最新的前端资料和零基础入门教程，欢迎初学和进阶中的小伙伴。 1.JavaScript是一门什么样的语言，它有哪些特点？ 没有标准答案。 2.JavaScript的数据类型都有什么？ 基本数据类型：String,boolean,Number,Undefined 引用数据类型：Object(Array,Date,RegExp,Function,Null) 那么问题来了，如何判断某变量是否为数组数据类型？ 方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效 方法二.obj instanceof Array 在某些IE版本中不正确 方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下： 3.已知ID的Input输入框，希望改变文本框的背景颜色，怎么做？(原生JS) 4.希望获取到页面中所有的checkbox怎么做？(原生JS) 5.Html事件绑定有几种方式？ 直接在DOM里绑定事件： 这种方式称为原生事件或者属性事件 在JS里通过onclick绑定：xxx.onclick = test Dom标准通过事件添加进行绑定：addEventListener(“click”,test, false) //第三个参数为是否支持事件捕捉 IE事件：attachEvent(“onclick”,test) 那么问题来了，Javascript的事件流模型都有什么？ “事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的 目标事件 “事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播 “DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡 IE事件流：目标事件和事件冒泡 阻止事件冒泡的方式： 阻止事件的默认行为： 6.看下列代码，将会输出什么?(变量声明提升) 上面的代码经过变量提升后，等价于下面的代码 再看下面的输出结果： 此时打印a函数，不会打印1，因为下面是一个函数表达式，跟变量声明一样，只会把var a;提升到最前面，a=function(){}保留，会覆盖前面的a=1;因此打印函数。 此题目，我再百度面试的时候问到过。 7.掌握样式的优先级。 !important &gt; style(内联) &gt; Id(权重100) &gt; class(权重10) &gt; 标签（权重1） 同类别的样式，后面的会覆盖前面的。 百度视频部门一道面试题是这样的： 8.怎样添加、移除、移动、复制、创建和查找节点 1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 9.用js写一个正则匹配标签中是否包含一个class(百度面试题) 10.事件循环绑定，输出结果（考察闭包） 通过闭包封装后的代码： 闭包我所知道的两个作用： a.通过闭包可以把局部变量传递出来，就是通过闭包可以访问函数内部的变量，比如下面的代码： 通过闭包就可以访问函数内部的局部变量，并且实现数量累加。 b.使用闭包可以避免空间污染，闭包内部的变量都只能在内部使用，这样有效避免和外部变量的混淆。（个人理解） 11.js数组去重。 12.两个div标签，如何控制标签左边固定，右边自适应，左边div标签的宽度为100px（滴滴面试题） 滴滴面试起初问我，现在有并排的三个Div框，如何实现三个div都自适应，我当时就懵了，这个考察的是display:table的使用 13.实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制 考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚 考察点2：是否知道如何判断一个变量是什么类型的 考察点3：递归算法的设计 14.继承的使用 15.请评价以下代码并给出改进意见 评价： 不应该在if和else语句中声明addListener函数，应该提前先声明，定义全局变量； 不需要使用window.addEventListener或document.all来进行检测浏览器，应该使用能力检测； 由于attachEvent在IE中有this指向问题，所以调用它时需要处理一下 改进如下： 16.对作用域上下文和this的理解，看下列代码： 这个文章到这里就说完了，想要前端学习资料的进我的群自助领取，已经上传到群文件里了：595549645，欢迎初学和进阶中的小伙伴。]]></content>
      <categories>
        <category>前端,css,编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做新媒体必备的43款工具，速来围观！]]></title>
    <url>%2F2017%2F08%2F25%2F%E5%81%9A%E6%96%B0%E5%AA%92%E4%BD%93%E5%BF%85%E5%A4%87%E7%9A%8443%E6%AC%BE%E5%B7%A5%E5%85%B7%EF%BC%8C%E9%80%9F%E6%9D%A5%E5%9B%B4%E8%A7%82%EF%BC%81%2F</url>
    <content type="text"><![CDATA[做新媒体必备的43款工具，速来围观！篱笆屋里的程序媛 2017-08-15 13:13:50 放一张我珍藏已久的优秀运营者必备工具图，做运营的人可以先存起来哦！ 1、文档写作与协作工具。 石墨文档 石墨 - 可多人实时协作的云端文档与表格 WPS文档 WPS云文档 协作在云端 Tower 你的网上办公室 - Tower 2、思维导图工具Xmind XMind: The Most Popular Mind Mapping Software on The Planet. 百度脑图。 百度脑图 - 便捷的思维工具 3、新媒体排行以及素材整理工具新榜 新榜–内容创业服务平台 清博指数 首页 - 清博指数 搜狗微信搜索 搜狗微信搜索_订阅号及文章内容独家收录，一搜即达 微小宝 超好用的微信编辑器、多账号管理和微信爆文神器，百万公众号首选 - 微小宝公众号助手_微小宝 西瓜公众号助手 西瓜助手 - 让公众号运营更简单 4、文章排版工具135编辑器 135微信编辑器，微信排版,图文排版,一键秒刷,公众号编辑器,排版编辑器，文章排版，内容编辑器，在线使用无需下载。135编辑器，从1开始，做更好 i排版 微信编辑器i排版微信排版微信图文编辑器公众号编辑_微信排版工具 秀米 关注秀米 - 秀米 XIUMI 新媒体管家 新媒体管家 - 首页 壹伴 壹伴 - 简单好用的公众号效率工具 5、制图与修图工具创客贴 创客贴在线平面设计工具海量平面设计素材免费使用 美图秀秀 美图秀秀网页版 官方网站_在线制作图片及图片处理工具 光影魔术手 光影魔术手官方网站–功能强大、好用的图片处理软件，最新版免费下载 6、HTML5制作工具易企秀 h5页面制作工具微信场景制作移动营销_邀请函模板-易企秀官网 iH5 iH5最专业的H5制作工具 MAKA MAKA官网免费H5页面制作工具微场景_移动营销_h5论坛 7、图像截取工具Snipaste Snipaste FastStone Capture FastStone Capture 8、二维码制作工具草料二维码 草料二维码生成器 第九工厂 第九工场 - 首页 9、GIF制作工具GifCam GifCam 10、短连接生成工具百度短网址 百度短网址 新浪短网址 新浪短网址 短网址生成 网址缩短服务 - 短网址 11、语音转文字工具讯飞听见 讯飞听见 - 高效,准确的语音转写服务平台 12、数据统计工具考拉新媒助手 考拉新媒体助手 侯斯特 侯斯特微信公众号CRM系统 友盟+ 【友盟+】全球领先的第三方全域数据服务商 百度指数 百度指数 13、社群管理工具小U管家 【小U管家】-社群管家|社群空间|专业微信群管理服务机器人 孤鹿Group+ 活动行 14、内容沉淀工具麦克CRM 首页 | 麦客CRM 金数据 金数据 - 人人可用的在线表单工具 表单大师 帮BOSS|表单大师–简单好用的数据收集、管理和分析平台 腾讯问卷 腾讯问卷 - 免费好用的问卷调查系统,调查问卷,免费,简单,模板 今天的分享就到这里啦，喜欢就点赞、收藏、关注吧！]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[偏门却又实用的 CSS 样式]]></title>
    <url>%2F2017%2F08%2F16%2F%E5%81%8F%E9%97%A8%E5%8D%B4%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%20CSS%20%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[偏门却又实用的 CSS 样式很早之前我们推荐大家看《推荐大家使用的CSS书写规范、顺序》，里面提到 CSS 的一些常用命名、规范等等，而今天主要是说一些偏门一点的 CSS 样式、技巧。 什么是偏门，就是有些片段很少使用，时间久了就记不起来，但用的时候又要去找，所以这里为大家整理一些少用但又实用的 CSS 样式， 部分由小编及网友提供，感谢你们~ 持续更新哦。 ::-Webkit-Input-Placeholder input 的 H5 placeholder 属性，很好用，但不能直接改这个文字颜色，所以目前的解决方法就是用::input-placeholder属性来改。 小Tips: 配合 opacity 属性使用效果更佳哦！ 1::-webkit-input-placeholder &#123; /* Chrome/Opera/Safari */color: pink;&#125;::-moz-placeholder &#123; /* Firefox 19+ */color: pink;&#125;:-ms-input-placeholder &#123; /* IE 10+ */color: pink;&#125;:-moz-placeholder &#123; /* Firefox 18- */color: pink;&#125; @Impor 嵌套样式表文件 使用它可以在样式表再次内嵌套样式表文件，比如一些组件 CSS可以使用，但不太推荐使用这个，因为加载时有可能会被漏掉。 1@import url("reset.css");@import url("global.css"); @import url("font.css"); Outline 当点击Input元素时显示的当前状态线（外发光） 这个状态线是用来提示用户当前状态指示作用，但因为效果很美观，建议去掉，或自己改个样式 1div &#123;outline: none; //移动浏览器默认的状态线// outline: 5px dotted red; 也可以设置样式&#125; Contenteditable 设置Element是否可编辑 1&lt;p contenteditable="true"&gt;可编辑&lt;/p&gt; Webkit-Playsinline 手机video 都可以在页面中播放，而不是全屏播放了。tml 1234567Position: Absolute， 让Margin有效的设置left:0, right:0 就可以。原因是2边都是0不存在边距，element就可以得出距离，并居中。```cssdiv &#123;position: absolute;left: 0;right: 0;margin: 0 auto;&#125; 使用 Clearfix 清楚浮动，解决父类高度崩塌。 1.clearfix &#123;zoom: 1;&#125;.clearfix:after &#123;visibility: hidden;display: block;font-size: 0;content: " ";clear: both;height: 0;&#125; User-Select 禁止用户选中文本 1div &#123;user-select: none; /* Standard syntax */&#125; 清除手机Tap事件后Element 时候出现的一个高亮 1*&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125; ::-Webkit-Scrollbar-Thumb 可以修改谷歌的滚动条样式，safari好像也可以 -Webkit-Appearance:none To apply platform specific styling to an element that doesn’t have it by default To remove platform specific styling to an element that does have it by default 移除浏览器默认的样式，比如chrome的input默认样式 1input, button, textarea, select &#123;*font-size: 100%;-webkit-appearance:none;&#125; CSS开启硬件加速 http://www.cnblogs.com/rubylouvre/p/3471490.html 1-webkit-transform: translateZ(0); 使用CSS Transforms 或者 Animations时可能会有页面闪烁的Bug 1-webkit-backface-visibility: hidden; -Webkit-Touch-Callout 禁止长按链接与图片弹出菜单 1-webkit-touch-callout: none; Transform-Style: Preserve-3d 让元素支持3d 1div &#123;-webkit-transform: rotateY(60deg); /* Chrome, Safari, Opera */-webkit-transform-style: preserve-3d; /* Chrome, Safari, Opera */transform: rotateY(60deg);transform-style: preserve-3d;&#125; Perspective 透视 这个属性的存在决定你看到的元素是2d还是3d。一般设置在包裹元素的父类上。 1.div-box &#123;perspective: 400px;&#125; Css实现不换行、自动换行、强制换行 1//不换行white-space:nowrap;//自动换行word-wrap: break-word;word-break: normal;//强制换行word-break:break-all; Box-Sizing 让元素的宽度、高度包含Border和Padding 1&#123;box-sizing: border-box;&#125; Calc() Function, 计算属性值 https://www.w3schools.com/cssref/func_calc.asp 1div &#123;width: calc(100% - 100px);&#125; 上面的例子就是让宽度为100%减去100px的值，项目中很适用，要IE9以上兼容。 Css3 Linear-Gradient 线性渐变 默认开始在top, 也可以自定义方向。 1div &#123;linear-gradient(red, yellow)&#125;background: linear-gradient(direction, color-stop1, color-stop2, ...); 常用的选择器 :Nth-Child() Selector 以下代码是选择父类下第一个子节点，p元素，建议学习这个样式属性的使用，很实用的。 1p:nth-child(1) &#123;...&#125; 就介绍到这里，以后会不断更新，如果有好的 CSS 代码，欢迎在留言处提交给我们，一起收录进来！]]></content>
      <categories>
        <category>前端, css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA配置]]></title>
    <url>%2F2017%2F07%2F30%2FJAVA%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[标签： 插件 # java环境 (1)新建-&gt;变量名123456变量值```S:\Java\jdk1.8.0_152```（即JDK的安装路径） (2)编辑-&gt;变量名&quot;Path&quot;，在原变量值的最后面加上```;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin (3)新建-&gt;变量名“CLASSPATH”,变量值“ .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Config</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I love you but just love you(纵然万劫不复,纵然相思入骨,我也待你眉眼如初,岁月如故)]]></title>
    <url>%2F2017%2F07%2F07%2F%E6%84%BF%E4%BD%A0%E8%83%BD%E9%81%87%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BA%BA%EF%BC%8C%E5%AF%B9%E4%BD%A0%E8%AF%B4%E8%BF%9920%E5%8F%A5%E6%83%85%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[愿你能遇到一个人，对你说这20句情话1你好能不能借一生说话2承蒙你出现够我欢喜好多年3第一次见到你我就知道我栽了4白茶清欢无别事我在等风也等你5海底月是天上月眼前人是心上人6从遇见你的那天起我就没想过要分开7你是我执着的理由也是我疯狂的借口8为了遇见你竟花光了我所有的运气9好像突然有了铠甲也突然有了软肋10说不清为什么爱你但你就是我不爱别人的理由11你不用分清东南西北只需要走向有我的方向12我用尽所有套路只为了撩到你13离开你是怕有一天真的爱上你14我一点都不遗憾没有在最好的时光遇见你因为遇见你之后最好的时光才开始15恋爱这个东西对方是你才有趣16我能对你做的最好的事就是让你知道世界虽然坏你却被爱着17虽然我不怎么会谈情也不怎么会说爱但是我想和你在一起一辈子18从小就听过冰山坚不可摧可谁知道冰山也有想在某个人手里变成冰淇淋的一天19喜欢你这件事从一而终认真且怂爱你的时间不长一生为期20遇见你之前我没有想过结婚*遇见你之后结婚我没想过别人]]></content>
      <categories>
        <category>爱情句子</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>句子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA配置git]]></title>
    <url>%2F2017%2F06%2F30%2FIDEA%E9%85%8D%E7%BD%AEgit%2F</url>
    <content type="text"><![CDATA[标签： 插件 github要想使用idea自带的版本控制系统,首先自己的电脑上得有git安装一个Git,不会的看阮一峰的git教程!https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/ 先加入自己git账户由于idea自带vcs,所以使用git更加方便,只需要先在settings下填入自己账户可以用密码验证,也可以用自己在github生成的token(得有github账户,如果看过阮一峰的git教程就知道了)点击test 测试成功就说明已经添加上了. 新建一个java工程(不用多说)建好之后在菜单栏上VCS&gt;import into version control&gt;share project on github成功后菜单栏的vcs的内容变化了在这里有git 的各种操作,比如commit` update branchmerge等,做了更改后直接commit然后push到git上面即可, ![](https://i.imgur.com/NfxPyWo.png) 右边那一堆是对将要上传的代码的操作,格式化啊,优化导入的包,分析代码质量,检查todos等等,我们点击右下角的commit and push`就上传到了git上,之后的操作,相信大家看了阮一峰的教程应该知道. gitlab既然可以用github 那么gitlab也是可以的 安装gitlab插件注册并添加gitlab账户(同github)有一个token需要注意 新建工程初始化gitlabVCS&gt;import into version control&gt;share project on gitlab这里我们使用ssh或者http都行 gitee Git Flow Integrationgit 的图形界面操作点击IDEA右下角的No flow初始化一下 成功时候gitflow会自动给你创建四个分支，分别如下feature/release/hotfix/support/]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Config</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常用代码合计]]></title>
    <url>%2F2017%2F06%2F18%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[前端常用代码合集1.使用FileReader实现前端图片预览 1&lt;input type="file"&gt;&lt;br&gt;&lt;img src="" height="200" alt="Image preview area..." title="preview-img"&gt; var fileInput = document.querySelector(‘input[type=file]’); var previewImg = document.querySelector(‘img’); fileInput.addEventListener(‘change’, function () { var file = this.files[0]; var reader = new FileReader(); reader.addEventListener(‘load’, function () { previewImg.src = reader.result; }, false); reader.readAsDataURL(file); }, false); 2.取到页面中所有的checkbox怎么做？(不使用第三方框架) var doc = document, domList = doc.getElementsByTagName(‘input’), checkBoxList = [], len = domList.length; while (len–) { if (domList[len].type === ‘checkbox’) { checkBoxList.push(domList[len]); } } 3.JavaScript模版引擎小实例 前端常用代码合计 数据: var data = [ { title: “”, href: “”, imgSrc: “” }, … ]; 方法一： var doc = document, template = doc.querySelector(‘#template’).innerHTML, result = doc.querySelector(‘.result’), fragment = ‘’; for (var i = 0, len = data.length; i &lt; len; i++) { fragment += template .replace(/前端常用代码合计/, data[i].title) .replace(//, data[i].href) .replace(//, data[i].imgSrc) } result.innerHTML = fragment; 方法二： var doc = document, template = doc.querySelector(‘#template’).innerHTML, result = doc.querySelector(‘.result’), attachTemplateToData; attachTemplateToData = function (template, data) { var i = 0, len = data.length, fragment = ‘’; function replace(obj) { var t, key, reg; for (key in obj) { reg = new RegExp(‘ + key + ‘, ‘ig’); t = (t || template).replace(reg, obj[key]); } return t; } for (; i &lt; len; i++) { fragment += replace(data[i]); } return fragment; }; result.innerHTML = attachTemplateToData(template, data); 4.实现JS函数重载 var people = { values: [“Dean Edwards”, “Sam Stephenson”, “Alex Russell”, “Dean Tom”] }; function addMethod(object, name, fn) { var old = object[name]; object[name] = function () { if (fn.length === arguments.length) { return fn.apply(this, arguments); } else if (typeof old === ‘function’) { return old.apply(this, arguments); } } } addMethod(people, “find”, function () { return this.values; }); addMethod(people, “find”, function (firstName) { var ret = []; for (var i = 0; i &lt; this.values.length; i++) { if (this.values[i].indexOf(firstName) === 0) { ret.push(this.values[i]); } } return ret; }); addMethod(people, “find”, function (firstName, lastName) { var ret = []; for (var i = 0; i &lt; this.values.length; i++) { if (this.values[i] === (firstName + ‘ ‘ + lastName)) { ret.push(this.values[i]); } } return ret; }); console.log(people.find()); console.log(people.find(“Sam”)); console.log(people.find(“Dean Edwards”)); 5.JS跨浏览器绑定事件函数 常规实现方法: //跨浏览器添加事件 function addHandler(target, eventType, handler) { //检测浏览器类型，并且重写addHandler方法 if (target.addEventListener) { addHandler = function (target, eventType, handler) { target.addEventListener(eventType, handler, false); } } else { //IE addHandler = function (target, eventType, handler) { target.attachEvent(“on” + eventType, handler); } } //调用新的函数 addHandler(target, eventType, handler); } //跨浏览器移除事件 function removeHandler(target, eventType, handler) { //检测浏览器类型，并且重写addHandler方法 if (target.addEventListener) { removeHandler = function (target, eventType, handler) { target.removeEventListener(eventType, handler, false); } } else { //IE removeHandler = function (target, eventType, handler) { target.detachEvent(“on”, eventType, handler); } } target.detachEvent(“on” + eventType, handler); } 优化方法: //绑定事件 var addHandler = document.body.addEventListener ? function (target, eventType, handler) {//DOM2 target.addEventListener(eventType, handler, false); } : function (target, eventType, handler) {//IE target.attachEvent(“on” + eventType, handler); }; //移除事件 var removeHandler = document.body.removeEventListener ? function (target, eventType, handler) { target.removeEventListener(eventType, handler, false); } : function (target, eventType, handler) { target.detachEvent(“on” + eventType, handler); }; 6.JS单体模式 var shoppingCar = (function () { //这个是由购物车构造器所创建的实例 var instance; //购物车的构造器函数 function Trolley() { this.date = new Date().getDate();//实例属性，当前日期 } //原型属性，一个返回当前日期的方法 Trolley.prototype.getDate = function () { return this.date; }; //暴露出去的公共API return function () { //如果实例不存在，那么就调用Trolley构造器实例化一个 if (!instance) { instance = new Trolley(); } //将实例返回外部 return instance; } }()); var a = new shoppingCar(); var b = new shoppingCar(); console.log(a === b);//true 7.使用prototype属性定义的对象方法 var dom = function () {}; dom.Show = function () { alert(“Show Message”); }; dom.prototype.Display = function () { alert(“Property Message”); }; dom.Display(); //error dom.Show(); //Show Message var d = new dom(); d.Display(); //Property Message d.Show(); //error 1、不使用prototype属性定义的对象方法，是静态方法，只能直接用类名进行调用！另外，此静态方法中无法使用this变量来调用对象其他的属性！ 2、使用prototype属性定义的对象方法，是非静态方法，只有在实例化后才能使用！其方法内部可以this来引用对象自身中的其他属性！ 8.闭包实现结果缓存 var CachedSearchBox = (function () { var cache = {}, table = []; return { attachSearchBox: function (dsid) { if (dsid in cache) { //如果结果在缓存中 return cache[dsid]; //直接返回缓存中的对象 } var fsb = new uikit.webctrl.SearchBox(dsid);//新建 cache[dsid] = fsb;//更新缓存 if (count.length &gt; 100) { delete cache[shift()]; } return fsb; }, clearSearchBox: function (dsid) { if (dsid in cache) { cache[dsid].clearSelection(); } } } })(); CachedSearchBox.attachSearchBox(‘input’); 我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间， 那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。 9.闭包实现封装 var person = function () { var name = “Default”; return { getName: function () { return name; }, setName: function (newName) { name = newName; } } }(); console.log(person.name);//undefined console.log(person.getName());//Default person.setName(“GoodMan”); console.log(person.getName());//GoodMan 10.闭包实现类和继承 function Person() { var name = “default”; return { getName: function () { return name; }, setName: function (newName) { name = newName; } } } var p = new Person(); p.setName(‘Tom’); console.log(p.getName()); var Jack = function () { }; Jack.prototype = new Person();//继承自Person Jack.prototype.Say = function () { //添加私有方法 console.log(“Hello,my name is Jack”); }; var j = new Jack(); j.setName(“Jack”);//Tom j.Say();//Hello,my name is Jack console.log(j.getName());//Jack 11.如何判断某变量是否为数组数据类型 if (typeof Array.isArray === “undefined”) { Array.isArray = function (arg) { return Object.prototype.toString.call(arg) === “[object Array]” }; } 12.Javascript继承-借用构造函数 var Widget = function (name) { this.messages = []; }; Widget.prototype.type = ‘Widget’; var SubWidget = function (name) { Widget.apply(this, Array.prototype.slice.call(arguments)); this.name = name; }; SubWidget.prototype = Widget.prototype; var sub1 = new SubWidget(‘foo’); var sub2 = new SubWidget(‘bar’); sub1.messages.push(‘foo’); sub2.messages.push(‘bar’); console.log(sub1.messages);//foo console.log(sub2.messages);//bar 13.Javascript原型-封装 var Dialog = (function () { function Dialog() { } Dialog.prototype = { init: function () { console.log(“ok”); } }; return Dialog; }()); var d = new Dialog(); d.init();//ok 14.通过闭包修正函数的上下文（浏览器不支持解决方案） if (!(‘bind’ in Function.prototype)) { Function.prototype.bind = function () { var fn = this, context = arguments[0], args = Array.prototype.slice.call(arguments, 1); return function () { return fn.apply(context, args.concat(arguments)); } } } 15.优化JavaScript的构造函数(new关键字的使用) 方法一： function User(name, age) { if (typeof Object.create === ‘undefined’) { Object.create = function (prototype) { function C() { C.prototype = prototype; return new C(); } } } var self = this instanceof User ? this : Object.create(User.prototype); self.name = name; self.age = age; return self; } 方法二： function Programmer(name, company, expertise) { if (!(this instanceof Programmer)) { return new Programmer(name, company, expertise); } this.name = name; this.company = company; this.expertise = expertise; this.writeCode = function () { console.log(“Writing some public static thing..”) } } 16.柯里化 var curry = function (fn) { var limit = fn.length; return function judgeCurry(…args) { return function (…args) { if (args.length &gt;= limit) { return fn.apply(null, args); } else { return function (…args2) { return judgeCurry.apply(null, args.concat(args2)) } } } } }; var currySingle = fn =&gt; judgeCurry = (…args) =&gt; args.length &gt;= fn.length ? fn.apply(null, args) : (…args2) =&gt; judgeCurry.apply(null, args.concat(args2)); 17.对象拷贝与赋值 var obj = { name: ‘xiaoming’, age: 23 }; var newObj = obj; newObj.name = ‘xiaohua’; console.log(obj.name);//xiaohua console.log(newObj.name);//xiaohua 我们将obj对象赋值给了newObj对象，从而改变newObj的name属性，但是obj对象的name属性也被篡改，这是因为实际上newObj对象获得的只是一个内存地址，而不是真正的拷贝，所以obj对象被篡改。 var obj = { name: ‘xiaoming’, age: 23 }; var newObj = Object.assign({}, obj, {color: ‘blue’}); newObj.name = ‘xiaohua’; console.log(obj.name);//xiaoming console.log(newObj.name);//xiaohua console.log(newObj.color);//blue 18.拷贝 利用Object.assign()方法进行对象的深拷贝可以避免源对象被篡改的可能。因为Object.assign()方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 var obj = { name: ‘xiaoming’, age: 23 }; var newObj = Object.create(obj); newObj.name = ‘xiaohua’; console.log(obj.name);//xiaoming console.log(newObj.name);//xiaohua 我们也可以使用Object.create()方法进行对象的拷贝，Object.create()方法可以创建一个具有指定原型对象和属性的新对象。 19.设置等高的列 First LineSecond LineThird Line Column Two $(function () { equalHeight(“.equalHeight”); }); var maxHeight = 0; function equalHeight(col) { col = $(col); col.each(function () { if ($(this).height() &gt; maxHeight) { maxHeight = $(this).height() } }); col.height(maxHeight); }]]></content>
      <categories>
        <category>前端, css, 编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这75款动效工具让你无所不能]]></title>
    <url>%2F2017%2F06%2F17%2F%E5%81%9A%E5%8A%A8%E6%95%88%EF%BC%9F%E8%BF%9975%E6%AC%BE%E5%8A%A8%E6%95%88%E5%B7%A5%E5%85%B7%E8%AE%A9%E4%BD%A0%E6%97%A0%E6%89%80%E4%B8%8D%E8%83%BD%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[做动效？这75款动效工具让你无所不能（上）动效这两年崛起非常之迅猛，几乎是网页设计领域最强大的设计趋势之一。无论是在设计师群体还是在用户当中，它的受欢迎程度都非常之高，大家都对它津津乐道。 从微妙的转场动效到覆盖整个页面的大范围动效，它几乎无处不在。动效的运用让网页中的元素逻辑变化关系清晰地表述出来，还将影视化的体验引入了进来。 对于设计师而言，动效赋予了设计足够的可能性。无论是纯粹的装饰，还是简化界面，阐述逻辑，还是增加用户体验，动效都能帮到你。今天，我们要为你提供75个不同的动效设计工具，它们有的是插件，有的是代码库，合理的运用它们，能帮你搞定各式各样的动效。1. ANIMATE.CSS Animate.css 是一个跨浏览器的动效基础库，是许多基础动效的解决方案。从经典的弹跳动效到独特的扭曲动效，一应俱全。 2. MAGIC ANIMATIONS Magic Animations 专注于为网页带来独特的视觉效果。虽然其中涵盖的类型不够丰富，但是带来的体验足够优秀。 3. BOUNCE.JS 这是一个用来创造弹跳特效的库，它的动效主要是通过CSS3和一些预设来实现的。你可以通过 npm ，bower 来安装JS库，简单的复制生成的CSS3代码来应用动效。 4. ANIJS AnijS 让你能够通过 if、on、do、to 等简单的命令更加直观地处理动效。有趣的地方在于，它还能用来控制前面 Animate.css 来创造动效。 5. SNABBT.JS Snabbt.js 在创造动效这件事上，一直是以轻量和极简而著称的。它只有5kb 的大小，但是它能搞定平移、旋转、倾斜、缩放等常见的动效效果，非常高效。 6. KUTE.JS Kute.js 是一个纯粹的动效引擎，拥有出色的性能。它可以兼容许多不同的浏览器，包括一些相对传统的浏览器。它还具备许多插件，提供有效的运行环境。 7. VELOCITY.JS Velocity.js 也同样是一个动效引擎，乍一看可能没啥太过突出的地方，然而它囊括了绝大多数常见的动效，比如变形、循环、滚动等，它足够快速，且不依赖 jQuery。 8. LAZY LINE PAINTER 你可以使用 Lazy Line Painter 轻松创建 SVG 路径动效。你可以在AI中制作出SVG文档，上传到转换器中。后者会帮你将它处理成为动效，生成jQuery 文档。如有必要，你还可以编辑代码进行微调。 9. SVG.JS SVG.js 为你提供一个更加直观的编辑SVG动效的环境。它足够小巧，语法也简单，并且提供统一的API。 10. MOTION UI Motion UI 和前面的工具都不一样，它是借助SASS 来创建有趣的CSS动效。其中包含了一整套预定义的特效，可以运用到不同的HTML组件当中去。除了IE9，其他浏览器都可用。 11. WAIT! ANIMATE Wait! Animate让你可以以更加轻松自如的方式来创造延时和等待的动效。通过调整控制面板上的参数，你可以创造出更加自然的效果。 12. DYNAMICS.JS Dynamics.js 是一个JS库，能为你提供9种标准的动效，你可以制定其中的持续时间、频率、预期尺寸和强度等数据，创造出符合物理效果的动效。 13. CHOREOGRAPHER.JS 拥有了 Choreographer.js 之后你就不用再担心搞不定复杂的动效了，这个JS 库能够通过自定义参数实现对复杂动效的设计。 14. ANIME.JS 这是一款强大的使用JS开发的动效库，支持 CSS，DOM，SVG，和JS对象。 15. MO.JS Mo.js 是一款完整的JS动效库，目前它拥有一系列的预设参数，确保你能快速的上手使用。值得注意的是，Mo.JS 是模块化的，你可以轻松移除不必要的功能，确保体量合理和流畅运行。 16. SEQUENCE.JS Sequence.js 是一个CSS驱动下的动效框架，用来构建基于步骤的响应式的动效。 17. SHIFTY Shifty 是一款性能优异，速度够快且足够灵活的补间动画引擎，它是公认的 GreenSock 替代方案。 18. IT’S TUESDAY Tuesday 是一款独立的动效库，可以和其他的库一起搭配使用，其中的动效大多以流畅和优雅著称，淡入淡出，扩展，收缩效果均是如此。 19. CSS ANIMATE 你可以使用 CSS Animate 作为测试和生成动效代码的游乐场，任何常规动效都可以在这里帮你测试，设置好名称、类、动效属性、框架属性以及时间轴和标记之后，最终能够生成你想要的代码和动效。 20. VIVUS.JS VIVUS.JS 能够给你带来延时、同步和展现这三种类型的动效。而动效的核心还是借助SVG来实现。 21. BONSAI.JS Bonsai.js 是一个用来做高级图形处理的JS库，它有着非常简单易用的API和SVG渲染器。 22. GSAP BY GREENSOCK GSAP 是一个强大的动效平台，用来创造专业的动效。它囊括了许多专业的插件和实用的工具。这些插件都包含在了其中：BezierPlugin, CSSPlugin, DrawSVGPlugin, MorphSVGPlugin, Physics2DPlugin, TweenLite, 等. 23. POPMOTION Popmotion 是另外一款源自于 Greensock 的轻量级的动效引擎。它可以完全控制每一帧的效果，先进的补间技术和色彩混合功能让它能够应对复杂的动效设计。 24. TWEEN.JS TWEEN.JS 是目前最强大的动效补间引擎，其中的参数控制系统足够完善，让你拥有绝佳的动效解决方案。 25. HOVER.CSS Hover.css: 这是一组使用CSS3实现的悬浮特效，它可以应用到按钮、链接、LOGO、SVG、图片等元素上。它还提供了CSS、Sass和Less的版本。 26. TRANSIT Transit 的功能其实并不多，但是它涵盖了完善的2D转3D的动效的功能。 27. ROCKET Rocket 提供的是物体从一个点运动到另外一个点的动效解决方案，包括8个特殊的效果，让你的动效足够可爱有趣。 28. ANIMO.JS Animo.js 是一款轻量级的动效处理工具，它还支持额外的插件来实现倒计时、旋转等不同样式的动效，借助额外的支持库，帮你实现预期的动效。 29. SHIFT.CSS Shift.css 是一个用来构建自适应元素动效的框架。 30. CSSHAKE CSShake 中包含了11类不同的可控动效属性，包括方向（水平、上下），类型（固定、疯狂），强度（强、弱）等等，让你可以全方位控制动效的特征。 31. SAFFRON 如果你喜欢 mixin 来轻松控制动效，那么Saffron 肯定会让你爱不释手。它是使用Sass来编写，可以更方便地设置参数和变量。 32. CSSYNTH CSSynth 是一个轻量级的动效编辑器，让你可以更轻松地设置同步或者延迟效果，然后可以下载相应的CSS或者SCSS代码。 33. CEASER Ceaser 是一款经过时间考验的动效工具，能够生成经典的动画效果。 34. MORF.JS MORF.JS 中包含了超过40种预定义的动效，并且你可以根据自己的需要在它们基础上进行自定义。 35. VOXEL.CSS Voxel.css 是专门用来3D 渲染的工具，即使你是新手也能够轻松掌握3D CSS样式。 -—– 原文地址：webdesignerdepot 原文作者：Nataly Birch 优设译文：@陈子木]]></content>
      <categories>
        <category>前端, css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端学习资源分享]]></title>
    <url>%2F2017%2F06%2F16%2F%E4%BD%A0%E4%BB%A5%E4%B8%BA%20CSS%20%E5%8F%AA%E6%98%AF%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B8%83%E5%B1%80%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[你以为 CSS 只是个简单的布局？CSS3 奇思妙想前几天看了一篇文章 ， 颠覆了我对 CSS 认识，心中无数次蹦出一个念头：’卧槽，卧槽，还能特么这么用，这特么太叼了’ … 于是我迫不及待想跟你们一起分享分享，以后你也可以在别人面前炫（装）耀（逼）了~ ps：本文原创不是我，我只是搬运工，看到好东西与大家分享而已，作者 github 主页请戳 这里~ 装逼指南本文中，所有的图形都是在单个标签内实现的，大量使用了 CSS3 中的 ::before、::after 伪元素，transparent 、border，多重线性与径向渐变，多重内外阴影，如果你的效果不尽人意，请尝试在 Chrome 浏览器下预览。 装逼技巧本文所有图形都会有个容器 &lt;div class=&quot;css-cell&quot;&gt;&lt;/div&gt;包裹，其样式结构如下： 12345.css-cell&#123; position: relative; width: 100%; height: 300px;&#125; 所有图形都是在容器内实现的，其结构如下： 1234&lt;!--heart--&gt;&lt;div class=&quot;css-cell&quot;&gt; &lt;div class=&quot;heart&quot;&gt;&lt;/div&gt;&lt;/div&gt; 天气那一块有部分会多一个容器，其结构如下： 12345&lt;div class=&quot;css-cell &quot;&gt; &lt;div class=&quot;breeze-container&quot;&gt; &lt;div class=&quot;breeze&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 为了方便起见，下面图形的具体实现，我只会贴出对应的类相应的样式代码~ 装逼实战 爱心 利用 div 的正方形和伪类的圆型组合而成，具体代码如下： 1234567891011121314151617181920212223242526/*heart*/.heart&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%) rotate(45deg); background: red; width: 100px; height: 100px;&#125;.heart:before,.heart:after&#123; content: &apos;&apos;; position: absolute; top: 0; left: -50px; width: 100px; height: 100px; border-radius: 50%; background: red;&#125;.heart:after&#123; top: -50px; left: 0;&#125; 气泡悬浮框 利用 border 结合 transparent 特性实现，代码如下： 12345678910111213141516171819202122232425/*bubbly*/.bubbly&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%); background: #00ccbb; border-radius: 8px; width: 200px; padding: 40px 10px; text-align: center; color: white; font-size: 20px;&#125;.bubbly:after &#123; content: &apos;&apos;; position: absolute; bottom: 0; left: 50%; border: 34px solid transparent; border-top-color: #00ccbb; border-bottom: 0; border-left: 0; margin: 0 0 -34px -17px;&#125; 切角 利用使用线性渐变实现的，代码如下： 12345678910111213141516171819202122/*notching*/.notching&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%); width: 200px; padding: 60px 20px;&#125;.notching&#123; background: linear-gradient(135deg, transparent 15px, deeppink 0) top left, linear-gradient(-135deg, transparent 15px, deeppink 0) top right, linear-gradient(-45deg, transparent 15px, deeppink 0) bottom right, linear-gradient(45deg, transparent 15px, deeppink 0) bottom left; background-size: 50% 50%; background-repeat: no-repeat;&#125; 弧形切角 使用径向渐变实现，具体实现如下： 12345678910111213141516171819202122/*arc*/.arc&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%); width: 80px; padding: 80px;&#125;.arc &#123; background: radial-gradient(circle at top left, transparent 15px, yellowgreen 0) top left, radial-gradient(circle at top right, transparent 15px, yellowgreen 0) top right, radial-gradient(circle at bottom right, transparent 15px, yellowgreen 0) bottom right, radial-gradient(circle at bottom left, transparent 15px, yellowgreen 0) bottom left; background-size: 50% 50%; background-repeat: no-repeat;&#125; 梯形 利用伪类加旋转透视实现，具体实现如下： 123456789101112131415161718192021/*trapezoid*/.trapezoid&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%); width: 160px; padding: 60px;&#125;.trapezoid:before&#123; content:&quot;&quot;; position: absolute; top: 0; right: 0; bottom: 0; left: 0; transform:perspective(40px) scaleY(1.3) rotateX(5deg); transform-origin: bottom; background:dodgerblue; z-index:-1;&#125; 饼图 利用伪类、线性渐变、旋转实现，具体代码如下： 12345678910111213141516171819202122232425262728293031/*pie*/.pie&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%); width: 200px; height:200px; border-radius:50%; text-align: center; background-color:yellowgreen; overflow:hidden; background-image: linear-gradient(to right, transparent 50%, #655 0); cursor:pointer;&#125;.pie:before&#123; content:&quot;&quot;; position:absolute; top:0; left:50%; width:50%; height:100%; background-color: inherit; transform-origin: left; z-index:-1; transform:rotate(.1turn);&#125;.pie:hover:before&#123; transition:all 1s; transform:rotate(.45turn);&#125; 平行四边形 利用伪类、拉伸实现，实现过程如下： 123456789101112131415161718192021/*parallelogram*/.parallelogram&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%); width: 200px; height:120px;&#125;.parallelogram:before&#123; content: &apos;&apos;; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color:#00aabb; z-index:-1; transform: skew(.08turn);&#125; 折角 利用切角、伪类、渐变、旋转实现，代码如下： 123456789101112131415161718192021222324/*corner*/.corner&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%); width: 120px; height:120px; padding:40px; background:linear-gradient(-150deg,transparent 1.5em, yellowgreen 0); border-radius:8px;&#125;.corner:before&#123; content: &apos;&apos;; position: absolute; top: 0; right: 0; background: linear-gradient(to left bottom,transparent 50%, rgba(0,0,0,.2) 0, rgba(0,0,0,.4)) 100% 0 no-repeat; width: 1.73em; height: 3em; transform: translateY(-1.3em) rotate(-30deg); transform-origin: bottom right; border-bottom-left-radius: inherit; box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.15);&#125; 纯 CSS 方案实现背景变暗效果（hover按钮触发） 鼠标移入 利用 box-shadow 实现，具体代码如下： 123456789101112131415161718/*spectiveBlur*/.spectiveBlur&#123; position: absolute; top: 50%; left: 50%; width: 220px; height:160px; transform: translate(-50%, -50%); border-radius:10px; overflow:hidden; background:#E91E63; cursor:pointer; transition: transform .2s;&#125;.spectiveBlur:hover&#123; box-shadow:0 0 0 1920px rgba(0,0,0,.7); transform: translate(-50%, -50%) scale(1.2);&#125; 条纹背景图 主要是利用渐变实现，具体实现如下： 123456789101112/*stripe*/.stripe&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%); width: 200px; height:200px; background:deeppink; border-radius:.5em; background:repeating-linear-gradient(45deg,#CC9999, #CC9999 15px, #CCCCCC 0, #CCCCCC 30px)&#125; 12345678910111213141516/*wave-stripe*/.wave-stripe&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%); width: 200px; height:200px; border-radius:.5em; background: linear-gradient(135deg, deeppink 25%, transparent 25%) -50px 0, linear-gradient(225deg, deeppink 25%, transparent 25%) -50px 0, linear-gradient(315deg, deeppink 25%, transparent 25%), linear-gradient(45deg, deeppink 25%, transparent 25%); background-size: 40px 40px;&#125; 12345678910111213141516/*arrow-stripe*/.arrow-stripe&#123; position: absolute; top:50%; left: 50%; transform:translate(-50%,-50%); width: 200px; height:200px; border-radius:.5em; background: linear-gradient(45deg, #92baac 45px, transparent 45px)64px 64px, linear-gradient(45deg, #92baac 45px, transparent 45px,transparent 91px, #e1ebbd 91px, #e1ebbd 135px, transparent 135px), linear-gradient(-45deg, #92baac 23px, transparent 23px, transparent 68px,#92baac 68px,#92baac 113px,transparent 113px,transparent 158px,#92baac 158px); background-color:#e1ebbd; background-size: 128px 128px;&#125; 混合模式背景图 123456789101112131415.colorful-stripe &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; height: 200px; text-align: center; color: #fff; font-size: 200%; border-radius: .5em; background: linear-gradient(limegreen, transparent), linear-gradient(90deg, skyblue, transparent), linear-gradient(-90deg, coral, transparent); background-blend-mode: screen;&#125; 太阳 利用线性渐变、阴影、旋转实现，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*sun*/.sun&#123; position: absolute; top: 50%; left: 50%; width:200px; height:260px; transform: translate(-50%, -50%); background:#0BF; border-radius:5px;&#125;.sun:before&#123; content:&quot;&quot;; position: absolute; width: 80px; height: 80px; left: 50%; top: 50%; transform: translate(-50%, -50%); border-radius:50%; background:rgba(255, 238, 68, 1); box-shadow: 0 0 0 15px rgba(255,255,0,0.2),0 0 15px #fff; z-index:-10;&#125;.sun:after&#123; content:&quot;&quot;; position: absolute; top: 50%; left: 50%; height: 160px; width: 160px; transform: translate(-50%, -50%) rotate(30deg); z-index:-100; background-image: -webkit-linear-gradient(top,rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 50%, rgba(255,255,255,0) 100%), -webkit-linear-gradient(left,rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 50%, rgba(255,255,255,0) 100%); background-size: 20px 100%, 100% 20px; background-repeat: no-repeat; background-position: center center, center center; animation:sunRotate 10s linear infinite;&#125;@keyframes sunRotate&#123; 0%&#123; transform: translate(-50%, -50%) rotate(30deg); &#125; 100%&#123; transform: translate(-50%, -50%) rotate(390deg); &#125;&#125; 多云 利用线性渐变、阴影、缩放实现，具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*cloudy*/.cloudy&#123; position: absolute; top: 50%; left: 50%; width:200px; height:260px; transform: translate(-50%, -50%); background:#2EB5E5; border-radius:5px;&#125;.cloudy:before &#123; content: &quot;&quot;; text-indent:23px; font-size:22px; line-height:40px; color:#333; position: absolute; height: 50px;width: 50px; background: #FFFFFF; left:30%; top:45%; transform: translate(-50%, -50%); border-radius: 50%; box-shadow: #FFFFFF 65px -15px 0 -5px, #FFFFFF 25px -25px, #FFFFFF 30px 10px, #FFFFFF 60px 15px 0 -10px, #FFFFFF 85px 5px 0 -5px, #C8C8C8 35px -35px, #C8C8C8 66px -27px 0 -5px, #C8C8C8 91px -10px 0 -8px; animation: cloudy 5s ease-in-out infinite;&#125;.cloudy:after&#123; content:&quot;&quot;; position: absolute; top: 80%; left: 50%; height: 15px; width: 120px; background:rgba(0,0,0,.5); border-radius: 50%; transform: translate(-50%, -50%); animation: cloudy_shadow 5s ease-in-out infinite;&#125;@keyframes cloudy &#123; 50%&#123; transform: translate(-50%, -70%); &#125; 100%&#123; transform: translate(-50%, -50%); &#125;&#125;@keyframes cloudy_shadow &#123; 50%&#123; transform: translate(-50%, -50%) scale(0.8); background:rgba(0,0,0,.2); &#125; 100%&#123; transform: translate(-50%, -50%) scale(1); background:rgba(0,0,0,.5); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*cloudy2*/.cloudy2&#123; position: absolute; top: 50%; left: 50%; width:200px; height:260px; transform: translate(-50%, -50%); background:#2EB5E5; border-radius:5px;&#125;.cloudy2:before &#123; content: &quot;&quot;; text-indent:23px; font-size:22px; line-height:40px; color:#333; position: absolute; height: 50px;width: 50px; background: #FFFFFF; left:30%; top:55%; transform: translate(-50%, -50%); border-radius: 50%; z-index:100; box-shadow: #FFFFFF 65px -15px 0 -5px, #FFFFFF 25px -25px, #FFFFFF 30px 10px, #FFFFFF 60px 15px 0 -10px, #FFFFFF 85px 5px 0 -5px; animation: cloudy2 5s ease-in-out infinite;&#125;.cloudy2:after&#123; content:&quot;&quot;; position: absolute; top: 45%;left: 63%; height: 60px; width: 60px; z-index:10; background:linear-gradient(180deg,#FE9F38 0%, #F46635 100%); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px 4px #FFA563; animation: cloudy2 10s ease-in-out infinite;&#125;@keyframes cloudy2 &#123; 50%&#123; transform: translate(-50%, -70%); &#125; 100%&#123; transform: translate(-50%, -50%); &#125;&#125; 雨 利用线性渐变、阴影、缩放实现，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*rainy*/.rainy &#123; position: absolute; width: 3px; height: 6px; top: 30%; left: 50%; background: #CCCCCC; border-radius: 50%; animation: rainy_rain .7s infinite linear;&#125;.rainy:before &#123; content: &quot;&quot;; color: #333; position: absolute; height: 50px; width: 50px; top: 30px; left: -40px; background: #CCC; transform: translate(-50%, -50%); border-radius: 50%; box-shadow: #CCC 65px -15px 0 -5px, #CCC 25px -25px, #CCC 30px 10px, #CCC 60px 15px 0 -10px, #CCC 85px 5px 0 -5px; animation: cloudy 5s ease-in-out infinite;&#125;.rainy:after &#123; content: &quot;&quot;; position: absolute; top: 120px; left: 50%; height: 15px; width: 120px; background: rgba(0, 0, 0, .5); border-radius: 50%; transform: translate(-50%, -50%); animation: cloudy_shadow 5s ease-in-out infinite;&#125;@keyframes cloudy &#123; 50% &#123; transform: translate(-50%, -70%); &#125; 100% &#123; transform: translate(-50%, -50%); &#125;&#125;@keyframes cloudy_shadow &#123; 50% &#123; transform: translate(-50%, -50%) scale(0.8); background: rgba(0, 0, 0, .2); &#125; 100% &#123; transform: translate(-50%, -50%) scale(1); background: rgba(0, 0, 0, .5); &#125;&#125;@keyframes rainy_rain &#123; 0% &#123; box-shadow: rgba(0, 0, 0, 0) -10px 30px, rgba(0, 0, 0, 0) 40px 40px, rgba(0, 0, 0, .3) -50px 75px, rgba(0, 0, 0, .3) 55px 50px, rgba(0, 0, 0, .3) -18px 100px, rgba(0, 0, 0, .3) 12px 95px, rgba(0, 0, 0, .3) -31px 45px, rgba(0, 0, 0, .3) 30px 35px; &#125; 25% &#123; box-shadow: rgba(0, 0, 0, .3) -10px 45px, rgba(0, 0, 0, .3) 40px 60px, rgba(0, 0, 0, .3) -50px 90px, rgba(0, 0, 0, .3) 55px 65px, rgba(0, 0, 0, 0) -18px 120px, rgba(0, 0, 0, 0) 12px 120px, rgba(0, 0, 0, .3) -31px 70px, rgba(0, 0, 0, .3) 30px 60px; &#125; 26% &#123; box-shadow: rgba(0, 0, 0, .3) -10px 45px, rgba(0, 0, 0, .3) 40px 60px, rgba(0, 0, 0, .3) -50px 90px, rgba(0, 0, 0, .3) 55px 65px, rgba(0, 0, 0, 0) -18px 40px, rgba(0, 0, 0, 0) 12px 20px, rgba(0, 0, 0, .3) -31px 70px, rgba(0, 0, 0, .3) 30px 60px; &#125; 50% &#123; box-shadow: rgba(0, 0, 0, .3) -10px 70px, rgba(0, 0, 0, .3) 40px 80px, rgba(0, 0, 0, 0) -50px 100px, rgba(0, 0, 0, .3) 55px 80px, rgba(0, 0, 0, .3) -18px 60px, rgba(0, 0, 0, .3) 12px 45px, rgba(0, 0, 0, .3) -31px 95px, rgba(0, 0, 0, .3) 30px 85px; &#125; 51% &#123; box-shadow: rgba(0, 0, 0, .3) -10px 70px, rgba(0, 0, 0, .3) 40px 80px, rgba(0, 0, 0, 0) -50px 45px, rgba(0, 0, 0, .3) 55px 80px, rgba(0, 0, 0, .3) -18px 60px, rgba(0, 0, 0, .3) 12px 45px, rgba(0, 0, 0, .3) -31px 95px, rgba(0, 0, 0, .3) 30px 85px; &#125; 75% &#123; box-shadow: rgba(0, 0, 0, .3) -10px 95px, rgba(0, 0, 0, .3) 40px 100px, rgba(0, 0, 0, .3) -50px 60px, rgba(0, 0, 0, 0) 55px 95px, rgba(0, 0, 0, .3) -18px 80px, rgba(0, 0, 0, .3) 12px 70px, rgba(0, 0, 0, 0) -31px 120px, rgba(0, 0, 0, 0) 30px 110px; &#125; 76% &#123; box-shadow: rgba(0, 0, 0, .3) -10px 95px, rgba(0, 0, 0, .3) 40px 100px, rgba(0, 0, 0, .3) -50px 60px, rgba(0, 0, 0, 0) 55px 35px, rgba(0, 0, 0, .3) -18px 80px, rgba(0, 0, 0, .3) 12px 70px, rgba(0, 0, 0, 0) -31px 25px, rgba(0, 0, 0, 0) 30px 15px; &#125; 100% &#123; box-shadow: rgba(0, 0, 0, 0) -10px 120px, rgba(0, 0, 0, 0) 40px 120px, rgba(0, 0, 0, .3) -50px 75px, rgba(0, 0, 0, .3) 55px 50px, rgba(0, 0, 0, .3) -18px 100px, rgba(0, 0, 0, .3) 12px 95px, rgba(0, 0, 0, .3) -31px 45px, rgba(0, 0, 0, .3) 30px 35px; &#125;&#125; 微风 利用border、transparent、实现，这个会多一层 div.breeze-container 包裹，样式代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*breeze*/.breeze-container&#123; position: absolute; top: 50%;left: 50%; width:200px;height:260px; transform: translate(-50%, -50%); text-align:center; font-size:200%; color:#fff; background:#00BBFF; border-radius:5px;&#125;.breeze-container:after&#123; content:&quot;&quot;; position:absolute; top:58%; left:50%; transform: translate(-50%, -50%); width:6px; height:70px; background:#fff;&#125;.breeze&#123; position:absolute; top: 30%; left: 50%; transform: translate(-50%, -50%) rotate(1deg); border-bottom:60px solid #fff; border-left:5px solid transparent; border-right:5px solid transparent; animation: windmill 12s infinite linear; transform-origin:50.5% 62px;&#125;.breeze:before&#123; position:absolute; top: 75px;left: -59px; content:&quot;&quot;; border-right:60px solid #fff; border-top:5px solid transparent; border-bottom:5px solid transparent; transform:rotate(-30deg);&#125;.breeze:after&#123; position:absolute; top: 75px;left: -1px; content:&quot;&quot;; border-left:60px solid #fff; border-top:5px solid transparent; border-bottom:5px solid transparent; transform:rotate(30deg);&#125;@keyframes windmill&#123; 0%&#123; transform: translate(-50%, -50%) rotate(0deg); &#125; 100%&#123; transform: translate(-50%, -50%) rotate(360deg); &#125;&#125; 彩虹 主要是利用border、box-shadow 实现，具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*rainbow*/.rainbow-container&#123; position: absolute; top: 50%; left: 50%; width:200px; height:260px; transform: translate(-50%, -50%); background:#F3D166; border-radius:5px;&#125;.rainbow&#123; position:absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); height: 1px;width: 1px;&#125;.rainbow:before&#123; content:&quot;&quot;; position:absolute; top: 50%;left: 50%; transform: translate(-50%, -50%) rotate(45deg); height: 70px;width: 70px; border-radius: 100px 0 0 0; box-shadow: #F44336 -2px -2px 0 1px, #FF9800 -4px -4px 0 3px, #FFEB3B -6px -6px 0 5px, #8BC34A -8px -8px 0 7px, #00BCD4 -10px -10px 0 9px, #2196F3 -12px -12px 0 11px, #9C27B0 -14px -14px 0 13px; animation: rainbow 5s ease-in-out infinite;&#125;.rainbow:after&#123; content: &quot;&quot;; position: absolute; top: 70px; left: 50%; height: 15px; width: 120px; background: rgba(0, 0, 0, .5); border-radius: 50%; transform: translate(-50%, -50%); animation: cloudy_shadow 5s ease-in-out infinite;&#125;@keyframes rainbow &#123; 50% &#123; transform: translate(-50%, -55%) rotate(30deg); &#125; 100% &#123; transform: translate(-50%, -50%) rotate(45deg); &#125;&#125;@keyframes cloudy_shadow &#123; 50% &#123; transform: translate(-50%, -50%) scale(0.8); background: rgba(0, 0, 0, .2); &#125; 100% &#123; transform: translate(-50%, -50%) scale(1); background: rgba(0, 0, 0, .5); &#125;&#125; 夜空 主要是利用 box-shadow 实现 ， 实现方式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*starry*/.starry-container&#123; position: absolute; top: 50%; left: 50%; width:200px; height:260px; transform: translate(-50%, -50%); background:#222233; border-radius:5px;&#125;.starry&#123; position:absolute; top: 30%;left: 40%; transform: translate(-50%, -50%); height: 4px;width: 4px; border-radius:50%; box-shadow: #FFFFFF -26px 77px 0 -1px, rgba(255,255,255,0.1) -36px 59px 0 -1px, rgba(255,255,255,0.1) -28px 89px 0 -1px, #FFFFFF -35px 20px 0 -1px, #FFFFFF 14px 100px, rgba(255,255,255,0.1) 41px 60px, #FFFFFF 34px 39px, rgba(255,255,255,0.1) 14px 45px 0 -1px, #FFFFFF 64px 12px 0 -1px, rgba(255,255,255,0.1) 32px 96px 0 -1px, #FFFFFF 64px 71px, rgba(255,255,255,0.1) 60px 18px 0 -1px, #FFFFFF 34px 9px, rgba(255,255,255,0.1) -26px 55px 0 -1px; animation: starry_star 5s ease-in-out infinite;&#125;.starry:before&#123; content:&quot;&quot;; position:absolute; top: 20%;left: 50%; width:100px;height:100px; box-shadow: #FFFFFF -25px 0; transform: rotate(-5deg); border-radius: 50%; animation: starry 5s ease-in-out infinite;&#125;@keyframes starry &#123; 50% &#123; transform: rotate(10deg); &#125;&#125;@keyframes starry_star&#123; 50%&#123; box-shadow: rgba(255,255,255,0.1) -26px 77px 0 -1px, #FFF -36px 59px 0 -1px, #FFF -28px 89px 0 -1px, rgba(255,255,255,0.1) -35px 20px 0 -1px, rgba(255,255,255,0.1) 14px 100px, #FFF 41px 60px, rgba(255,255,255,0.1) 34px 39px, #FFF 14px 45px 0 -1px, rgba(255,255,255,0.1) 64px 12px 0 -1px, #FFF 32px 96px 0 -1px, rgba(255,255,255,0.1) 64px 71px, #FFF 60px 18px 0 -1px, rgba(255,255,255,0.1) 34px 9px, #FFF -26px 55px 0 -1px; &#125;&#125; 雷电 主要是利用阴影、border实现，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*thunder*/.thunder-container &#123; position: absolute; top: 50%; left: 50%; width: 200px; height: 260px; transform: translate(-50%, -50%); background: #444; border-radius: 5px;&#125;.thunder &#123; color: #333; position: absolute; height: 50px; width: 50px; top: 40%; left: 30%; background: #222; transform: translate(-50%, -50%); border-radius: 50%; box-shadow: #222 65px -15px 0 -5px, #222 25px -25px, #222 30px 10px, #222 60px 15px 0 -10px, #222 85px 5px 0 -5px; animation: cloudy 5s ease-in-out infinite;&#125;.thunder:before &#123; content: &quot;&quot;; position: absolute; top: 60px; left: 60px; border-left: 0px solid transparent; border-right: 8px solid transparent; border-top: 38px solid yellow; box-shadow: yellow -7px -32px; transform:rotate(30deg); transform-origin:center -50px; animation:stormy_thunder 2s steps(1, end) infinite;;&#125;.thunder:after &#123; content: &quot;&quot;; position: absolute; top: 120px; left: 64px; height: 15px; width: 120px; background: rgba(0, 0, 0, .5); border-radius: 50%; z-index:-1; transform: translate(-50%, -50%); animation: cloudy_shadow 5s ease-in-out infinite;&#125;@keyframes cloudy &#123; 50% &#123; transform: translate(-50%, -30px); &#125;&#125;@keyframes cloudy_shadow &#123; 50% &#123; transform: translate(-50%, 0) scale(0.8); background: rgba(0, 0, 0, .2); &#125;&#125;@keyframes stormy_thunder&#123; 0% &#123; transform: rotate(30deg); opacity:1; &#125; 5% &#123; transform: rotate(-34deg); opacity:1; &#125; 10% &#123; transform: rotate(0deg); opacity:1; &#125; 15% &#123; transform: rotate(-34deg); opacity:0; &#125;&#125; 大雪 利用阴影实现 ， 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/*snow*/.snowy-container &#123; position: absolute; top: 50%; left: 50%; width: 200px; height: 260px; transform: translate(-50%, -50%); text-align: center; font-size: 200%; color: #fff; background: #607D8B; border-radius: 5px;&#125;.snowy &#123; position: absolute; width: 4px; height: 4px; border-radius:50%; top: 30%; left: 50%; background: #fff; border-radius: 50%; animation: snowy_rain 2s infinite linear;&#125;.snowy:before &#123; content: &quot;&quot;; color: #333; position: absolute; height: 50px; width: 50px; top: 30px; left: -40px; background: #eee; transform: translate(-50%, -50%); border-radius: 50%; box-shadow: #eee 65px -15px 0 -5px, #eee 25px -25px, #eee 30px 10px, #eee 60px 15px 0 -10px, #eee 85px 5px 0 -5px; animation: cloudy 5s ease-in-out infinite;&#125;.snowy:after &#123; content: &quot;&quot;; position: absolute; top: 120px; left: 50%; height: 15px; width: 120px; background: rgba(0, 0, 0, .5); border-radius: 50%; transform: translate(-50%, -50%); animation: cloudy_shadow 5s ease-in-out infinite;&#125;@keyframes cloudy &#123; 50% &#123; transform: translate(-50%, -70%); &#125; 100% &#123; transform: translate(-50%, -50%); &#125;&#125;@keyframes cloudy_shadow &#123; 50% &#123; transform: translate(-50%, -50%) scale(0.8); background: rgba(0, 0, 0, .2); &#125; 100% &#123; transform: translate(-50%, -50%) scale(1); background: rgba(0, 0, 0, .5); &#125;&#125;@keyframes snowy_rain &#123; 0% &#123; box-shadow: rgba(255, 255, 255, 0) -10px 30px, rgba(255, 255, 255, 0) 40px 40px, rgba(255, 255, 255, .6) -50px 75px, rgba(255, 255, 255, .6) 55px 50px, rgba(255, 255, 255, .6) -18px 100px, rgba(255, 255, 255, .6) 12px 95px, rgba(255, 255, 255, .6) -31px 45px, rgba(255, 255, 255, .6) 30px 35px; &#125; 25% &#123; box-shadow: rgba(255, 255, 255, .6) -10px 45px, rgba(255, 255, 255, .6) 40px 60px, rgba(255, 255, 255, .6) -50px 90px, rgba(255, 255, 255, .6) 55px 65px, rgba(255, 255, 255, 0) -18px 120px, rgba(255, 255, 255, 0) 12px 120px, rgba(255, 255, 255, .6) -31px 70px, rgba(255, 255, 255, .6) 30px 60px; &#125; 26% &#123; box-shadow: rgba(255, 255, 255, .6) -10px 45px, rgba(255, 255, 255, .6) 40px 60px, rgba(255, 255, 255, .6) -50px 90px, rgba(255, 255, 255, .6) 55px 65px, rgba(255, 255, 255, 0) -18px 40px, rgba(255, 255, 255, 0) 12px 20px, rgba(255, 255, 255, .6) -31px 70px, rgba(255, 255, 255, .6) 30px 60px; &#125; 50% &#123; box-shadow: rgba(255, 255, 255, .6) -10px 70px, rgba(255, 255, 255, .6) 40px 80px, rgba(255, 255, 255, 0) -50px 100px, rgba(255, 255, 255, .6) 55px 80px, rgba(255, 255, 255, .6) -18px 60px, rgba(255, 255, 255, .6) 12px 45px, rgba(255, 255, 255, .6) -31px 95px, rgba(255, 255, 255, .6) 30px 85px; &#125; 51% &#123; box-shadow: rgba(255, 255, 255, .6) -10px 70px, rgba(255, 255, 255, .6) 40px 80px, rgba(255, 255, 255, 0) -50px 45px, rgba(255, 255, 255, .6) 55px 80px, rgba(255, 255, 255, .6) -18px 60px, rgba(255, 255, 255, .6) 12px 45px, rgba(255, 255, 255, .6) -31px 95px, rgba(255, 255, 255, .6) 30px 85px; &#125; 75% &#123; box-shadow: rgba(255, 255, 255, .6) -10px 95px, rgba(255, 255, 255, .6) 40px 100px, rgba(255, 255, 255, .6) -50px 60px, rgba(255, 255, 255, 0) 55px 95px, rgba(255, 255, 255, .6) -18px 80px, rgba(255, 255, 255, .6) 12px 70px, rgba(255, 255, 255, 0) -31px 120px, rgba(255, 255, 255, 0) 30px 110px; &#125; 76% &#123; box-shadow: rgba(255, 255, 255, .6) -10px 95px, rgba(255, 255, 255, .6) 40px 100px, rgba(255, 255, 255, .6) -50px 60px, rgba(255, 255, 255, 0) 55px 35px, rgba(255, 255, 255, .6) -18px 80px, rgba(255, 255, 255, .6) 12px 70px, rgba(255, 255, 255, 0) -31px 25px, rgba(255, 255, 255, 0) 30px 15px; &#125; 100% &#123; box-shadow: rgba(255, 255, 255, 0) -10px 120px, rgba(255, 255, 255, 0) 40px 120px, rgba(255, 255, 255, .6) -50px 75px, rgba(255, 255, 255, .6) 55px 50px, rgba(255, 255, 255, .6) -18px 100px, rgba(255, 255, 255, .6) 12px 95px, rgba(255, 255, 255, .6) -31px 45px, rgba(255, 255, 255, .6) 30px 35px; &#125;&#125; 五角星 主要是利用border、transparent、旋转实现，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*star*/.five-star&#123; position: absolute; top: 35%; right: 50%; transform: translate(-50%, -50%) scale(8); width: 0; height: 0; display: block; border-left: 3.04px solid transparent; border-right: 3.24px solid transparent; border-bottom: 10px solid #98DBE3; -webkit-filter: drop-shadow(1px .5px 1px #ccc); cursor: pointer;&#125;.five-star:before&#123; content: &quot;&quot;; position: absolute; top: 8.65px; left: -8.82px; width: 0; height: 0; color: #98DBE3; display: block; border-left: 12.5px solid transparent; border-right: 12.5px solid transparent; border-bottom: 9.08px solid #98DBE3; transform-origin: top center; transform: rotate(36deg);&#125;.five-star:after&#123; content: &quot;&quot;; position: absolute; top: 8.65px; left: -15px; width: 0; height: 0; color: #98DBE3; display: block; border-left: 12.5px solid transparent; border-right: 12.5px solid transparent; border-bottom: 9.08px solid #98DBE3; transform-origin: top center; transform: rotate(-36deg);&#125; 太极八卦 利用 box-shadow 实现 ， 代码很简单： 123456789101112131415161718/*TaiChi*/.TaiChi&#123; position: absolute; top: 50%; left: 50%; width: 200px; height: 200px; transform: translate(-50%, -50%); box-shadow:0 0 2px #ddd; border-radius:50%; background-image: radial-gradient(#000 12.5px, transparent 12.5px), radial-gradient(#fff 12.5px, transparent 12.5px), radial-gradient(#fff 50px, transparent 50px), radial-gradient(#000 50px, transparent 50px), linear-gradient(90deg,#000 100px, #fff 100px); background-position:center 50px,center -50px,center 50px,center -50px,0 0;&#125; 美队盾牌 利用 渐变 实现 ， 代码如下： 123456789101112131415161718192021222324252627282930313233/*captainAmerica*/.captainAmerica&#123; position: absolute; top: 50%; left: 50%; width: 200px; height: 200px; transform: translate(-50%, -50%); background: linear-gradient(45deg, rgba(255,255,255,0) 35%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0) 65%), linear-gradient(-45deg, rgba(255,255,255,0) 35%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0) 65%), linear-gradient(to right, rgba(0,0,0,0) 35%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0) 65%), linear-gradient(to bottom, rgba(0,0,0,0) 35%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0) 65%), radial-gradient(ellipse at center, #0033b0 20%, #ce0021 20%, #ce0021 35%, #eee 35%, #eee 55%, #ce0021 55%); border-radius: 50%; box-shadow: 0 3px 0 #a20917,0 4px 2px 2px #eee;&#125;.captainAmerica::before&#123; content: &apos;★&apos;; position:absolute; top: 50%;left: 50%; transform: translate(-50%, -50%); margin-left:-3px; width: 50px;height:50px; font-family: simsun,Tahoma,Helvetica,Arial,SimHei,sans-serif; line-height: 47px; z-index: 1; border-radius: 50%; font-size: 55px; color: #fff; text-align:center; text-shadow: 2px 1px 2px #777;&#125; 纽扣 利用 渐变、阴影 实现 ， 实现方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*button*/.button&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 180px; height: 180px; background: #87ceeb; border-radius: 50%; box-shadow: inset 0 5px 5px #87ceeb, inset 0 17px 5px rgba(255,255,255,0.7), inset 0 -3px 3px rgba(255,255,255,0.3), inset 0 -10px 10px rgba(0,0,0,0.3), inset 0 -15px 10px #45b3e0, 0 7px 10px rgba(0,0,0,0.3);&#125;.button::before&#123; content: &apos;&apos;; position:absolute; top: 50%;left: 50%; width: 110px;height: 106px; margin-left: -55px;margin-top: -55px; background-image: radial-gradient(circle at 38px 38px, #333 10px, transparent 10px), radial-gradient(circle at 73px 73px, #333 10px, transparent 10px), radial-gradient(circle at 38px 73px, #333 10px, transparent 10px), radial-gradient(circle at 73px 38px, #333 10px, transparent 10px); border-radius: 50%; border-top: 1px solid rgba(0,0,0,0.6); border-bottom: 1px solid rgba(255,255,255,0.6); box-shadow: inset 0 20px 2px rgba(255,255,255,0.3), 3px -15px 7px -4px rgba(0,0,0,0.3), 0 -14px 10px 5px #45b3e0, 0 2px 5px 5px #87ceeb, 0 10px 5px 5px rgba(255,255,255,0.6);&#125;.button::after&#123; content: &apos;&apos;; position:absolute; top: 50%;left: 50%; width: 50px;height: 50px; margin-left: -25px; margin-top: -23px; background-image: linear-gradient(to right, transparent 35%, #000080 35%, #4682b4 40%, #000080 45%, #4682b4 50%, #000080 55%, #4682b4 60%, #000080 65%, transparent 65%), linear-gradient(to bottom, transparent 35%, #000080 35%, #4682b4 40%, #000080 45%, #4682b4 50%, #000080 55%, #4682b4 60%, #000080 65%, transparent 65%); border-radius: 50%; transform: rotate(45deg);&#125; Chrome 利用渐变实现 , 具体如下： 12345678910111213141516171819202122/*chrome*/.Chrome&#123; position: absolute; top: 50%;left: 50%; width: 180px;height: 180px; transform: translate(-50%, -50%); box-shadow:0 0px 4px #999,0 0 2px #ddd inset; border-radius:50%; background-image: radial-gradient(#4FACF5 0%,#2196F3 28%, transparent 28%), radial-gradient(#fff 33%, transparent 33%), linear-gradient(-50deg,#FFEB3B 34%, transparent 34%), linear-gradient(60deg,#4CAF50 33%, transparent 33%), linear-gradient(180deg,#FF756B 0%, #F44336 30%, transparent 30%), linear-gradient(-120deg,#FFEB3B 40%, transparent 40%), linear-gradient(-60deg,#FFEB3B 30%, transparent 30%), linear-gradient(0deg,#4CAF50 45%, transparent 45%), linear-gradient(60deg,#4CAF50 30%, transparent 30%), linear-gradient(120deg,#F44336 50%, transparent 50%), linear-gradient(180deg,#F44336 30%, transparent 30%); background-position:0 0;&#125; Opera 利用渐变实现 , 代码如下： 1234567891011121314151617181920212223242526272829/*Opera*/.Opera&#123; position: absolute; top: 50%;left: 50%; width: 170px;height: 200px; transform: translate(-50%, -50%); border-radius:50%; box-shadow:0 2px 4px #333; background-image: linear-gradient(rgb(254, 135, 138) 0%, rgb(231, 22, 22) 50%, rgb(128, 0, 0) 85%, rgb(184, 3, 4) 100%);&#125;.Opera:after&#123; content:&quot;&quot;; position: absolute; top:50%;left:50%; width: 60px;height: 180px; transform: translate(-50%, -50%); border-radius:50%; background:#fff;&#125;.Opera:before&#123; content:&quot;&quot;; position: absolute; top:50%;left:50%; width: 72px;height: 185px; transform: translate(-50%, -50%); border-radius:50%; background:rgba(0,0,0,.4);&#125; IE 利用渐变、多重阴影实现 ， 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/*IE*/.IE&#123; position: absolute; top: 50%; left: 50%; width:200px; height:200px; transform: translate(-50%, -50%); border-radius:50%; background-image: radial-gradient(#fff 38%, transparent 38%), radial-gradient(#09C 0%, #09C 100%);&#125;.IE:before&#123; content: &quot;&quot;; width:285px; height:122px; background:none; border-radius:100%; position:absolute; top:33px; left:-45px; margin:auto; box-shadow: inset 0 12px 0 13px #09c, -35px -8px 0 -5px #fff; transform: rotate(-35deg);&#125;.IE:after &#123; content: &quot;&quot;; width: 120px; height: 25px; background: #09c; position: absolute; top: 80px; left: 0; right: 0; margin: auto; box-shadow: 50px 23px 0 -2px #fff&#125; safari 利用渐变、border、旋转实现 ， 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*safari*/.safari&#123; position: absolute; top: 50%;left: 50%; width:200px; height:200px; transform: translate(-50%, -50%); border-radius:50%; border:5px solid #E8E8E8; box-shadow: -1px 3px 1px 2px #999, -1px 3px 1px 2px #999 inset; background-image: radial-gradient(transparent 30%,#fff 30%,#fff 34%, transparent 34%), linear-gradient(rgba(255,255,255,.8) 100%, transparent 100%), linear-gradient(rgba(255,255,255,.8) 100%, transparent 100%), linear-gradient(rgba(255,255,255,.8) 100%, transparent 100%), linear-gradient(rgba(255,255,255,.8) 100%, transparent 100%), linear-gradient(#1DE3FF 0%, #1F52EF 100%); background-size: 50% 50%,20px 2px,20px 2px,2px 20px,2px 20px,100%,100%; background-repeat:no-repeat; background-position:center center, 175px center,5px center,center 175px,center 5px,0 0;&#125;.safari::before&#123; content:&quot;&quot;; position: absolute; top: 10px;left: 50%; border-radius:10px; border-bottom:100px solid rgba(255,255,255,.9); border-left:10px solid transparent; border-right:10px solid transparent; transform-origin:center 90px; z-index:-1; transform:translate(-50%, 0%) rotate(40deg);&#125;.safari::after&#123; content:&quot;&quot;; position: absolute; top: 10px;left: 50%; border-radius:10px; border-bottom:100px solid rgba(255,0,0,.9); border-left:10px solid transparent; border-right:10px solid transparent; transform-origin:center 90px; transform:translate(-50%, 0%) rotate(220deg);&#125;.safari:hover::before&#123; transition:transform 1s; transform:translate(-50%, 0%) rotate(70deg);&#125;.safari:hover::after&#123; transition:transform 1s; transform:translate(-50%, 0%) rotate(250deg);&#125; firefox 利用多重阴影实现 , 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*firefox*/.firefox&#123; position: absolute; top: 50%;left: 50%; width: 200px;height:200px; transform: translate(-50%, -50%); border:8px solid #eee; border-radius:50%; overflow:hidden; background:#F48D00; box-shadow:0 0 2px 0 #999;&#125;.firefox::before&#123; content: &quot;&quot;; width: 46px; height: 46px; background: #A4DFEF; border-radius: 100%; position: absolute; top: 90px; left: 50px; margin: auto; border: 1px solid #A4DFEF; box-shadow: -10px 0 0 5px rgba(164, 223, 239, .2), 16px -60px 0 8px rgba(164, 223, 239, .2), -30px -50px 0 8px #F48D00, 25px -38px 0 0px #A4DFEF, -30px -30px 0 12px #F48D00, 15px -60px 0 8px #A4DFEF, 33px 31px 0 -15px #A4DFEF, 30px 17px 0 -13px #F48D00, 20px -10px 0 0px #A4DFEF, -8px -0px 0 19px #F48D00, 30px 17px 0 0px #A4DFEF, 24px 30px 0 15px #F48D00, 20px -6px 0 28px #A4DFEF, 45px 10px 0 35px #F48D00, -5px -57px 0 8px #F48D00, 20px -23px 0 45px #A4DFEF, -5px -80px 0 8px #A4DFEF, -30px -70px 0 8px #F48D00, -5px -57px 0 8px #F48D00, 43px -11px 0 55px #F48D00, 22px -39px 0 55px #A4DFEF;&#125;.firefox::after&#123; content: &quot;&quot;; width: 0px; height: 2px; background: linear-gradient(90deg,#F48D00 75% ,#333 30% ); background-size: 35px 35px; position: absolute; top: 50px; left: 73px; margin: auto; border: solid; border-width: 12px 0 15px 30px; border-color: #A4DFEF #fff #A4DFEF transparent; box-shadow: inset 0px 0 0 50px #333;&#125; 搜狗 利用文字、阴影实现 , 具体代码如下： 123456789101112131415161718192021222324252627282930313233/*sougou*/.sogou&#123; position: absolute; top: 50%; left: 50%; width: 200px;height:200px; transform: translate(-50%, -50%); border:8px solid #fff; box-shadow: 2px 1px 2px 2px #ccc; border-radius:50%; overflow:hidden; background:#4DA0ED;&#125;.sogou::before&#123; content:&quot;S&quot;; position: absolute; line-height: 185px; top:0; left:0; right:0; bottom:0; color:#fff; font-weight:600; font-size:320px; text-align:center; text-shadow: 3px 0 0px #337FC4, -5px 0px 0px #CDE4F0, 0px 8px 0px #387FBF; transform:rotate(2deg); z-index:-10; overflow:hidden;&#125; 利用滤镜实现混合效果 利用 fliter:blur() 、filter:contrast() 实现 ， 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*filter-mix*/.filter-mix&#123; position: absolute; top: 50%;left: 50%; transform: translate(-50%, -50%); width: 300px;height: 200px; -webkit-filter:contrast(20); background:#fff;&#125;.filter-mix::before&#123; content:&quot;&quot;; position: absolute; width:120px; height:120px; border-radius: 50%; background:#333; top:40px; left:0px; z-index:2; -webkit-filter:blur(6px); box-sizing:border-box; animation:filterBallMove 10s ease-out infinite; -webkit-animation:filterBallMove 10s ease-out infinite;&#125;.filter-mix::after&#123; content:&quot;&quot;; position: absolute; width:80px; height:80px; border-radius: 50%; background:#3F51B5; top:60px; right:0px; z-index:2; -webkit-filter:blur(6px); animation:filterBallMove2 10s ease-out infinite; -webkit-animation:filterBallMove2 10s ease-out infinite;&#125;@keyframes filterBallMove&#123; 50%&#123; left:200px; &#125;&#125;@-webkit-keyframes filterBallMove&#123; 50%&#123; left:200px; &#125;&#125;@keyframes filterBallMove2&#123; 50%&#123; right:200px; &#125;&#125;@-webkit-keyframes filterBallMove2&#123; 50%&#123; right:200px; &#125;&#125; 装逼总结怎么样，是不是颠覆了你对 CSS3 的认识？ 实际上 CSS3 带给我们的远不止这些东西，没有做不到，只有想不到，只有你脑洞够大，各种黑科技、酷炫的 CSS 必然也是手到擒来~ 虽然你给不了 CSS3 全部，但它却把全部给了你，骚年，加油吧~ 参考文献本文主要来源以下文章： magicCss CSS Secrets 对 CSS 感兴趣的同学可以去作者的 github 点个赞~]]></content>
      <categories>
        <category>前端, css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端学习资源分享]]></title>
    <url>%2F2017%2F06%2F16%2F%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB--web%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[个人分享–web前端学习资源分享1.前言时间过得真快，转眼间现在是2016年最后一个星期，而今天也是圣诞节，过几天也是元旦了。每到年底，大家都习惯总结和分享，我也不例外。但是经历，我之前已经发过了，那么我今天就分享吧！把我接触的一些资源分享给大家，算是送给大家的双旦礼物吧！希望大家能够从中获取自己所需的资源。从我接触前端的开始，到发稿时间截止的这段时间我看过很多的博客，开源项目也了解过一些，质量有参差不齐（甚至还出现过广告文，鸡汤文），但下面的推荐的博客，文章，项目或者其它资源都是我接触过的。不敢说资源最好，最全，适合每一个人，但是内容质量上让我满意的。可能有些资源我未必看完，看懂，看细。但我觉得是可以帮到大家的，能让大家提升技术水平的。希望能给大家起到一个引导，指路或者解惑的作用。如果大家有什么好的资源，也欢迎分享！ 有一些资源链接，在后面我会加上括号的注释！比如：“ html5推广（介绍html5开发的创意广告） ”，加上注释的原因可能有以下几点：1.资源很不错，干货比较多，提醒大家看！2.资源是一个系列的其中一个资源。比如一个系列有20多篇文章，每一篇都有用，我不可能把20多篇链接都贴上，所以一般我贴这个系列的第一条，提醒大家不要忘记读完所在系列！3.资源里面的部分内容我个人觉得很有用，有部分我觉得没什么用！提醒大家挑着看，按需求看！4.资源的标题可能会有些小误导，或者资源的其它注意事项，我加以自己的解释和备注。 2.推荐文章（教程）html(5)后HTML5时代I后HTML5时代II（简单粗暴的介绍html5的api，没什么废话）html5推广（介绍html5开发的创意广告）匠心打造canvas签名组件HTML5/CSS3（汤姆大叔总结的html5和css3的新特性）H5动画开发快车道移动H5前端性能优化指南玩转HTML5移动页面HTML5 进阶系列：文件上传下载HTML5 进阶系列：canvas 动态图表HTML5 进阶系列：拖放 API 实现拖放排序（这个系列的文章都不错，值得大家一看）H5动效的常见制作手法超多经典 canvas 实例，动态离子背景、移动炫彩小球、贪吃蛇、坦克大战、是男人就下100层、心形文字等等等打造高大上的Canvas粒子动画canvas入门实战–邀请卡生成与下载 css(3)CSS3属性教程与案例分享（大漠的CSS3干货，进去里面可以逐个看，对css3的学习很有用）CSS3实现11种经典的CSS技术（大漠的CSS3经典实例干货，对css3的学习很有用）W3cplus demo（w3cplus的案例，非常值得一看）强大的css3（概括性的说明css3的新特性的一篇文章）css3经典教程系列（不要忘记看完这个系列，文章都不错）个人总结（css3新特性）CSS3热身实战–过渡与动画（实现炫酷下拉，手风琴，无缝滚动）编写自己的代码库(css3常用动画的实现)也许vue+css3做交互特效更简单CSS 写作建议和性能优化小结如何编写轻量级 CSS 框架21条CSS高级技巧原创：CSS3技术-雪碧图自适应缩放与精灵动画方案Flex 布局教程：语法篇Flex 布局教程：实例篇奇妙的 CSS shapes(CSS图形)使用CSS3制作各种形状的图形（转自others）有趣的CSS题目（1）： 左边竖条的实现方法（看了第一篇，可以往下面看，总会会帮助的，不过这个网站有时候加载不出图片，如果加载不出图片，放弃还是坚持，大家抓主意）纯 CSS 实现波浪效果！使用浏览器开发者工具检测CSS动画性能搞定这些疑难杂症，向css3动画说yesEffective前端1：能使用html/css解决的问题就不要使用JS如何让你的动画更自然css画图形css各种鼠标效果深入了解 CSS3 新特性（也是概括性的总结，这个系列值得推荐）前端如何呼风唤雨:after和:before炫酷用法总结神奇的 conic-gradient 圆锥渐变10 个优质的 CSS 与 JS LOGO 动画示例被解放的GPU-提高CSS3性能【项目总结】扯一扯电商网站前端css的整体架构设计（1）（看了第一篇，别忘了看下面的一个系列）【整理】CSS布局方案css：默认的checkbox、input、radio太丑了？我来教你改变使用纯css3改写的带动画的默认样式20个实用的CSS技巧代码CSS性能分析，如何优化CSS提高性能CSS 黑魔法小技巧，让你少写不必要的JS，代码更优雅渐进式动画解决方案CSS新特性CSS Animation性能优化【转载】高性能的动画奇妙的 CSS shapes(CSS图形) sassSASS用法指南编写Sass的八个技巧 javascript深入理解JavaScript系列（汤姆大叔写的JavaScript系列，涉及到各个知识点，对学习和深入js很有用）JavaScript核心概念归纳整理（概括性的说明js的一些核心概念）从达标到卓越 —— API 设计之道我眼中的 JavaScript 函数式编程javascript组件化如何写出小而清晰的函数？（JS 版）javascript对象详解：proto和prototype的区别和联系理清javascript中的面向对象（一）——原型继承（这个专栏（实用至上）文章质量不错，值得留意）微前端-Javascript常用的设计模式详解10 个你需要了解的最佳 javascript 开发实践深入理解javascript原型和闭包系列JavaScript学习总结（一）基础部分（这个系列的文章不错，不要忘记看完这个系列不过大家得在发文章的专栏找下这个系列的文章，因为作者在这个专栏发文不是连着发一个系列，中间也夹杂着其它文章，不过也很好找。在这专栏（trigkit4）里面，即使不是这个系列的文章，我看过其中几篇，感觉也很好，大家可以留意下）JavaScript设计模式与开发实践 | 01 - 面向对象的JavaScript（这个系列的教程不错，《JavaScript设计模式与开发实践》的笔记，这本书我也看过，这本书不错，作者整理总结得也不错，大家看完，收获不少）JavaScript 函数式编程存在性能问题么？如何让 JS 写得更漂亮JS的平凡之路–学习人气眼中的效果（上）你还在用for循环大法麽？前端模板的原理与实现只有20行Javascript代码！手把手教你写一个页面模板引擎【教学向】150行代码教你实现一个低配版的MVVM库（1）- 原理篇【教学向】150行代码教你实现一个低配版的MVVM库（2）- 代码篇（可以关注这篇文章对应的专栏，写得不错，不知道作者还会不会写下一篇）如何循序渐进、有效地学习JavaScript？过目不忘JS正则表达式JavaScript 进阶之深入理解数据双向绑定利用 JavaScript 数据绑定实现一个简单的 MVVM 库（这篇文章除了自己简单造轮子，更重要的是用一个实例了解MVVM的原理）正则表达式30分钟入门教程如何监听页面 DOM 变动并高效响应IntersectionObserver API 使用教程（利用这个API可以更简单的实现图片懒加载和其它事情，性能也更高）（下面三个连接，是知乎上的几个话题，里面的回答质量参差不齐，大家可以挑些高质量的回答看，绝对有帮助）作为一名前端开发人员，有哪些值得一读的js代码？JavaScript 有什么奇技淫巧？用 JavaScript 可以做哪些有趣的事情？反击爬虫，前端工程师的脑洞可以有多大？（前端反爬虫的文章，只有想不到，没有做不到）这些的JavaScript编程黑科技，装逼指南，高逼格代码，让你惊叹不已如何写出好的 JavaScript —— 浅谈 API 设计JavaScript 设计模式 ① 正确使用面向对象编程的姿势（看了第一篇，不要忘记下面的）如何优雅的编写 JavaScript 代码个人小结–javascript实用技巧和写法建议用65行代码实现JavaScript动画序列播放如何用原生 JS 实现手势解锁组件Javascript思维导图纯前端实现人脸识别-提取-合成最全正则表达式总结：验证QQ号、手机号、Email、中文、邮编、身份证、IP地址等99%的人都理解错了HTTP中GET与POST的区别JavaScript练习网站收集（收录一些js练习的网站，有空可以去练习一下）重新介绍 JavaScript（JS 教程）编写自己的代码库（javascript常用实例的实现与封装）让我印象深刻的javascript面试题JavaScript 打怪升级 —— 把业务逻辑当练习题做 javascript(es6，es7，es8)阮一峰 es6（可以当作es6文档用的在线书籍）ES6 你可能不知道的事 - 基础篇ES6 你可能不知道的事 - 进阶篇30分钟掌握ES6/ES2015核心内容（简单粗暴介绍es6核心）八段代码彻底掌握 PromiseECMAScript 6 新特性（总结性描写常用的es6新特性）实例感受-es6的常用语法和优越性10个最佳ES6特性聊聊ES7与ES8特性Async/Await替代Promise的6个理由10分钟学会ES7+ES8import、require、export、module.exports 混合使用详解 typeScript官网文档（ts的一个官方文档，写得较好） jqueryjquery源码分析jQuery中的100个技巧（译）（看了这篇文章，感觉自己学的是假jquery，不过很多技巧我没有亲身试过，保留意见）这几条JQuery提升性能的规则你需要牢记JQuery坑，说说哪些大家都踩过的坑（对于刚接触的新人而言，这篇文章还有帮助）jQuery学习笔记（总结性说明jquery常用的api，也不错）jQuery插件开发总结jQuery === 面条式代码？ vuevue官网Vue2.x踩坑与总结Vue 中你不知道但却很实用的黑科技一个栗子实践vue2.0与1.0的区别我从未见过如此简洁易懂的Vue教程vue-API（2.3版本的API大全）Vue.js 插件开发详解vue插件编写与实战（从开发到发布的一个流程，实例简单易懂）使用 Vue.js 创建的 Calendar加薪DAY10」Vue开源项目库汇总（杂七杂八的库都有，质量当然也是有高有低，大家挑着看。）Vue.js 的实用技巧（一）(看了第一篇，别忘记剩下的)深入vue2.0底层思想–模板渲染Vue.js——vue-router 60分钟快速入门Vue2.1.7源码学习剖析Vue实现原理 - 如何实现双向绑定mvvmVue.js入门（一）–MVVM框架理解Vue2 源码分析——逻辑梳理手把手教你撸个vue2.0弹窗组件深入浅出基于“依赖收集”的响应式原理Vue全家桶实践项目总结vuex入门实例(1/3)原创《vue2.0进阶系列》教程目录大全另辟蹊径：vue单页面，多路由，前进刷新，后退不刷新vuejsexamples（vue的各种demo，可能会有需要的需求）vue快速入门的三个小实例（我自己的文章，比较基础的用法，用三个小实例讲解vue的入门，）用vue开发一个所谓的数独 webpack（下面的文章，有些是webpack1.x和2.x的，考虑到现在已经更新到3.x了，大家看时候要注意区别）webpack中文网webpack官方文档webpack使用优化（基本篇）webpack常用功能介绍webpack 3 零基础入门教程 #1 - 介绍（看了第一篇，不要忘记下面的，这个系列值得一看）开发工具心得：如何 10 倍提高你的 Webpack 构建效率Webpack 大法之 Code Splittingwebpack多页应用架构系列（一）：一步一步解决架构痛点（看了第一篇不要忘记剩下的，这个系列的文章不错） parcel宣布 Parcel：一个快速，零配置的 Web 应用打包工具前端构建工具吐槽与parcel极简入门折腾记：Hello Parcel从 webpack 到全面拥抱 Parcel #1 探索 Parcel（这篇应该会用后续内容，大家可以跟着学） gulpgulp详细入门教程前端构建工具gulp的使用介绍及技巧gulp入门指南 react（react我刚接触不久，暂时看过的网站就这两个）React中国React 技术栈系列教程React组件规范在在 2017 年学习 React + Redux 的一些建议（中篇）在 2017 年学习 React + Redux 的一些建议（下篇）学习 React.js 比你想象的要简单 git猴子都能懂的GIT入门Git教程 - 廖雪峰的官方网站 browsersync(Browsersync中文网 - 省时的浏览器同步测试工具) node.js使用npm - NodeSource的绝对入门指南Node.js和npm - NodeSource中的Package.json的基础知识配置.npmrc以获取最佳Node.js环境 Markdown认识与入门 Markdown yoeman教你从零开始搭建一款前端脚手架工具 lodash这是一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库。4.17.4版本 Fiddler官网Fiddler教程 调试web调试优化-chrome开发者工具不完全指南分享几个日常调试方法让js调试更简单用 Chrome 调试你的 JavaScriptJavaScript 中 console 的用法（看了这篇和上面一篇文章，你可能会感觉以前根本不会使用console）Chrome开发者工具系列Web 的现状：网页性能提升指南移动 Web 开发问题和优化小结前端优化不完全指南 细节，优化浅谈移动前端的最佳实践前端优化带来的思考，浅谈前端工程化前端优化实践总结减少前端代码耦合判断单、多张图片加载完成终端代码重复率检测【组件化开发】前端进阶篇之如何编写可维护可升级的代码作为一个web开发人员，哪些技术细节是在发布站点前你需要考虑到的【单页应用】我们该如何处理框架弹出层层级关系？剥离模板代码加速Web页面加载移动前端系列——移动页面性能优化[聊一聊系列]聊一聊百度移动端首页前端速度那些事儿 其它socket.io 中文手册 socket.io 中文文档WebSocket 与 Socket.IOVR进化论|教你搭建通用的WebVR工程RxJS 入门deeplearn.js：浏览器端机器智能框架 分享和技能清单鸡年大吉！继续前行的前端周刊（第十五期）（虽然差不多狗年了，但是里面的内容并没有过时）前端收藏夹（和上面那篇一样，都是别人的总结的，干货不少，但是‘前端收藏夹’，可能是资源太多了，给我的感觉也有点一股脑放资源的感觉，只要是资源，都放进去，少部分资源质量有点低，建议大家带参考思想看）移动web干货收藏夹awesomes（前端一个巨大的资源库，里面的资源应有尽有）知识库（拥有很多语言，框架，库的知识图谱，值得一看！能让你了解哪个语言，框架，库所包含的知识点，每一个知识点的详情讲解，也有栗子和文章，如：javascript知识图谱，html5知识图谱，react知识图谱）前端资源分享送给前端的你，推荐几篇前端汇总文章。 - 知乎专栏前端面试问题合集（Front-end-Developer-Interview-Questions）github上值得关注的前端项目（trigkit4大神审理的一份清单，里面推荐的项目很多，大家可以按需所需）前端那点事儿（书列）FPB 2.0：免费的计算机编程类中文书籍 2.0（迷渡大神分享的书籍，各类图书都有，也有前端的，大家可以挑着看）腾讯 Web 工程师的前端书单前端开发者手册印记中文-手册（各种开发文档，webpack,vue,sass等）（以下几个链接，不是文章，也不算问题吧，都是segmentfault官方举行的比赛，分享或者讨论的内容，在上面看大神的分享，代码，绝对有收获）1024 HackGame 第四关面壁人这些题目是怎么想出来的？把 SegmentFault 全部带回家 —— 码文章，送周边官方送书活动第二弹 —— 增长姿势之SF喊你来谈开发官方活动，深入浅出之SF喊你来谈开发！一起来分享一下你的开发知识？官方30行js比赛：30行js你能做出什么？【官方比赛】社区 1111 秀代码，让你来秀让你飞！ 3.推荐博客团队博客淘宝前端团队fed阿里巴巴百度前端团队360奇舞团奇舞团视频教程京东设计体验部-凹凸实验室腾讯网前端研发中心腾讯alloyteam腾讯前端IMWEB团队腾讯前端IMWEB团队-github腾讯游戏新浪UED去哪儿网移动架构组大前端（饿了么）搜车大无线团队博客（上面的团队博客，值得关注，博文内容质量很高，但是就是更新不频繁，下面的更新会比较多，质量也不错）极乐科技IMWeb前端社区爱前端-知乎专栏前端杂货铺前端外刊评论前端解忧杂货铺DDFE 技术周刊前端之巅Fed汇总 大牛博客十年踪迹张鑫旭阮一峰叶小钗司徒正美博客汤姆大叔廖雪峰勾三股四chokCoCochokCoCo-githubCherry’s Blog雅X共赏的前端技术博客-前端路上 4.推荐书籍我看过的书比较杂七杂八，与前端有关的，推荐的就是下面这些了！下面的书，我都看过，区别就在于有些我是整本都看完了(有些也来回看过几次)，有些粗略的看了其中一部分（有些就看了几页）！ 关于看书的建议，下面的书，大家可以根据自己的需求兴趣去挑着看。一本书，不要看完就可以了，要弄懂书中的内容。有些书值得大家来回看几遍的！ 关于书的资源，下面的推荐的书（我看的是电子书）我都是从网上下载的。为避免侵权，我在这里就不放资源的链接了！大家自行购买纸质书或者电子书，或者到网上找资源！ 《JavaScript高级程序设计》：（红皮书或者红宝石书）可以作为入门书籍，但同时也是高级书籍，可以快速吸收基础，等到提升再回来重新看《JavaScript权威指南》：（犀牛书）可以说是js最经典的一本书了，新手看着可能会有点吃力，但是对于学js的人来说，必备的，不理解的地方就去查阅一下，很有帮助。《数据结构与算法JavaScript描述》（刺猬书）《编写可维护的JavaScript》（乌龟书）《JavaScript DOM编程艺术 第2版》《JavaScript语言精粹》（蝴蝶书）：经典的书，也是普及JavaScript的开发思维的一本书。《javascript框架设计》（第二版）-司徒正美《JavaScript设计模式 》-张榕铭（百度员工写的一本书，案例生动易懂，涉及的设计模式比较全）《JavaScript设计模式与开发实践》-曾琛（腾讯员工写的一本书，讲了js里面更加常用的14个设计模式）《单页Web应用 JavaScript从前端到后端》《ECMAScript 6 入门》可以作为es6新特性文档的一本书，而且这本书开源了（ECMAScript 6 入门），直接看就好！需要的也可以购买！ 《HTML5移动Web开发实战》《HTML5移动Web开发指南》《HTML5 Canvas核心技术》：对于感受canvas的魅力，使用，动画的实现，都非常有帮助。《html5与css3权威指南 第三版》-陆凌牛，这本书貌似有同名的，注意作者，另外该书分上册和下册的。我当时看的是第二版，现在已经出了第三版就推荐第三版了。《锋利的jquery》：我学jquery就是看这本书，这本书给我身边的同行印象不是很好，但是我感觉不错，而且我学jquery就看了这一本书，就推荐这本了！《了不起的Node js 将JavaScript进行到底》《css揭秘》：看了这本书，我再也不敢说自己会css了！里面很多都是你想不到的！ 5.推荐社区我推荐社区虽然有这么多个，但是我注册账号并且活跃的只有两三个，其它的社区基本都是我在学习的时候偶然接触到的，并且觉得不错的，所以也推荐下。至于大家想活跃哪几个社区，就看大家的选择了。如果大家有什么好的社区资源，也不妨推荐下！ github：这个起初我经常在上面找资源。但是没注册账号，但是后来被老大催着注册，就去了。在里面可以阅读别人的代码，向大家学习！稀土掘金：我现在活跃的一个社区，是写文章的一个很好的地方！segmentfault：我现在活跃的一个社区，主打问答，也有文章和讲堂，质量也很不错！知乎：虽然不是单纯的IT社区，但是里面有很多大牛和高质量的专栏！stackoverflow：一个问答社区，基本上各种问题都能在上面获得解答w3cplus：一个前端学习的网站，里面的文章质量都挺不错的，特别是关于CSS(3)的前端网前端乱炖：一个前端文章分享的社区，有很多优秀文章开发者头条前端周刊HTML5梦工场毕业僧慕课网（貌似现在很多视频收费了，以前我看的时候，基本都是免费的）汇智网 6.公众号前端大全 segmentfault 前端之巅 前端早读课 W3cplus 稀土圈 （以上图片来源网络） 7.推荐关注项目github上的项目vuereact（我只接触过几次react，使用起来还不错，现在也正在学习）gulpparcelwebpackd3chart（和d3一样，属于数据可视化方面，体验过。但是在项目上没用过，感觉功能强大，就推荐下）element-ui（基于vue2.x开发的一个组件库，一般用于后台管理系统开发，现在我们公司开发的后台管理就是用这个）muse-ui（同样是基于vue的组件库，ui非常的漂亮）一起学 Node.js（这个其实应该是node.js教程）AlloyTeam移动端手势解决方案frontend-dev-bookmarks（前端各方面的学习清单）免费的编程中文书籍（中文分享书籍，不止前端，各方面都有，大家按需查看）animate.csshover.cssmuse-ui（基于vue2.0的一个UI库，样式漂亮，种类全）CSS3 实现各类3D效果的博客（和下面三个连接同属一个作者，这个大牛的作品不错，效果酷炫，虽然star数量与其它几个推荐项目没法比，但是很值得推荐）chokcoco/boomJSchokcoco/magicCsschokcoco/iCSShandtouchawesome-vueElectronvue-skeleton-webpack-plugin梁少峰的个人博客（里面的文章质量也不错，各种都有，js,jquery,vue,react,node.js等）RxJsdeeplearn（谷歌出版，一个关于人工智能深度学习的框架，有兴趣可以看，我看了一会，没看懂） （下面这两个是我自己的开发的项目，虽然跟其他项目比较欠缺火候，但是还不至于用不了或者拿不出手的地步，也算是我的一个小广告吧！(●’◡’●)）ec-do（封装了日常开发常用的javascript实例，实例为日常开发常用的小实例，包括数组去重，打乱数组，字母大小写转换，cookie操作的封装等。）ec-css（基于css3开发的代码库，包括日常使用的hover过渡效果，动画效果，以及预设动画） 其它推荐项目腾讯css3 ui库NEC : 更好的CSS样式解决方案（网易的一个css3解决方案，但是貌似挺旧了，不维护了，但是里面的案例大家可以参考，绝对有收获） 8.综合项目教程（学习实录）使用node.js + socket.io + redis实现基本的聊天室场景前端开发，从草根到英雄（第一部分）前端开发，从草根到英雄（第二部分）我的前端进阶之路（看着标题以为是杂谈，实际上感觉是一篇总结性文章，大家可以看下）为你的移动页面寻找一丝新意——手机互动网页项目总结（上）为你的移动页面寻找一丝新意——手机互动网页项目总结（下）前端开发指南2017【实战HTML5与CSS3 第一篇】初探水深，美丽的导航，绚丽的图片爆炸！！（看完别忘记下面的，是叶小钗大神仿智能社官网的实战）基于 Vue 2.0 实现的移动端弹窗 (Alert, Confirm, Toast)组件.发现最好的你-设计中如何打造最合适的组件webpack+vue项目实战（一,搭建运行环境和相关配置）（我自己的文章，关于使用vue+webpack开发一个单页应用，一个后台管理系统的开发搭建，这个系列一共有五篇文章） 9.开发杂谈web前端–10个妨碍进步的学习方式前端入行两年–教会了我这些道理关于IT培训机构的个人看法OpenDoc - 前端简历评级标准（美团出的一份简历评级，可以适当参考下，对比下自己的实力和美团评级。当然有兴趣的也可以去面试）前端代码规范及最佳实践Vue.js 很好，但是比 Angular 或 React 更好吗？聊聊技术选型 - Angular2 vs Vue2写给前端工程师看的，移动应用选型指南网站架构-从无到有前端架构那些事儿技术大牛养成指南，一篇不鸡汤的成功学实践6 个值得好好学习的 JavaScript 框架更快学习 JS 的 6 个简单思维技巧程序员怎么学英语8个让程序员追悔莫及的职业建议当心！程序员应警惕七种错误的职业规划1024程序员节，写给年轻程序员的建议给新程序员的10条建议前端框架这么多，该何去何从？2017年前端开发工具趋势现代前端开发技术栈听说2017你想写前端？如何跟上前端开发的最新前沿前端开发人员必须了解的七大技能图谱前端技能汇总（JacksonTian）另一张前端技能汇总图（和上面的一个链接一样，但是看的话，建议大家带参考的思想看）怎样成长为一个优秀的 Web 前端开发工程师？月薪10-12k的前端人员应该具备怎样一种技术水平？作为一名前端开发人员，有哪些值得一读的js代码？不吹不黑聊聊前端框架–尤雨溪Live整理前端开发者指南（2017）为什么一些公司招前端不想要培训班出来的人？前端新人不容易现在Web前端是不是已经饱和了?2017前端技术发展回顾hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一（有兴趣的可以看一下，有用）开放源码的法律面（因为国外对版权，许可证很是注重，该文章就讲代码开源后关于许可证的文章，看得我有点蒙，但是最终整理后，我的开源项目就用MIT） 10.开发经常会接触的网站MDN-web技术文档智图图片压缩在线工具在线制作webp多视通图片转换Base64微信JS-SDK说明文档草料二维码菜鸟教程w3cschool 11.小结好了，我学前端看过的博客文章，关注过的大牛和项目，项目技术栈的教程基本都在这里了！我分享的这些，不敢说最好，最全，适合每个人。但是都是我看过或者接触过的，至少内容上让我满意的，让我觉得是对学习有用的，能帮到大家的。如果大家有什么学习资源推荐的，我也希望大家不吝啬的共享给我，给大家！ 这篇文章，对于大家而言是一个资源的合集，但对于我而言，可能是一个分割线。发完2017最后一篇文章在以后我可能会在务实基础的前提下，注重深入的探究，发的文章可能会比现在的文章深入，文章产量可能不会像现在这么频繁！ 还有一个建议就是，学习web前端，上面分享的可以起到一个引导，指路，解惑的作用。但是，大家不要忘记多练，毕竟实操最重要！大家有空余的时间或者周末也可以自己做下自己有兴趣的项目，并且用在自己工作的项目开发上！项目不求比别人好，只求自己能练习，提升自己的技术水平！ JavaScript]]></content>
      <categories>
        <category>前端, css, 干货</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学者最容易学的六种编程语言]]></title>
    <url>%2F2017%2F06%2F11%2F%E5%88%9D%E5%AD%A6%E8%80%85%E6%9C%80%E5%AE%B9%E6%98%93%E5%AD%A6%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[初学者最容易学的六种编程语言学习编程看起来是一项艰巨的任务，其实不如想象中的那么难学。由于，现在网上有一大批资源可供使用和活跃的社区，以及社交媒体上也有很多专家，现在学习编程要比过去简单得多，就连小孩子都能尽快的学习编程了。 然而，学编程关键是要找到一种合适的语言。下面是为大家介绍初学者，最容掌握的六种编程语言。 1.JavaScript 可别将JavaScript与Java混为一谈。Java是一种可以撰写跨平台应用软件的面向对象的程序设计语言，即使是开发简单的程序，也必须设计对象；而JavaScript是一种直译式脚本语言，它本身提供了非常丰富的内部对象供设计人员使用。JS之所以特别受欢迎，是由于它是跨平台的。由于JS本身在浏览器里面运行，你甚至不需要编译器。只需要一款笔记本应用程序或Sublime Text就可以编写了。 如果，你想从事Web开发，那么JavaScript就是一种出色的入门级语言。对初学者来说，JavaScript是比较宽容和动态类型（弱类型）的编程语言。此外，JS语法类似C的语法，所以学习JS让你可以在编程领域继续深造，比如学习更难的编程语言C++。 不过Matthew Mombrea等一些人士认为，JavaScript实际上是一种糟糕的入门级语言。Mombrea认为，JS是面向对象编程（OOP）方面的就是一个糟糕例子，这一点其实已经路人皆知。另外，虽然JS是弱类型语言并且有助于在编程时提高效率，但是直到运行时才会发现错误。他声称，如果你想要以软件开发为业，JavaScript不是好的起点。但是JS作为通向编程世界的一种入门级语言，它还是个不错的选择。 用途： Web开发 优点： 跨平台兼容 不需要编译器 便于进而学习其他语言 缺点： OOP方面的糟糕例子 弱类型语言 难以调试 2.Ruby on Rails Ruby on Rails最大的优点是易于阅读，这对缺乏编程经验的人更易于掌握。Ruby是一种动态、面向对象的脚本语言，它被大量应用于Web开发。包括Groupon和GitHub在内的网站都在各自的后端上使用Ruby。 由于不需要学习大量命令，Ruby学起来更容易一点。虽然Ruby是一种框架，但是它汇集了Ruby快捷键，并且许多培训班都在教Ruby on Rails。 它对初学者来说堪称完美。此外，正如One Month网站指出的，有许多初创公司在招聘Ruby on Rails开发人员，即便你只有入门级经验，也可能找到一份不错的工作。 用途： Web开发 优点： 广泛使用 汇集快捷键 就业市场看好 缺点： Ruby on Rails基本上是一套快捷键 3.Python Python对初学者来说也是一个入门级编程语言。Python可用于Web开发的应用程序和桌面应用程序，这种动态语言支持OOP编程、过程式编程和函数式编程。 另外，它是开源语言，这意味着它可以免费入手，有着相当活跃的社区。Joel Lee细述了为何Python很有用（http://www.makeuseof.com/tag/reasons-python-programming-not-useless/）。 不过，作为一种入门级编程语言而言，Python有点复杂。比如说，要保持一定的命名和缩进，都是很重要的细节方面。但是考虑到它的灵活性和庞大社区，Python对初学者来说仍是一种易学的编程语言。 用途： Web开发 应用程序开发 优点： 用于桌面和Web程序 开源 缺点： 有特定的要求，比如规范的命令约定 4.Java Java仍是历史最悠久的编程语言之一。Java可谓是Web应用程序、桌面程序、操作系统及更多系统的立足之本。这种面向对象、基于类的编程语言广泛使用；此外，它也是最受欢迎的语言之一。 不过尽管广泛使用、人气超高，但是Java与其他入门级语言相提并论时，显得稍为复杂一点。Java的语法主要来自C和C++之类的语言，所以许多编程学习和强化培训班都是从C/C++开始教起，然后再教Java。如果，你在寻找一些Java应用程序例子？不妨看看这五个网站（http://www.makeuseof.com/tag/top-5-websites-for-java-application-examples/）。 然而，Java也能迫使程序员从程序的角度来思考问题。因此，你必须考虑计算机是如何处理信息的。由于在分析编程知识方面打下坚实的基础，Java对初学者来说仍是一种很棒的编程语言。 用途： Web开发 应用程序开发 优点： 非常流行 一种历史悠久的语言 资源丰富 编程挑战建立了稳定的编程基础 缺点： 语法来自C/C++，所以从C/C++入手可能更好 需要非常注重分析的思维 5.**C/C++** C和C++都是优秀的入门编程语言。另外，借助这些网站（http://www.makeuseof.com/tag/3-websites-started-learning-programming-language/），你可以很快入手C和C++ 。 如果你对游戏开发很有兴趣，C++是一种优秀的入门语言，因为除了Web开发应用程序、移动应用程序和桌面应用程序外，它还经常用于开发游戏和游戏引擎。 C和C++都不仅仅为编程提供了入门知识，还为整个计算机学提供了入门知识。即便你将注意力集中在其他编程语言上，C/C++提供的基础性知识也很有价值。 不过，C++在最初阶段对初学者来说可能颇具挑战性。如果你能够克服这个困难，那么将会大有回报。 用途： 应用程序开发 优点： 出色的计算机学基础 适合软件和游戏开发 缺点： C++要比C难学一点 6.C# C#对初学者来说是个很好的选择。启动时间相当短：只要下载Visual Studio Express，即可全面安装所有必要的元素，比如SQL Express。C#可以用途很多，从Web开发到控制台应用程序等等。语法基于C，所以与C++和C一样，它也提供了出色的计算机学基础。 然而，Visual Studio确实拥有自动完成功能和自动生成的项目文件等方面，C#可能比较复杂，不像在C和Ruby等语言中有多个编译器和解释器。但是C#有易于使用的IDE以及广泛的用途，C#也是初学者学习编程不错的选择。 用途： 应用程序开发 优点： 广泛使用 Visual Studio让启动很简单 出色的计算机学基础 易于使用的IDE 缺点： 复杂的编译器 结束语 本文不见HTML的身影，你可能会问：为什么不介绍这种语言？考虑到HTML学起来极容易，常常很多中学都在教这种语言，实际上，HTML也是本人所学的第一种语言；在短短几小时内，我就由一个菜鸟变成水平相当高。正如许多人所知，HTML是一种标记语言，而不是一种编程语言。所以，很遗憾，它不是完全符合这个标准。 不过，HTML适用于广泛领域，因此，对初学者来说HTML是一种简易的语言（不是编程语言），HTML还是值得一提。HTML广泛用于Web开发，因此你可以在此基础上学习CSS （与HTML一样，CSS同样不是一种真正的编程语言），最后再学习像JavaScript这些标准的编程语言。 你认为哪些编程语言对初学者来说最容易？欢迎留言交流，也欢迎告知你的第一种语言是什么。 原文标题：6 Easiest Programming Languages to Learn for Beginners 作者：Moe Long]]></content>
      <categories>
        <category>技术</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js执行机制]]></title>
    <url>%2F2017%2F06%2F08%2F%E8%BF%99%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20JavaScript%20%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前端这一次，彻底弄懂 JavaScript 执行机制本文的目的就是要保证你彻底弄懂javascript的执行机制，如果读完本文还不懂，可以揍我。 不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论： javascript是按照语句出现的顺序执行的 看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的：12345let a = '1';console.log(a);let b = '2';console.log(b); 然而实际上js是这样的： 1234567891011121314setTimeout(function()&#123; console.log('定时器开始啦')&#125;);new Promise(function(resolve)&#123; console.log('马上执行for循环啦'); for(var i = 0; i &lt; 10000; i++)&#123; i == 99 &amp;&amp; resolve(); &#125;&#125;).then(function()&#123; console.log('执行then函数啦')&#125;);console.log('代码执行结束'); 依照js是按照语句出现的顺序执行这个理念，我自信的写下输出结果： 1234//&quot;定时器开始啦&quot;//&quot;马上执行for循环啦&quot;//&quot;执行then函数啦&quot;//&quot;代码执行结束&quot; 去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？ 我们真的要彻底弄明白javascript的执行机制了。 1.关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ 2.javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明： 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 说了这么多文字，不如直接一段代码更直白： 123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log('发送成功!'); &#125;&#125;)console.log('代码执行结束'); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(&#39;代码执行结束&#39;)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 3.又爱又恨的setTimeout大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行： 123setTimeout(() =&gt; &#123; console.log('延时3秒');&#125;,3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？ 先看一个例子： 1234setTimeout(() =&gt; &#123; task();&#125;,3000)console.log('执行console'); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12//执行console//task() 去验证一下，结果正确！然后我们修改一下前面的代码： 12345setTimeout(() =&gt; &#123; task()&#125;,3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明： 12345//代码1console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,0); 12345//代码2console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,3000); 代码1的输出结果是： 12//先执行这里//执行啦 代码2的输出结果是： 123//先执行这里// ... 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 4.又恨又爱的setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 5.Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。 Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明： 1234567891011setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise');&#125;).then(function() &#123; console.log('then');&#125;)console.log('console'); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。 事件循环，宏任务，微任务的关系如图所示： 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 宏任务Event Queue 微任务Event Queue process3 then3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 6.写在最后(1)js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 (2)事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 (3)javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 (4)setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 (5)最后的最后 javascript是一门单线程语言 Event Loop是javascript的执行机制 牢牢把握两个基本点，以认真学习javascript为中心，早日实现成为前端高手的伟大梦想！]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>技巧</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json与jsonp区别浅析]]></title>
    <url>%2F2017%2F05%2F18%2Fjson%E4%B8%8Ejsonp%E5%8C%BA%E5%88%AB%E6%B5%85%E6%9E%90%EF%BC%88json%E6%89%8D%E6%98%AF%E7%9B%AE%E7%9A%84%EF%BC%8Cjsonp%E5%8F%AA%E6%98%AF%E6%89%8B%E6%AE%B5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前端标签： 干货 json与jsonp区别浅析（json才是目的，jsonp只是手段）一言以蔽之，json返回的是一串数据；而jsonp返回的是脚本代码（包含一个函数调用）； JSON其实就是JavaScript中的一个对象，跟var obj={}在质上完全一样，只是在量上可以无限扩展。简单地讲，json其实就是JavaScript中的对象(Object)和数组(Array，其实也是对象)这倆好基友在那儿你嵌我我嵌你地套上n多层，以此模拟出许多复杂的数据结构。 json易于人阅读和编写，也易于机器解析和生成，相对网络传输速率较高，功能型网站前后端往往要频繁大量交换数据，而json凭借其强大的表现力和高颜值渐渐地成为理想的前后端数据交换语言。那xml前辈呢，我觉得应该会像微软的xp那样功成身退。 同源（不懂同源策略的童鞋请自行百度）下的前后端数据交换格式确定使用json了，那么问题来了，如果我想获取别人网站上提供的数据肿么做到呢？也就是跨域读取数据问题（不要钻牛角说你不需要读取其他网站的数据，相信我，你早晚得需要），json行不行呢？答案是No Way，为什么呢，因为json只是普通的文本格式，能让你这样就轻松拿到那服务端就没有任何安全和保密性可言了，这样的话互联网世界非乱套不可，这个问题那些牛X的规范制定者早就想到了，所以使用了同源策略来限制文件获取。最后的结果就是只有像img、script、iframe这类可以指定src属性的标签有跨域获取别人网站上数据（图片，脚本，源文件其实都是数据）的能力。比如： 1234&lt;!--京东商品图片--&gt;&lt;img src=&quot;http://img30.360buyimg.com/jgsq-productsoa/jfs/t2407/323/1635505465/47386/f2d89d88/56615e00N7a475ee6.jpg&quot; /&gt;&lt;!--百度CDN--&gt;&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; 看来直接获取json是行不通了，那有没有其他方法能拿到数据呢？于是乎jsonp就这样被聪明的开发者给发现了，为什么说是发现而不是发明呢，因为并没有涉及到任何新技术，就像发现ajax一样。 jsonp原理是这样的，网站A需要获取网站B的数据，网站B说我给你们一个方法，【1. 你们使用标签先获取到open.js文件（网站B的责任），这里边有你们需要的数据。2. 你们获取数据后处理数据（总得处理数据吧）的方法名必须命名为foo（数据请求者的责任和义务）】，这里相当于B网站和请求获取数据者之间建立了一个协议，要求请求者务必按照规则办事，如果请求者不能同时遵守上面两条就不能按预期获取数据。额..，这也算相当于建立了一个潜规则吧 open.js内容 123foo(&#123;&quot;name&quot;:&quot;B&quot;,&quot;age&quot;:23&#125;); //为什么不直接写成json数据&#123;&quot;name&quot;:&quot;B&quot;,&quot;age&quot;:23&#125;呢，原因很简单，在js文件总得合乎js语法吧//这也是为什么协议中明确规定处理数据的方法名必须命名为foo，因为B网站是在假定请求者的脚本中已经定义了数据处理方法foo的情况下返回数据；//不然就会报foo is not defined错误 网站A脚本须有 1234function foo(data)&#123; console.log(data); //ToDo.. &#125; 啊！虽然拐了个弯，但数据总算得到了，网站A，网站B都非常高兴，那么问题又来了，网站C说也需要获取网站B的数据，网站B把协议甩给它，网站C拿过来一看，草泥马啊，foo这个名字已经在自己的脚本文件的6868行用过了，而且已经使用在脚本的各个角落，批量替换会导致很多潜在bug啊，网站B情急之下决定把foo改成fool，网站A立马蹦起来，因为自己的网站已经在很多地方使用foo引用了数据。 为了避免上面情况发生，那些牛X哄哄的开发者使用了动态生成js文件的方法，php版本如下： open.php ;) 123456&lt;?phpheader(&apos;Content-type: application/javascript&apos;);$jsonCallback = htmlspecialchars($_REQUEST [&apos;callback&apos;]); //获取请求者自定义的回调函数名$jsonData =&apos;&#123;&quot;name&quot;:&quot;B&quot;,&quot;age&quot;:23&#125;&apos;; //待返回的json数据echo $jsonCallback . &quot;(&quot; . $jsonData . &quot;)&quot;; //输出jsonp格式的数据，即一行函数调用语句?&gt; ;) 额 ..，至于php为什么能返回js格式文件，自行百度。于是网站A用来请求数据，不需要修改任何变量，返回给A的脚本文件内容是： 1foo(&#123;&quot;name&quot;:&quot;B&quot;,&quot;age&quot;:23&#125;); //所谓的jsonp，就是一句函数调用，数据都被包裹传递到参数中了，千万别穿个马甲就不认识了 网站C就用来请求数据，返回给C的脚本文件内容是： 1blah(&#123;&quot;name&quot;:&quot;B&quot;,&quot;age&quot;:23&#125;); 网站N就用来请求数据，返回给N的脚本文件内容是： 1what(&#123;&quot;name&quot;:&quot;B&quot;,&quot;age&quot;:23&#125;); Problem Solved，大家都取到了期望的数据，并且避免了命名冲突。 jsonp全名叫做json with padding，很形象，就是把json对象用符合js语法的形式包裹起来以使其它网站可以请求得到，也就是将json数据封装成js文件； json是理想的数据交换格式，但没办法跨域直接获取，于是就将json包裹(padding)在一个合法的js语句中作为js文件传过去。这就是json和jsonp的区别，json是想要的东西，jsonp是达到这个目的而普遍采用的一种方法，当然最终获得和处理的还是json。所以说json是目的，jsonp只是手段。json总会用到，而jsonp只有在跨域获取数据才会用到。 理解了json和jsonp的区别之后，其实ajax里的跨域获取数据就很好理解和实现了，同源时候并没有什么特别的，直接取就行，跨域时候需要拐个弯来达到目的。 附上jquery中ajax请求json数据实例： （同源）： ;) 1234567$.ajax(&#123; url:&quot;persons.json&quot;, success:function(data)&#123; console.log(data); //ToDo.. &#125;&#125;); ;) （跨域） ;) 12345678$.ajax(&#123; url:&quot;http://www.B.com/open.php?callback=?&quot;, dataType:&quot;jsonp&quot;, success:function(data)&#123; console.log(data); //ToDo.. &#125;&#125;); ;) jquery已把jsonp封装进ajax，很合理，因为毕竟绝大多数的jsonp请求都是ajax，关于jquery的ajax具体用法请自行百度，另外要注意的一点就是不同的网站提供的数据接口的$_REQUEST [‘callback’]中不一定绝对是callback也可能是cb,cbk等，具体使用时务必阅读服务端提供的有关接口使用的详细文档。]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 实用技巧和写法建议]]></title>
    <url>%2F2017%2F05%2F14%2FJavaScript%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E5%92%8C%E5%86%99%E6%B3%95%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[前端标签： 干货 JavaScript 实用技巧和写法建议1.前言从大学到现在，接触前端已经有几年了，感想方面，就是对于程序员而言，想要提高自己的技术水平和编写易于阅读和维护的代码，我觉得不能每天都是平庸的写代码，更要去推敲，去摸索和优化代码，总结当中的技巧，积极听取别人的建议，这样自己的技术水平会提高的更快。那么今天，我在这里就分享一下关于javascript方面的写作的实用技巧和建议，这些技巧和建议是我平常在开发项目上会用到的，希望能让大家学到知识，更希望能起到一个交流意见的作用，也就是说大家有什么好的技巧或者建议，欢迎分享，或者觉得我的想法存在什么问题，欢迎指出! 2.更短的数组去重写法123[...new Set([2,&quot;12&quot;,2,12,1,2,1,6,12,13,6])]//[2, &quot;12&quot;, 12, 1, 6, 13]//es6的新特性 3.对象深浅拷贝关于对象的深浅拷贝，我个人见解就是有一下几点： 1.深拷贝和浅拷贝只针对像Object, Array这样的引用类型数据。 2.浅拷贝是对对象引用地址进行拷贝，并没有开辟新的栈，也就是拷贝后的结果是两个对象指向同一个引用地址，修改其中一个对象的属性，则另一个对象的属性也会改变。 3.深拷贝则是开启一个新的栈，两个对象对应两个不同的引用地址，修改一个对象的属性，不会改变另一个对象的属性。 浅拷贝1var myInfo=&#123;name:&apos;守候&apos;,sex:&apos;男&apos;&#125;; 1var newInfo=myInfo; 1newInfo.sex=&apos;女&apos;; 1console.log(myInfo) //&#123;name: &quot;守候&quot;, sex: &quot;女&quot;&#125; 假-深拷贝假-深拷贝这个是自己随性命名的，大家看看就好，别当真！ 1var myInfo=&#123;name:&apos;守候&apos;,sex:&apos;男&apos;&#125;; 1var newInfo=Object.assign(&#123;&#125;,myInfo) 1newInfo.sex=&apos;女&apos;; 12console.log(myInfo) //&#123;name: &quot;守候&quot;, sex: &quot;男&quot;&#125;console.log(newInfo) //&#123;name: &quot;守候&quot;, sex: &quot;女&quot;&#125; 真-深拷贝真-深拷贝这个是自己随性命名的，大家看看就好，别当真！ 看着深浅拷贝，区别写法很简单，但是那个上面的深拷贝写法是有问题的。看下面案例 12345678910var arr=[&#123;a:1,b:2&#125;,&#123;a:3,b:4&#125;]var newArr=Object.assign([],arr)//截断数组newArr.length=1console.log(newArr)//[&#123;a:1,b:2&#125;]console.log(arr)//[&#123;a:1,b:2&#125;,&#123;a:3,b:4&#125;]//操作newArr，这里看着对arr没影响，实际上已经挖了一个坑，下面就跳进去newArr[0].a=123//修改newArr[0]这个对象，也是影响了arr[0]这个对象console.log(arr[0])//&#123;a: 123, b: 2&#125; 为什么会这样呢，因为Object.assign并不是深拷贝，是披着深拷贝外衣的浅拷贝。最多也是Object.assign会课拷贝第一层的值，对于第一层的值都是深拷贝，而到第二层的时候就是 复制引用。类似的情况还有，slice方法和concat方法等。要解决这个问题，就得自己封装方法！如下 123456789101112131415161718192021222324//利用递归来实现深拷贝，如果对象属性的值是引用类型（Array,Object），那么对该属性进行深拷贝，直到遍历到属性的值是基本类型为止。 function deepClone(obj)&#123; if(!obj&amp;&amp; typeof obj!== &apos;object&apos;)&#123; return; &#125; var newObj= obj.constructor === Array ? [] : &#123;&#125;; for(var key in obj)&#123; if(obj[key])&#123; if(obj[key] &amp;&amp; typeof obj[key] === &apos;object&apos;)&#123; newObj[key] = obj[key].constructor === Array ? [] : &#123;&#125;; //递归 newObj[key] = deepClone(obj[key]); &#125;else&#123; newObj[key] = obj[key]; &#125; &#125; &#125; return newObj; &#125;var arr=[&#123;a:1,b:2&#125;,&#123;a:3,b:4&#125;]var newArr=deepClone(arr)console.log(arr[0])//&#123;a:1,b:2&#125;newArr[0].a=123console.log(arr[0])//&#123;a:1,b:2&#125; 还有一个方法就是简单粗暴法，我现在在用的一个方法！原理很简单，就是先把对象转成字符串，再把字符串转成对象！也能实现同样效果 1234var newArr2=JSON.parse(JSON.stringify(arr));console.log(arr[0])//&#123;a:1,b:2&#125;newArr2[0].a=123console.log(arr[0])//&#123;a:1,b:2&#125; 上面所说的浅拷贝，真假深拷贝（自己随性命名的），这几种情况，在开发上都有可能要用到，至于要使用哪一种方式，视情况而定！ 4.使用事件委托一个简单的需求，比如想给ul下面的li加上点击事件，点击哪个li，就显示那个li的innerHTML。这个貌似很简单！代码如下！ 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;ul-test&quot;&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var oUl=document.getElementById(&quot;ul-test&quot;); var oLi=oUl.getElementsByTagName(&quot;li&quot;); for(var i=0,len=oLi.length;i&lt;len;i++)&#123; oLi[i].addEventListener(&quot;click&quot;,function()&#123; alert(this.innerHTML) &#125;) &#125; &lt;/script&gt;&lt;/html&gt; 很简单，这样就实现了，实际上这里有坑，也待优化！1.for循环，循环的是li，10个li就循环10次，绑定10次事件，100个就循环了100次，绑定100次事件！2.如果li不是本来就在页面上的，是未来元素，是页面加载了，再通过js动态加载进来了，上面的写法是无效的，点击li是没有反应的！所以就者需要用事件委托（即使不考虑上面的第二种情况，也是建议使用事件委托）！代码如下 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;ul-test&quot;&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var oUl=document.getElementById(&quot;ul-test&quot;); oUl.addEventListener(&quot;click&quot;,function(ev)&#123; var ev=ev||window.event; var target=ev.target||ev.srcElement; //如果点击的最底层是li元素 if(target.tagName.toLowerCase()===&apos;li&apos;)&#123; alert(target.innerHTML) &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 这样写，即使是动态添加进来的li点击也有反应，还有一个就是ul只有一个，事件绑定在ul上，无论li多少个，都是添加一次事件！但是也是可能会有问题，如果li下面还有子元素，那么点击的时候，target可能不是li，而是鼠标点击那个位置的最底层元素！如下图，如果鼠标点击白色区域，那个target就是body元素,鼠标点击绿色区域target就是div元素，鼠标点击蓝色区域target就是ul，点击橙色就是li。 5.使用对象作为函数参数大家试想下这样一个函数–函数接受几个参数，但是这几个参数都不是必填的，函数该怎么处理？是不是下面这样 12345function personInfo(name,phone,card)&#123; ...&#125;//以上函数，可以任意传参数。比如我想传card等于1472586326。这下是不是这样写personInfo(&apos;&apos;,&apos;&apos;,&apos;1472586326&apos;) 有没有觉得上面写法奇怪，不太优雅？下面这里看着舒服一点！ 1234function personInfo(opt)&#123; ...&#125;personInfo(&#123;card:&apos;1472586326&apos;&#125;) 再想一下，如果一个函数，参数很多，怎么处理？ 123function test(arg1,arg2,arg3,arg4,arg5,arg6,arg7)&#123; ...&#125; 密集恐惧症复发没有复发？下面这样看着会舒服一点！ 123function personInfo(opt)&#123; ...&#125; 最后再想一下，如果需求改了，操作函数也要改！函数也要增加一个参数。 12345678//原来函数function personInfo(name,phone,card)&#123; ...&#125;//修改后function personInfo(name,age,phone,card)&#123; ...&#125; 这样就是参数修改一次，函数的参数就要修改一次！如果是用对象，就不会出现这样问题！ 1234//修改前后都是这样，变得是函数的操作内容和调用时候的传参！function personInfo(opt)&#123; ...&#125; 看了上面的几个栗子，总结来说，就是当函数的参数不固定的时候，参数多(三个或者三个以上)的时候，建议用一个对象记录参数，这样会比较方便，也为以后如果参数要改留了条后路！ 6.使用push和apply合并数组合并数组这个已经是老生常谈的话题了，方法也是多种多样！ concat123var arr1=[1,2,3,4,5],arr2=[6,7,8,9,10];arr1=arr1.concat(arr2)console.log(arr1)//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] concat会一个全新的数组，表示arr1和arr2两个数组的组合，并让arr1和arr2不变。简单吧？但如果arr1和arr2的长度都很长，那就产生了一个很长很长的数组，内存又被占用了那么多。但是数组长度没限制！ for12345var arr1=[1,2,3,4,5],arr2=[6,7,8,9,10];for(var i=0,len=arr2.length;i&lt;len;i++)&#123; arr1.push(arr2[i])&#125;console.log(arr1)//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 这里是往arr1循环添加arr2的元素，但是有一个情况，arr1的长度远小于arr2的长度，是不是循环arr1性能更好，循环次数更少。处理这个很简单，但是万一不知道arr1和arr2到底哪个长度更少呢？而且，for循环不够优雅！（当然，这个可以用迭代方法来替代） reduce123456var arr1=[1,2,3,4,5],arr2=[6,7,8,9,10];arr1 = arr2.reduce( function(coll,item)&#123; coll.push( item ); return coll; &#125;, arr1 ); console.log(arr1)//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 逼格高了一点，而且用ES6的箭头函数还可以减少一些代码量，但它仍然需要一个函数，每个元素都需要调用一次。 push.apply123var arr1=[1,2,3,4,5],arr2=[6,7,8,9,10];arr1.push.apply(arr1,arr2);console.log(arr1)//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 逼格看着高，代码少，也不会产生新的数组，也不难理解，就是调用arr1.push这个函数实例的apply方法，同时把arr2当作参数传入，这样arr1.push这个方法就会遍历arr2数组的所有元素，达到合并的效果。相当于arr1.push.apply(arr1,[6,7,8,9,10]);，最后相当于arr1.push(6,7,8,9,10)。遗憾的就是，这个方法对数组长度有限制，网上说法是不同浏览器，不同的长度限制，一般不超过10万！ 之前是建议用push.apply，但是现在保留意见，就是大家觉得哪个方式用哪个方式！这个没有一定的对错！ 7.toFixed保留整数在开发上，经常会遇到最多保留多少位小数或者类似的问题，针对这个，使用toFixed可以很简单的解决问题，但是如果数据是要和后台交互的，而且后台存储的数据一般是保存数字类型，而使用toFixed后生成的是一个字符串，这下，就需要把toFixed生成的是一个字符串转成数字类型，转发很多。今天我说一个最简单–+。代码如下 1234var a=123.36896335.toFixed(2)console.log(a)//&apos;123.37&apos;a=+aconsole.log(a)//123.37 PS：a=a|0和~~a也可以实现，但是生成的是一个整数，如下 123456789var a=123.36896335.toFixed(2)console.log(a)//&apos;123.37&apos;a=a|0 console.log(a)//123 //---------------------------------分割线var a=123.36896335.toFixed(2)console.log(a)//&apos;123.37&apos;a=~~a console.log(a)//123 8.其它类型数据转布尔数据下面的转换，大家一看就明白了，不多说。 123456789101112console.log(!!&apos;123&apos;)//true!!12//true!!-1//true!![]//true!!&apos;&apos;//false!!null//false 9.缓存变量for循环缓存length123456789var arr=[1,2,3,4,5,6]for(var i=0,i&lt;arr.length;i++)&#123; ...&#125;//------------------------分割线var arr=[1,2,3,4,5,6]for(var i=0,len=arr.length;i&lt;len;i++)&#123; ...&#125; 第一段就是每一次循环的时候，都要查询一次arr.length。第二段代码就是缓存了arr.length，每次对比len就好，理论上是第二段代码的写法比较好，性能比较高！但是随着浏览器的发展，这个细节的性能上的影响貌似远远小于预期，现在还是建议缓存！我写了下面的测试用例(谷歌浏览器测试)！ 12345678910111213141516171819202122232425262728var arr100=[], arr10000=[];for(var i=0;i&lt;100;i++)&#123; arr100.push(i)&#125;for(var i=0;i&lt;10000;i++)&#123; arr10000.push(i)&#125;//缓存情况function testCache(arr)&#123; console.time(); for(var i=0,len=arr.length;i&lt;len;i++)&#123; &#125; console.timeEnd()&#125;//不缓存情况function testNoCache(arr)&#123; console.time(); for(var i=0,len=arr.length;i&lt;len;i++)&#123; &#125; console.timeEnd()&#125;testCache(arr100)//default: 0.007mstestCache(arr10000)//default: 0.035mstestNoCache(arr100)//default: 0.012mstestNoCache(arr10000)//default: 0.109ms//这只是一个最简单的数组，如果遍历的是一个nodeList（元素列表），效果可能会更明显。 元素事件这里我用jquery来讲解，比较容易理解，原生js也是这个道理！如下代码 12345678$(&apos;.div1&apos;).click(function()&#123; ...&#125;)//--------------------------分割线 var $div1=$(&apos;.div1&apos;);$div1.click(function()&#123; ...&#125;) 上面的代码，改变的也是缓存了$(‘.div1’)，但是这里就建议是第二种写法了，因为第一种点击一次就要查询一次.div1，Dom的操作还是能减少就减少！ 10.使用innerHTML添加元素比如有一个需求，往ul里面添加10个li，两种方法，如下代码 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;ul-test&quot;&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var oUl=document.getElementById(&quot;ul-test&quot;); //createElement方式 console.time(); for(var i=0;i&lt;10;i++)&#123; var oLi=document.createElement(&apos;li&apos;); oLi.innerHTML=i; oUl.appendChild(oLi); &#125; console.timeEnd(); //innerHTML方式 console.time(); var _html=&apos;&apos;; for(var i=0;i&lt;10;i++)&#123; _html+=&apos;&lt;li&gt;&apos;+i+&apos;&lt;/li&gt;&apos; &#125; oUl.innerHTML=_html; console.timeEnd(); &lt;/script&gt;&lt;/html&gt; 大家把代码用浏览器打开，发现基本是第二种方式更快，第8点也说了，DOM操作能少就少！第一种要操作10次DOM，第二种只需要操作1次DOM。还有一个就是，这个只是很简单的li,如果是下面的列表呢？用第一种方式，得createElement多少次，innerHTML多少次，appendChild多少次？代码多，各个节点的逻辑和嵌套关系也乱！用第二种方式就是一个拼接字符串的操作，比第一种方式好多了，如果用es6的模板字符串，就更简单了！ 11.将参数转成数组函数里的arguments，虽然拥有length属性，但是arguments不是一个数组，是一个类数组，没有push,slice等方法。有些时候，需要把arguments转成数组，转的方法也不止一个，推荐的是是下面的写法！ 1var _arguments=Array.prototype.slice.apply(arguments) 12.函数节流这里拿一个栗子说，比如mousemove,onscroll,onresize这些事件触发的时候，可能已经触发了60次事件，这样很消耗性能，而且实际上，我们并不需要这么频繁的触发，只要大约100毫秒触发一次就好！那么这样就需要函数节流了！ 普通写法 12345678var count = 0;function beginCount() &#123; count++; console.log(count);&#125;document.onmousemove = function () &#123; beginCount();&#125;; 效果 节流写法 1234567891011121314var count = 0;function beginCount() &#123; count++; console.log(count);&#125;function delayFn(method, thisArg) &#123; clearTimeout(method.props); method.props = setTimeout(function () &#123; method.call(thisArg) &#125;,100)&#125;document.onmousemove = function () &#123; delayFn(beginCount)&#125;; 效果 这种方式，其实是有问题的，在不断触发停下来等待100ms才开始执行，中间操作得太快直接无视。于是在网上找到下面这种方案！ 第二种节流写法 12345678910111213141516171819202122232425262728293031function delayFn2 (fn, delay, mustDelay)&#123; var timer = null; var t_start; return function()&#123; var context = this, args = arguments, t_cur = +new Date(); //先清理上一次的调用触发（上一次调用触发事件不执行） clearTimeout(timer); //如果不存触发时间，那么当前的时间就是触发时间 if(!t_start)&#123; t_start = t_cur; &#125; //如果当前时间-触发时间大于最大的间隔时间（mustDelay），触发一次函数运行函数 if(t_cur - t_start &gt;= mustDelay)&#123; fn.apply(context, args); t_start = t_cur; &#125; //否则延迟执行 else &#123; timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125; &#125;;&#125;var count=0;function fn1()&#123; count++; console.log(count)&#125; //100ms内连续触发的调用，后一个调用会把前一个调用的等待处理掉，但每隔200ms至少执行一次document.onmousemove=delayFn2(fn1,100,200) 我现在函数节流用得很少，这两个写法是比较基础的，希望大家能共享下自己的比较好的方法！ 13.其他写作建议关于其它的一些写法技巧和建议，都是比较老生常谈的，比如命名规范，函数单一性原则等。这一部分内容我自己总结和别人写的基本一致！我就不展开说了（感觉展开说也基本是复制粘贴别人的文章，这事我不干），所以我推荐大家去看这篇文章（如何优雅的编写 JavaScript 代码）。有些知识我也是从这里获得的！ 14.小结好了，关于我自己总结的一些实用技巧和建议，就到这里了！关于javascript的技巧和建议，这点大家还是要多看网上的资源，也要自己多总结，毕竟我自己总结的只是我自己发现的，只是冰山一角。但还是希望这篇文章能帮到大家，让大家学习到知识。当然，更希望的是能起到一个交流意见的作用。如果大家有什么建议，技巧。也欢迎分享。觉得我哪里写错了，写得不够好，也欢迎指出！让大家一起互相帮助，互相学习！]]></content>
      <categories>
        <category>编程, 前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA设置]]></title>
    <url>%2F2017%2F05%2F08%2FIDEA%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[idea标签： 设置 先来看一些idea文件目录 IntelliJ IDEA 的安装目录并不复杂，上图为最常改动的 bin 目录，经常会改动的文件或是必须介绍就是如图红色框中的几个。 idea.exe 文件是 IntelliJ IDEA 32 位的可行执行文件，IntelliJ IDEA 安装完默认发送到桌面的也就是这个执行文件的快捷方式。 idea.exe.vmoptions 文件是 IntelliJ IDEA 32 位的可执行文件的 VM 配置文件，具体配置修改会下面进行专门讲解。 idea64.exe 文件是 IntelliJ IDEA 64 位的可行执行文件，要求必须电脑上装有 JDK 64 位版本。64 位的系统也是建议使用该文件。 idea64.exe.vmoptions 文件是 IntelliJ IDEA 64 位的可执行文件的 VM 配置文件，具体配置修改会下面进行专门讲解。 idea.properties 文件是 IntelliJ IDEA 的一些属性配置文件，具体配置修改会下面进行专门讲解。 不管你使用的是哪个操作系统，IntelliJ IDEA 的设置目录命名是统一的、有规律：大家没设置的话应该是C:\Users\你的用户名\.IntelliJIdea2017.2的设置目录，其他版本道理一样。 在三大主流的操作系统上该文件夹都在当前用户的 Home 目录，Windows 上即%userprofile%，Linux 和 Mac 上即 ~ 对于这个设置目录有一个特性，就是你删除掉整个目录之后，重新启动 IntelliJ IDEA 会再自动帮你再生成一个全新的默认配置，所以很多时候如果你把 IntelliJ IDEA 配置改坏了，没关系，删掉该目录，一切都会还原到默认，我是很建议新人可以多自己摸索 IntelliJ IDEA 的配置，多几次还原，有助于加深对 IntelliJ IDEA 的了解。 config 目录是 IntelliJ IDEA 个性化化配置目录，或者说是整个 IDE 设置目录。也是我个人认为最重要的目录，没有之一，如果你还记得安装篇的介绍的时候，安装新版本的 IntelliJ IDEA 会自动扫描硬盘上的旧配置目录，指的就是该目录。这个目录主要记录了：IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等等个性化的设置。 system 目录是 IntelliJ IDEA 系统文件目录，是 IntelliJ IDEA 与开发项目一个桥梁目录，里面主要有：缓存、索引、容器文件输出等等，虽然不是最重要目录，但是也是最不可或缺目录之一。 上图是 64 位可执行文件的 JVM 配置文件内容，如果你是 32 位的系统你应该修改的是 idea.exe.vmoptions 文件里面的内容，但是由于 32 位系统内存一般都是 2G 左右的，所以也没有多大空间可以调整，所以一般无需调整的。 修改的原则主要是根据自己机器的内存情况来判断的，我个人是建议 8G 以下的机子或是静态页面开发者都是无需修改的。如果你是开发大型项目、Java 项目或是 Android 项目，并且内存大于 8G，建议进行修改，常修改的就是下面 4 个参数，我这里主要以我的机子会例进行建议，每个人机子情况不一，这里也只是做一个引子，最好的调整方式是你可以根据 jconsole 这类工具进行观察后个性化调整。 强烈推荐使用 IDEA 自带菜单中的Help -&gt; Edit Custom VM Options 来进行个性化配置，而不是直接修改安装目录中的该文件！ -Xms128m，16 G 内存的机器可尝试设置为 -Xms512m -Xmx750m，16 G 内存的机器可尝试设置为 -Xmx1500m -XX:MaxPermSize=350m，16G 内存的机器可尝试设置为 -XX:MaxPermSize=500m -XX:ReservedCodeCacheSize=225m，16G 内存的机器可尝试设置为-XX:ReservedCodeCacheSize=500m 上图是 IntelliJ IDEA 一些属性配置，没有 32 位和 64 位之分，修改原则主要根据个人对 IntelliJ IDEA 的个性化配置情况来分析。强烈推荐在阅读了安装目录中的带注释的配置文件后，使用 IDEA 自带菜单中的 Help -&gt; Edit Custom Properties 来进行个性化配置！常修改的就是下面 4 个参数： *idea.config.path=${user.home}/.IntelliJIdea/config，该属性主要用于指向 IntelliJ IDEA 的个性化配置目录，默认是被注释，打开注释之后才算启用该属性，这里需要特别注意的是斜杠方向，这里用的是正斜杠。 idea.system.path=${user.home}/.IntelliJIdea/system，该属性主要用于指向 IntelliJ IDEA 的系统文件目录，默认是被注释，打开注释之后才算启用该属性，这里需要特别注意的是斜杠方向，这里用的是正斜杠。如果你的项目很多，则该目录会很大，如果你的 C 盘空间不够的时候，还是建议把该目录转移到其他盘符下。 idea.max.intellisense.filesize=2500，该属性主要用于提高在编辑大文件时候的代码帮助。IntelliJ IDEA 在编辑大文件的时候还是很容易卡顿的。 idea.cycle.buffer.size=1024，该属性主要用于控制控制台输出缓存。有遇到一些项目开启很多输出，控制台很快就被刷满了没办法再自动输出后面内容，这种项目建议增大该值或是直接禁用掉，禁用语句 idea.cycle.buffer.size=disabled。]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大前端工具集]]></title>
    <url>%2F2017%2F05%2F08%2F%E5%A4%A7%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[大前端工具集 这个项目的定位是 大前端程序猿的百宝箱。主要针对 前端方向和 Node 方向；主要内容是国内外优秀的库、工具、套路、设计 / 交互或关注的前端组织 / 博客等等，反正用瑞士军刀 来总结这篇文章再合适不过了。 对于列在这里的几乎所有项目，我都有去实践与了解，所以我会尽量给出中肯的建议和理解，也希望大家能多关注我的评语 :) 目录 前端 [大前端工具集 正文 -这里介绍些有特色且前端有必要知道的包 -背景 -说说目标 -您可以通过以下方式联系到我： License 正文前端组织/前端博客 虽混过外企俩家，但劳资英文这项的技能点还是灰色的 …so，俺关注的站点主要以中文为主 GitHub - 没 Github 都不好意思面基有木有！！！ MDN - 无数的资源再等着你探索，追标准和新特性肯定得关注的网站 Awesomes.cn - 国人维护的前端资源库，深度对接到Github，分类和展现清晰，值得收藏 如何跟上前端开发的最新前沿 - RT，不解释 慕课 - 大量的在线计算机课程。 虽然初、中级居多，但是不乏有巨作值得细细品尝 阮一峰 - 关注多年，拜读其ES6 系列。虽网传靠写书进鸟阿里，但博客内容确实够丰富 W3Cplus - 大漠 (《图解 CSS3》作者 ) 在国内的影响力杠杠的，Sass 专家级 淘宝前端团队 - 内容涵盖 Web 和 Node，要深度有深度，要广度有广度 奇舞团博客 - 坚持是最宝贵的，别人的奇舞周刊早已经过百期了 大搜车前端 - 前端网红小芋头君 所在的团队，文章质量高，尤其是 Node 方向的 百度 FEX - 代表作FIS、UEditor、WebUploader、KityMinder 腾讯全端 AlloyTeam - 腾讯 Web 前端团队，博客真的有点丑 … 粉丝日志 for 张丹 - 大爱作者写的 Node 系列 张鑫旭 - 成名多年的、高产的前端大湿，CSS猛人 博客搭建 Hexo - 快速、简洁且高效的博客框架，照着文档分分钟就可以在本地跑起来。Github 地址 :Hexo Jekyll - 将纯文本转化为静态网站和博客。由于环境依赖的问题，所以安装起来可能稍费劲那么一点。Github 地址：Jekyll GithubPages - 免费的静态站点。配合着 Hexo 或Jekyll 的模板，分分搭建出一套炫酷的个人博客 Tumblr - 轻博客的祖师爷，各种各样的主题感觉不错 Wordpress - 这玩意古老到都不想介绍 使用 Hexo/Jekyll + GitPage，前端搭建静态博客那是相当 easy。用 Markdown 写文章做记录，再 push 到 Github 上，分分钟高大上有木有 再推荐三款视觉效果极佳的 Hexo 主题，且在 Github 上的 star 都很不错： NexT Yilia Tranquilpeak 不能偏心，所以也推荐三款 Jekyll 的好主题： So Simple 如果你看过俺的博客，对这个主题就肯定不会陌生啦 HPSTR 当初fefork 差点选这个主题 :) beautiful HTML 纯 HTML 相关其实没有好玩的项目，所以这儿展示的内容主要都是一些模板，而且以下列出来的都是免费的，方便拿取搭架后台或者博客 HEAD - 最全的 &lt;head&gt; 列表，真心佩服这种偏执的整理能力 blur-admin - 视觉冲击极强的管理后台，各种动画效果。PS ：因为团队有ant-design的使用经验，感觉使用起来不是很顺畅，这套后台又是基于AngularJS，所以再三权限之后还是没实际使用，劳资还是别给团队添乱了，囧 … AdminLTE - 很小清新的后台模板，每次看preview 页面都觉得很有视觉冲击 gentelella - 刚用这个搭建了我司内部用的的数据平台，效果喜人。模板实现的功能比较全，比如登录、注册甚至各种widget，所以最终交付的时候，自己几乎没写几行 CSS。 material-design-lite -Star 数超过 2W 的开源模板项目，包含了多套简洁的 templates，可以用于博客、后台或者企业首页。 CSS MetroUI - 好看好用，重点是样式特别、个性 Font-Awesome - 图标字体库。相类似的库有不少，大厂都喜欢造轮子嘛 :) LoadersCSS - 用 CSS 技术实现 loading 动画； 补一句，想熟悉、理解 keyframes、animation 、 transform、transition 的童鞋可以直接去读其源码 ( 只有千把行代码 )，读完就算出师鸟 :) text-spinners - 又是一款 spinners效果的库，用来做 loading 正合适。 WeUI - 一套同微信原生视觉体验一致的基础样式库为微信 Web 开发量身设计，令用户的使用感知更加统一 PostCSS - 最近才知道大名鼎鼎Autoprefixer是其插件 推荐大漠的文章《PostCSS 深入学习》，有关 PostCSS 不是什么？PostCSS 是什么？PostCSS 可以做什么等等问题，文章里面有答案 CSSgram - 图片滤镜库，终于可以用 CSS 在 web上实现滤镜的效果鸟 IE 不支持，不过新的移动设备支持没问题Can I Use HINT.css - 一款非常小巧的提示框效果 Balloon.css - 同上，一款非常小巧的提示框效果 Hover.css - 很多鼠标 Hover 态的效果，可以给产品学习一下 :) Cursor - 记录各浏览器对 Cursor 的支持情况 csscss - 用于检查 CSS 代码冗余 purecss - 小巧的响应式 CSS 库，Yahoo! 出品 hamburgers - 简单的动画库，让 Click(or Tap)变得美妙 cssmatic - 一个帮忙调试 CSS 效果的工具 浏览端 JS requirejs - JS 模块化是构建复杂项目的第一步 中文学习文档奉上：RequireJS 中文网 three.js - JavaScript 3D 库。超多的examples 等着你去发现，你只需要关注内存和风扇就行了 ECharts - 好用，最关键的是支持的图表展示非常之多，强烈推荐 Swiper - 强大的 Slider 库 其实这类效果库非常多，但文档能那么专业的就很少鸟 babel - ES6 用起来。这个插件可以让我们用新的 标准 /提案 写 JavaScript 代码，然后再向下 转换编译，最终生成随处可用的JavaScript 代码。中文文档奉上《babel-handbook 》 dvajs - 基于 Redux 的一层封装，推荐的原因是因为阿里同学写文档都比较大而全，还可以顺道学习周边知识 :) fullPage - 非常好用的全屏滑动库，看 Demo就明白 PhotoSwipe - 偶常用的 js 库 官网上有这么一句很关键、重要 “no dependencies” Vuejs - 比较喜欢其作者 … 所以劳资正在看源码学习学习 ScrollReveal - star 10000+ 轻量级 JS 库。作用为当元素进入视窗的时候展示它们，README 中有示例，上手非常简单。官网体验地址：ScrollReveal vue-admin - 基于 Vue.js 开发的后台，示例地址：demo mixitup 一款基于 jQuery 的 排序/ 过滤 的 JS 库，最关键是有着美妙的动画效果 favico.js - 动态改变浏览器标签栏中的网站图标，非常好玩 ant.design - 蚂蚁金服搞的良心项目，文档美好的令人发指 样式优雅，强烈推荐内部系统尝试此库 highlightjs - 代码高亮库，支持非常多的语言 daterangepicker - 时间选择插件的不二选择，基于 Bootstrap 和 Moment.js nodePPT - 前同事三水的大作，好用必须得支持 :) 用 Markdown 写 PPT，还可以 HTML 混排，上手飞快 excellentexport - 纯前端的Excel 导出，非常之方便 Sortable - 拖拽神器，用了就知道 toastr - 信息提示的库，推荐的原因是卖相好、功能强大 demo peity.js - jQuery 的图表插件，特别cute，感觉萌萌哒 将 HTML 转换成一个小的&lt;svg&gt;饼图、圆环图、折线图等等 emojify.js - 能够将emoji关键词转换为emoji图片的JS插件 可以快速的为你的网站提供emoji表情支持 Push.js - 基于 Notification API 实现的桌面效果的提示栏。浏览器支持情况不错，如http://caniuse.com/#search=Notification Highcharts - Highcharts 中文网，又是一个图表库 确实功能强大，但是觉得不好看 … PS：官网就做的不好看，脏脏的赶脚 NProgress - 使页面加载时有更好的loading 效果 Noticejs - 一个简单的通知库，木有依赖 onepage-scroll - 依赖 jQuery的单页滚动库，和 fullPage 类似 videojs - 当下视频需求都用上&lt;video&gt;鸟 样式和交互统一的问题交给 videojs 搞定 :) clipboard - 仅 2KB 大小，搞定剪贴板功能，屌不屌 ~ 但是，Safari 不支持 … impress.js - 用来写 PPT 不错，偶也曾为其写过一篇impress.js 初体验 Cropper - 国人开发的图片裁剪库 Swiper/PhotoSwipe/fullPage 有这仨库，微信里常见的 H5 页完全不是问题哒 React &amp; RN awesome-react-native - 不解释 Project Build pm2 - 是一个带有负载均衡功能的 Node 应用的进程管理器； 是 Forever 的进阶库，想了解的可以看这篇文章《拥抱 PM2》 Webpack - 项目构建工具，由于过于复杂和太强大，所以劳资还没去深入研究。推荐篇教程：webpack 教程资源收集 Gulp - Gulp 是基于 Node 实现 Web 前端自动化开发的工具。 俺总结了篇《gulp 使用小结》，推荐您阅读 :) Bower - 前端项目的包管理其实是件复杂的事 谁谁谁依赖谁谁谁，谁谁谁依赖谁谁谁的某个版本 … 卧槽 Bower 就是搞定这件事儿的，亲爹是 Twitter推荐篇 Bower 的中文文章：《 bower 解决 js 的依赖管理》 Grunt - 和 Gulp 类似，都是项目构建的常见选择 对比这俩的文章可谓不少，推荐篇《Gulp vs Grunt 》 英盲又想看文档，可以去Grunt 中文网 FIS - 度厂出品的前端构建工具 文档清晰，功能强大，推荐了解和使用 Gitlab CI - 一套基于Gitlab的持续集成服务 Travis CI - 为 Github 上的项目打造的 CI 服务。记得2013 年 开始陆续看到文章介绍，刚在官网上看到，目前已经有 30W 开源项目和 23.5W用户在使用。大概看了一下getting started，简单几步就可以实现开源项目的持续集成。 Gulp + Webpack 的使用套路参考 :learning-gulp Gulp 资料收集：use-gulp 推荐篇与 Webpack 相关的文章《CSS Modules》 Webpack 用起来吼吼：webpack-howto Node Package 作为一名大前端甚至是多端，Node 绝逼是必备的一块 有关 Node 的学习资料，请访问Node 学习资料 这里介绍些有特色且前端有必要知道的包 anywhere - 随时随地将你的当前目录变成一个静态文件服务器的根目录 supervisor - 监控 Node 代码，自动重启。 A supervisor program for running nodejs programs nodemon - 监控 Node 代码，自动重启。Nodemon is a utility that will monitor for any changes in your source andautomatically restart your server. pm2 - 是一个带有负载均衡功能的 Node 应用的进程管理器； 是 Forever 的进阶库，想了解的可以看这篇文章《拥抱 PM2》 cz-cli - 刚用上的一个 git ci 工具，让我们的项目提交代码更规范、更有套路。打算写篇文章分享下，文章正在准备中，写完后会补地址。 async - 一个流程控制工具包，提供直接而强大的异步功能 optimist - 当需要处理 CLI 中的argv 时 ( 即命令行传参 )，用它就行了 lodash - JS 工具库 Underscore.js的一个 fork 发展而来 socket.io - 预计 Node 的实时框架 聊天室、页游等对实时性有高要求的较适用 Inquirer.js - 实现的效果比Commander 简单、有趣，贴个 GIF 供大家参考：loc Commander - 用 Commander.js 可以方便的创建基于 Node 的命令行工具，比如 vue-cli 这类，瞬间觉得自己又高大上了呢 ~ Mongoose - 让 NodeJS 更容易操作Mongodb 数据库； 附上一篇Mongoose 学习参考文档 CNPM - 淘宝 NPM 镜像，提供了 NPM 同步的服务 当然可不仅仅这样，利用 CNPM 可以打造企业 / 个人私有的 NPM 服务 推荐篇搭建私有 NPM的文章：《 CNPM 搭建私有的 NPM 服务》 koa - 玩 Node 都知道 express，但使用 koa 的就少很多，门槛比 Ex 稍高 通过 generator 避免繁琐的回调函数嵌套，强烈推崇官方的文章教程 Shipit - 一个强大的自动化部署工具。shipit 很多地方非常类似 gulp，他们的核心都是任务系统。 node-inspector - Node 调试工具，使用起来跟 Chrome 的 JS 调试器很相似 winston - Node 服务最流行的日志库之一 co - 用 generator 写法让异步代码同步 thenify-all - 把异步的方法变成Promise 的 Promisifies all the selected functions in an object PhantomJS - 一般用来做抓取截图和无界面测试 也可以用来操作 DOM 和网络监测，很好玩的库Quick Start ava - 偶是应 TJ 大神推荐而得之的 ava 未来的测试运行器 Mocha - Node 里最常用的测试框架； 它支持多种 Node 的 Assert libs； 同时支持异步和同步的测试，同时支持多种方式导出结果；也支持直接在 browser 上跑 JS 代码测试。 koa-validate - koa 的校验库 可以非常方便的对 queryString 或 postBody 的信息进行验证 line-reader - 基于steam的按行读文件，偶处理日志时用哒 要不实现一个按行读文件，又得 steam、 又得 chunk，还是比较麻烦的 binary 作者是大神substack，对应的处理 PHP/Python 中的 unpack方法。英文解释：Unpack multibyte binary values from buffers and streams. everyauth - OAuth 的集成解决方案 shelljs - 写 Node 时难免需要用 shell去操作些神马 shelljs 是基于 Node 的 shell 工具，API 及其简单 hashids - 看名称就懂，给 userid 加解密用的 node-pool - 让 Node 有连接池的概念 colors - 花俏的小工具 让打印console.log时有更好的展示样式 n - 控制 Node 的版本，想升级一行代码搞定 supervisor 和 nodemon 这俩都是监控 Node 代码，使得每次修改代码后会，开发Node 程序必备 以上库俺都有使用过，甚至有不少都是项目开发中、各种特定场景下必用的，有任何使用问题欢迎沟通哈 :) Node Project _暂无_ 精选阅读 前端技术 2015D2 前端论坛 - Node 方向非常值得看，有干货，相信东哥推荐哈 前端开发规范手册 -此手册主要实现的目标：代码一致性和最佳实践 《babel-handbook 》 -可以用新的规范 ( 如 ES6) 写代码，经过 babel 编译后生成没有兼容问题的代码 JavaScript Standard Style - 强烈推荐，尤其适合技术Leader。优秀的 JS 编码规范是好前端团队的开始 ECMAScript 6 入门 - 阮一峰大神所著，一本开源的JS 教程 全面介绍 ECMAScript 6 新引入的语法特性 ReactNative 中文版 - 翻译自官方的中文文档 ReactWebpackCookBook -此书会引导读者是进入React和Webpack的世界。 俩都是非常前沿的技术，同时使用会更有趣。 Sass 指南 - Sass 指南主要作用是用来帮助大家更好的书写 Sass 和维护 Sass。 ReactNative 学习指南 - 新玩意层出不穷 … 对于能持续学习的童鞋，这是个美好的时代 HTML/CSS 编码规范 - 编写灵活、稳定、高质量的HTML和CSS代码的规范 移动前端入门 - 入门价值高，移动方向常见问题的较好总结 GulpBook - Gulp 是基于 Node 实现 Web 前端自动化开发的工具 Node 学习资料 Node.js 中文资料导航 - Node 的中文资料导航，start1300+ 从零开始 NodeJS 系列文章 - 基本上每一篇都看过，强烈推荐 Node.js 包教不包会 - 值得阅读，看完绝不用买书鸟 七天学会 NodeJS - 劳资还没看，不过看目录还不错 :) Style Guide - 这是一份关于如何写出一致且美观的 Node 代码的风格指南 koa 实战 -“明河出品 ” 这四字已经说明一切。PS ：正在连载中 stream-handbook - 如果学习NodeJS，那么流一定是需要掌握的概念 前端面试 笔试面试知识整理 - 打开其 Gitbook上的地址我都惊呆了。虽然有部分内容待完善，但是光浏览目录都是享受。 在 LinkedIn 做面试官的故事 -非面试题，介绍 LinkedIn 的面试过程 文章有很多中肯的建议和想法，推荐阅读 大漠：写给前端面试者 -这篇文章不涉及任何的面试题 大漠与大家聊聊面试者与被面者之间的感受 … 前端面试题 -Git 上非常火的前端面试题，start17k+ 前端面经 -主要内容是些前端面试笔试题和面试套路，值得阅读 其他技术 微信小程序开发资源汇总 -天津第一程出品。微信小程序开发资源汇总。 命令行的艺术 -熟练使用命令行是优秀工程师的基础 MongoDB 极简实践入门 -入门推荐的套路，非常浅显易懂 Mac 设置指南 - Mac使用必看 尤其适合 偏执狂 / 强迫症 患者 :) Markdown 资料 - 简单看些语法入门，快速用起来 工具/软件 Web 百度脑图 - 非常方便的思维导图工具。功能强、样式佳、无广告，算百度出的良心产品之一。除了 Evernote，脑图是我非常依赖的记录工具 CanIuse - 前端必备；查看浏览器对各种新特性的兼容情况 overapi - 最全的开发人员在线速查手册 ProcessOn - 和百度脑图的功能类似，脑图工具。但是还有社交、通讯的功能，提倡 协作绘图 的理念。感觉网页跳转的时候有点慢，模板样式比百度脑图好看 ( 个人观点 )，而且团队协作的功能真的相当好用。 Slides - 一个所见即所得的 WebPPT 编辑器。虽然装 X 效果一般，但是比较推荐，因为无论懂不懂 UI，做出来的效果不会太难看 faviconer.co - 一个所见即所得的 icon 生成器，很好用 smallpdf - 提供各种格式和 PDF 互相转换 Cmd Markdown - 好用的 Web 版 Markdown 编辑器 VimAwesome - Vim 插件集合，Vim 党必备 Tower - 小而美的多人协同工具。 不光只有 Web 版，还有iPhone、iPad 、 Android、微信版。 StackEdit - 又是一款 Web 版 Markdown 编辑器 墨刀 - 一个在线移动应用原型制作工具。 旨在帮助产品经理快速制作可在手机端展示的移动应用原型。 htm2pdf - HTML to PDF Speaker Deck - 在线的演讲稿展示平台 RunJS - 在线编辑、展示、分享、交流你的 JavaScript 代码 Bootswatch - Bootstrap 的免费模板 AdminLTE - 又是一个 Bootstrap的免费管理后台 APP 以下列表中的 APP 都是不区分系统平台的 印象笔记 - 免费账号完全够用，跨平台跨终端的记录软件 365 日历 - 首先肯定比系统自带的日历强大，要不推荐个蛋蛋 俺一般用来搞目标管理，比如学习计划和工作计划 生活中会订阅演唱会、电影首映的信息 多看阅读 - kindle 确实好，但是懒得随身带着 多看还算不错，书较多且偶尔有特价比较爽 Surge -非免费 牛逼的网络开发与调试工具，前端必备 Monkey - Monkey 是 iPhone 上一个 GitHub第三方客户端。 展示 GitHub 上的开发者的排名，以及仓库的排名 Mac 软件篇 对于美好事务的追求无论何时都不算晚。 Mac 下的软件那么多，又是免费又是付费，应该怎么选呢？我来分享下我的推荐列表，推荐的优先级老规矩，从上往下依次降低。 Alfred - 免费，绝对的推荐 Top1，很提效率，高级版 Powerpack 售价 £17。除了能快速搜索和打开应用程序之外，查找文本文件、全文检索、调起浏览器搜索和计数器都是俺经常使用的功能。如果想知道具体咋用，推荐阅读老池 ( 池建强 ) 的文章：《神兵利器 —Alfred》 iTerm2 - 免费。Mac 终端功能少又不好看，iTerm2 可以解救你 ~ 推荐篇文章：《让你的命令行丰富多彩》 HyperDock - 售价 ￥68，感觉还是很值的 ( 特么我还想说，Windows 数年前就自带的功能，在 Mac 上还收费，略忧伤 )。预览和快速切换窗口太有必要了，能用快捷键控制窗口，能让拖拽到边缘的窗口自动调整大小(window 早就有的功能 )，真心能提高效率。推荐篇中文的文章：让 Mac 的窗口飞 ATOM - 免费。2015/7 之前，在桌面环境下偶最喜欢的编辑器是 Sublime，但之后就是 ATOM，俺也专门为它写了篇《使用纪要》 Surge -$49.99。关注 IOS 开发或者常备梯子的同学，肯定都知道这大名鼎鼎的软件。价钱从 ￥68 涨到 $99 也让偶咋舌，背后的故事就不细说了，感兴趣可自行去谷歌百度一下。PS ：翻墙软件 小飞机 ShadowsocksX 也非常棒，同样推荐：“ 轻量级科学上网姿势，改变您的生活体验！” 1Password - 免费 试用一个月，售价不便宜$64.99。如果觉得对各种账号的密码管理心累，那么推荐你使用，这个钱肯定值，Mac 和 iPhone 通用，爽歪歪。如果账号密码都是那种一、俩个套路，而且被盗也随意，那么用不用就无所谓啦 Go2Shell - 一款适合程序员的神器。可以快速在当前目录打开 Shell 的工具，比如直接在 Finder 里打开 ITerm2。 Sequel Pro - 免费。好用的 Mysql 工具 OmniPlan - 免费 试用 14 天。甘特图工具，项目 Leader 必备。 Manico - 免费 版已经很好用了，全功能版售价 ￥25。快捷启动和切换 APP 的工具，高效的第一步 Moom - 售价 $10，有试用版。个人觉得这钱花的值，设置快捷键之后可以方便的调整每个窗口的位置。我不管在家还是公司都是开双屏，外接屏幕三分之一 iTerm，三分之二 ATOM，日常使用时各种全屏、居中、靠左、靠右等用快捷键来回着换，辛福感满满的。 CheatSheet - 免费。能够显示当前程序的快捷键列表，默认的快捷键是长按 ⌘ 奇妙清单 - 免费 漂亮的任务清单管理工具。有简中和繁中版，操作和样式都比较简洁，推荐有 TODO 需求的人士使用。最关键的是其支持所有设备而且免费。 马克鳗 - 免费 版已经够用啦，收费版是 60/ 年。英文名 MarkMan，非常强大好用的标注、测量工具，强烈推荐 BrowseShot - 免费。偶正在使用的网页截图工具，强烈推荐 Wireshark - 免费。说实话，Mac 下木有Fiddler 挺不习惯，不过在有更强大的替代品，虽然有点复杂 … 还好后来下载到便宜 (￥68) 的 Surge 做替代品 LICEcap - 免费。屏幕录制工具，支持导出GIF 动画图片格式 轻量级、使用简单，录制过程中可以改变录屏范围 Bartender 2 - 售价 $20.97，但是可 免费试用四周。Mac 右上角菜单的管理工具，试用之后右上角的菜单瞬间清爽了，反正试用下也不花钱 :) BeyondCompare - 免费。在 Windows 下就开始用了 比对文件和文件夹杠杠好使，Merge 必备工具 SourceTree - 免费。属于大名鼎鼎的Atlassian，一款好用的的 Git 客户端工具，重点是 支持中文，哈哈 :) focus booster - 免费 已经够用，当然还有更高级的 INDIVIDUAL/PROFESSIONAL，售价分别是 $3/$5。因为比较在意时间管理，所以当工作压力较大时，这软件是俺的必备之物 WebTorrent - 免费。直接播放种子，你懂得。年轻的斯坦福大神 Feross 开发，Git 上的开源项目哦。 WebStorm - $129，可试用一个月。功能超强的前端 IDE，谁用谁知道 PS：貌似俺插件装多了，用着卡卡的，风扇呼呼转 …然后俺就卸载装了，装了 ATOM… MindNode - 售价 $29.99，有免费试用版。这是款漂亮的思维导图工具。其实 百度脑图 这类 Web 上的工具绝对够用了，不太推荐 … Mou - 我曾使用过的 Markdown 编辑器，不推荐使用。原本已经准备去掉，但是偶还是想让大家了解下这个有意思的事情：《一年了，那个闻名遐迩的 Mou 你还记得吗？》 Fliqlo - 视觉控会喜欢的屏保软件。纯深色界面上铺满着大大的时间，非常好的简约效果。 以上列出来的都是偶觉得比较有意思、有特点的软件。当然，类似 Docker、Polarr( 泼 辣修图 ) 等这类都太小众；有道翻译、Evernote、Foxmail 等这类又太大众；然后有些软件买了觉得有点 “ 亏 ”，比如刚出手买入的 Final Cut Pro，其实机器自带的iMovie 就挺好了（完美诠释《Final 从入手到放弃》）。所以，这几类就不一一往这列举啦 ~ Linux 作为一名程序员兼工具控，我期待自己无比高效 首先，都是免费哒；然后，所列项目都是针对 CLI( 命令行界面 ) 哒；最后，探索无止境 oh-my-zsh - 终端党 必备，好处太多太多，比如炫酷的外观，超强的易用性 … 推荐大家阅读知乎的问题：《为什么说 zsh 是 shell 中的极品？》 spf13-vim - 对于 Vim 偶之前做了好多文档和记录，但是自从了解有这个套路，那些记录都可以丢掉了。不过建议想了解的去看看.vimrc 中的 Plugin，确实足够大而全。PS ：如果遇见 neocomplete does not work之类的错误，可以参考Problems with Vim and lua? Vundle - Vim 党必备。用于管理各种Vim 插件，有 Git 就可以安装 $ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle tree - linux 以树状图逐级列出目录的内容，装逼效果和实用功能都不错 cloc - 可用来计算 文件夹中各种语言的代码占比情况。展示内容非常直观，如某目录下 JavaScript 有多少个文件，共多少空格行数、注释行数、代码行数，就这些简单粗暴的内容。常见的安装方式可通过 npm 来进行安装。 oneapm - 强大的运维工具，提供多种监控客户端； 有采集、分析、展示等一套功能； PS ：我这用了服务器监控 ( 免费哦 ) httpie - 一个 CLI 中的 HTTP 客户端，用法简单，非常适合用来搞调试、测试 ESLint - 前端大神Nicholas C. Zakas创建。JavaScript 辅助编码的规范工具，有效控制偶们的代码质量 Lucario 暗色系主题，支持 Vim, Atom,Sublime Text, TextMate, Terminal.app, iTerm, Xcode and XTerm cmatrix - 作用就是装逼，可以在屏幕上显示经典的黑客帝国的数码雨效果 ( 看官方文档上也有其他效果，俺就不往细研究了 )。在 Mac 下安装非常简单，一步搞定：$ brew install cmatrix Mac Homebrew - 有了他 OS X 程序猿能更好的专注代码层面。最近在看《七周七语言》，里面出现各种语言环境，用 brew 来安装、管理各种解释器和编译器，省心省力！ Xcode - 因为玩 Swift 所以早早就下载了，后来才知道原来 Mac 下如果不安装 Xcode，部分常用的指令都不支持，囧 Chrome 浏览器插件 Chrome 应用商店必定是需要翻墙的哈。 以下插件都是俺多年积累淘出来的，数量不多，所以就不区分 Github 插件和非Github 插件了。按照俺推荐的强度自上向下展示，且大多数插件就是偶工作和生活必备，希望能对大家有用。后续如有新发现好插件，偶也会及时更新哒。 Postman -POST 接口调试终结者，异常强大的接口调试工具。稍稍有一点学习成本，推荐之 JSONView -就是个 JSON 格式的查看工具，可以很方便的展示数据，麻麻再也不用担心偶调试接口啦。PS ：同类插件有不少，所以用的开心就行 二维码生成器 -RT。PS ：这 FF 早已经自带生成二维码工具了，Chrome 还得装插件才行，任性 … WEB 前端助手 (FeHelper) -百度 FE出品，功能超全的 Chrome 插件。简单列一下其功能：QR 码生成器、字符串编解码工具、JSON 格式化查看器、前端编码规范检测、代码压缩工具、页面取色工具、统计并分析网页加载性能等等 Eye Dropper -前端必备的颜色提取神器，操作简单容易上手 Vimium和 Vim 快捷键一样，浏览网站时不需要鼠标咯 Page Ruler -前端必备的尺子。计算页面元素间距、位置等信息的时候，你就知道它的好了，无脑上手，你值得拥有 FireShot -可以截取整个网页、部分页面，然后支持导出为各种格式。俺微博上发的网页全景图都是靠这个插件截取的 Infinity -好不好用有点见仁见智了，但是我个人比较喜欢。使用后会让你的 新标签页 耳目一新，有漂亮的背景和各种常用的功能，比如地图、天气、Gmail、Chrome商店等等。当然，在这个插件的设置中还可以设置壁纸、动画效果等等 Momentum -同样也是 新标签页 的插件，但是不管是视觉上 ( 高清大图 ) 还是功能上，都比Infinity高大上不少，Setting 里面有不少设置和快捷键，都很好上手的。Infinity胜在中文和直观，Momentum胜在视觉冲击。俺基本上这俩款看心情换着用，所以希望你也都能喜欢 :) Google 翻译 -英文不好又得经常浏览英文资料的，一般都准备好了翻译工具。不过能在浏览器里达到划词翻译的方案就不多了，偶推荐这个 Google 翻译 (PS：如不能翻墙，有道词典的扩展也同样支持划词翻译 )。 Octotree -在浏览器左侧展示 Github 项目的文件导航，使目录结构一目了然，而且我们国内Github 的访问速度又不稳定，用这个工具也就很提效率了。对经常使用 Github 的同学强烈推荐 BuiltWith/wappalyzer/Chrome Sniffer Plus -几款超强的网站分析工具，可以给出网站非常多的技术栈信息。大到 Web Servers、服务端的 Frameworks 或 JS 框架，小到 meta、编码格式甚至 Analytics，非常推荐 Adblock Plus -非常非常有名的免费的过滤广告的插件。PS ：广告屏蔽这个见仁见智，其实俺个人还是比较接受一些个性化推荐的广告 Wide Github -无聊又实用的 Github 插件。无聊是因为这个插件就特么一个功能，加宽，能让Github 页面变宽，每行展示更多的内容，尤其配合着Octotree，展示效果极佳。非常推荐 Mac 用户实用，因为屏幕比较不大，变宽后阅读感觉更好 Gmail -方便查看自己的 Gmail 邮件 Imagus鼠标指针悬停在链接或缩略图上时直接在当前页面的弹出视图上显示这些图片、HTML5 视频 / 音频和内容专辑 … 看新浪微博时贼有用 :) DevTools Author -纯装逼的插件，可以选择你的 Chrome 开发者工具的主题，且支持的主题超过 25 种，视觉装逼控必备。设置分大概三步，官网有文字说明，youtube 上的视频教程奉上(Customization With DevToolsAuthor)[https://www.youtube.com/watch?v=AUZagMLMAJc] GitPlug -在 Github 项目页中嵌入有关的图表信息，直观的展示当前项目的 Star Trend，能方便看到当前这个开源项目的发起时间，火爆趋势；对比较知名的项目还有相关的News 展示 OctoLinker -在 package.json 或任意 .js 文件中，可以方便的对 require() 的 package进去点击，跳转去对应的 Github 页面。PS ：特么不太好表达，建议你去这个插件的概述页，里面有个十来秒的视频，看完就明白鸟 GitHub Hovercard - GitHub 增强工具，悬停可显示对应的用户、仓库、issue 等的详情。 ReRes -可以用来更改页面请求响应的内容。通过指定规则，您可以把请求映射到其他的 url，也可以映射到本机的文件或者目录。ReRes 支持单个 url 映射，也支持目录映射。 补充： 翻墙代理的插件偶没使用，偶手机和电脑的翻墙都是配的 Surge 无脑搞定，不过翻墙代理插件推荐Proxy SwitchySharp，熊掌公司里大多用的都是它 日常开发相关的插件就以上这些，还有几款如知乎的插件、购物插件等这类与开发效率不沾边的，俺就不这上头列了哈 Git Git 教程 - 廖雪峰 -俺有看过不少 Git 的文章，确实这个系列是最通俗易懂的 GitAwards - Git 工具，可以查看 Git 排名 Git 速查 -分类清晰的速查表 Git 简明指南 - 入门Github的简明指南，木有高深内容 :) Git 学习资料整理 - 内容包括很多 Git 的相关资料，star 1200+ GitHub 漫游指南 - 一篇还算不错的 Git学习总结，就是乱了点 … 我理解作者_漫游_的意思是漫无目的想到哪写到哪 ~ 看到作者为鸟达成 Git 连击的成就，也是蛮拼的 :) 服务端 如 Ruby、Python 、 Perl 等相似的服务端语言的学习资源。 _暂无_ 数据端 Mongoose - 让 NodeJS 更容易操作Mongodb 数据库。 附上一篇Mongoose 学习参考文档 客户端 面对大名鼎鼎的 Electron，我懵逼了。犹豫了一会儿，不知道把其放在哪个分类中，于是我单开了一个 客户端 的类目。 Electron - 如果你想利用 web 技术构建跨平台的桌面程序，那么赶紧来了解 Electron。 设计/交互 作为负责最终效果呈现的前端工程师，多少得了解些 设计和交互 的，这也是为什么fetool 会单独的存在这一章 … 当然话又说回来了，偶毕业的第一份工作是设计 :) 站酷 - 里面好东西太多，俺当年真没少再上面淘素材 UI 中国 - 光听名字就知道有多高大上鸟 :) 速查手册 RT，这篇都是些文档或者 API，一般这类东西都在大家浏览器的书签内，偶这也列一下大前端常用的手册地址 JavaScript Standard Style - 强烈推荐，尤其适合技术Leader。优秀的 JS 编码规范是好前端团队的开始 HEAD - 最全的 &lt;head&gt; 列表，真心佩服这种偏执的整理能力 百度 CDN 公共库 - 基本常见的库都收录拉，搞 demo的时候特方便 HTML 和 CSS 代码规范 - 编写灵活、稳定、高质量的 HTML 和 CSS 代码的规范 Linux 命令中文手册 - 木有系统的好好学习 Linux，所以命令更不熟悉 真羡慕那些 CLI 玩的飞起的 :) Git 速查 -分类清晰的速查表 jQueryAPI 1.11.3 - ZeptoAPI 基本和 jQuery 一样，所以看一份就好 CSS - CSS 在线参考手册 Redux 中文文档 - 作为个前端，React 还是得尝试下的。英文文档就不给大家推荐了 ~ Express API - 中文手册 :) 4.x 和3.x 都有 CI 用户指南 - 一个轻量级的PHP 框架用户指南 推荐指数低的原因是劳资 PHP 比较弱，囧 Yaf - 鸟哥 ( 惠新宸 ) 所写的 PHP 框架 推荐指数低的原因同上 … 杂七杂八 放些开发中较有用的杂物在这儿 提問的智慧 -RT，简体版。“當你拋出一個技術問題時，最終是否能得到有用的回答，往往取決於你所提問和追問的方式。本指南將教你如何正確的提問以獲得你滿意的答案。”—— 摘自原文 租房要点 - 适用于北上广深杭，大城市打拼租房确实是硬伤 QQ 群规 - 突然某天，有个QQ 群让我加群 原本我是拒绝的，但当我看完这篇 QQ 群规后 … 劳资真的被感动到了，太牛逼、够专业！ 最后，我默默加群鸟 :) .gitignore 文件 - 介绍不同语言项目的gitignore 模板 Docsify - 一个轻量级的、支持Markdown 语法的文档生成器。ps ：还提供了详细的中文文档哦。 程序员如何优雅的挣零花钱？ -中肯的文章，如果读完能有些许收获，那么恭喜你 git-draw - 黑魔法，可以修改自己 Git 上的Contributions GitBook - 写记录的好地方 Codebabes - 学编程的网站。 重点是每通过一个测试，尼玛对应的妞会脱一件衣服 … PS：要翻墙哦 ~ emailframe - 邮件展示确实比较坑，建议有需要的收藏 ReadmeSample - 项目高大上的第一步就是包装，所以来看看 README 的书写套路吧 PS：劳资怎么这么无聊 … 前端炫技-炫酷狂拽叼炸天站点 three.js - JavaScript 3D 库。超多的examples 等着你去发现，你只需要关注内存和风扇就行了 windows93 - 模拟 Win93 桌面，思路、体验和整体效果比较有意思 GeekTyper - 好玩又具有 Geek 精神的网站，虽然创建的目的是个恶作剧 PS：网站需要翻墙 2016.makemepulse.com - 帅哭了。请使用现代浏览器打开 前端技能栈 - 好玩的前端技能栈展示 Mapbox - 非常叼的开源项目，有方便的 JSAPI( 还有SDK)。 不过免费版只能浅尝，流量有限。 PS ：网站需要翻墙 mixitup 一款基于 jQuery 的 排序 / 过滤的 JS 库，最关键是有着美妙的动画效果 Clark Duvall - 一枚歪果仁的个人 blog，范儿叼叼的 earth - 全球天气的可视化项目 SuperScrollorama - 好玩好看的动画库，链接是 SuperScrollorama 的展示页 parallax.js - 一个视差引擎的官网，在电脑和手机上都有很好的体验 CSS 字母 - 用 CSS 实现英文字母，叼叼的 墨刀 - 一个在线移动应用原型制作工具。 旨在帮助产品经理快速制作可在手机端展示的移动应用原型。 小结 背景俺算个比较能自我总结的码农，所以偶尔喜欢写点东西做些记录或者自我熏陶陶醉一下。可写着写着发现Evernote里面的东西太尼玛多 ( 乱 ) 了，于是想着把一些技术相关的资料都整理整理，都丢到Github上沉淀下来。 这样 Evernote 就可以只需要记录些偏生活方便的，看着清爽一些 … 所以，这篇记录其实只是为偶自己而写，确信以后也一直会这样 ~~~ 说说目标其实与这篇记录类似的文章太多鸟，俺也不愿意成为一个单纯的收集资料，分享资料的这么个东西。 我希望 fetool 能更生动、更个性，最好能更另类点，对于每样工具的思考和解析更多点，吐槽也必须有理有据，然后再配上劳资收集的 low 图，完美！ 希望通过不停的完善这篇记录，能 Push 劳资多了解业内的新玩具和新创意，然后围绕这些新东西，客观的再写点好东西，比如文章、资料、开源项目这些，让其他伙伴们少走弯路或学的更顺畅点儿 所以劳资对自己的要求是：这篇记录里列出的每样东西，自己都得的去了解、去尝试，然后再列出来。 能举一反三最好，如果达不到至少也能清楚的认识：列出来的这玩意对程序员有没有卵用，解决了啥痛点。 TODO 继续完善和扩充内容 “ 备注 / 说明 ” 这一栏不够犀利，希望再多加入自己的理解、点评、吐槽，让这篇记录更犀利和生动 支持导出多种格式，如.pdf、.epub、.mobi等 后续看看如果有必要，可以单独搞个页面，优化下阅读和展示效果 以下是 @ 拔赤 总结的前端技能图： 完善 ing，慢慢把 Evernote 和 浏览器书签 里面的好东西慢慢捣腾到这儿，更欢迎 PR，谢谢。 用自己青涩时的照片镇楼，哇哈哈 ~ 您可以通过以下方式联系到我： 微博 @ 聂微东 个人 Blog fefork.com 博客园 犀利的东哥 QQ 群 214199415，群名前端 Club。PS ：入群务必请提供 有内容的 git 或blog 地址，否则进不去哈 :) License ⬆ 返回顶部]]></content>
      <categories>
        <category>编程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>干货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA插件汇总]]></title>
    <url>%2F2017%2F01%2F30%2FIDEA%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[IDEA 插件汇总标签： 插件 IDEA 插件安装 IDEA 的插件安装非常简单，对于很多插件来说，只要你知道插件的名字就可以在 IDEA 里面直接安装 在线安装如图 : Preferences—&gt;Plugins—&gt; 查找所需插件 —&gt;Install 或者 离线安装 Preferences—&gt;Plugins—&gt;Install plug from disk —&gt; 选择下载好的插件安装 在 IntelliJ IDEA 的安装讲解中我们其实已经知道，IntelliJ IDEA 本身很多功能也都是通过插件的方式来实现的，只是 IntelliJ IDEA 本身就是它自己的插件平台最大的开发者而已，开发了很多优秀的插件。 官网插件库：插件https://plugins.jetbrains.com/ 推荐的插件Maven Helper我一般用这款插件来查看 maven 的依赖树。在不使用此插件的情况下，要想查看 maven 的依赖树就要使用 Maven 命令maven dependency:tree来查看依赖。，但是这样还是需要我执行命令，并且当项目比较复杂的时候，这个过程是比较漫长的。maven helper 就能很好的解决这个问题。 一旦安装了Maven Helper插件，只要打开 pom 文件，就可以打开该 pom 文件的 Dependency Analyzer 视图（在文件打开之后，文件下面会多出这样一个 tab），进入 Dependency Analyzer 视图之后有三个查看选项，分别是 Conflicts( 冲突 )、All Dependencies as List( 列表形式查看所有依赖)、All Dependencies as Tree( 树结构查看所有依赖 )。并且这个页面还支持搜索。很方便！并且使用该插件还能快速的执行 maven 命令。 来一张 maven helper 提供的图片感受一下： FindBugs-IDEAFindBugs很多人都并不陌生，Eclipse 中有插件可以帮助查找代码中隐藏的 bug，IDEA 中也有这款插件。 使用方法很简单，就是可以对多种级别的内容进行 finbugs 分析完之后会有一个视图进行提示，详细的说明是哪种问题。 按照提示解决完问题之后再执行findbug 查看情况即可。 CheckStyle-IDEA通过检查对代码编码格式，命名约定，Javadoc ，类设计等方面进行代码规范和风格的检查，从而有效约束开发人员更好地遵循代码编写规范。软件安装成功之后，首先要设置规则。可以通过 Preferences—&gt;Other Settings —&gt;CheckStyles 进行设置，可以直接将文件添加进来，然后就可以对具体的文件进行检查了。 同样，该插件也有个单独的视图，该视图可以展示检查结果。 GsonFormatJava 开发中，经常有把 json 格式的内容转成 Object 的需求，GsonFormat 这款插件可以实现该功能。 AceJumpAceJump 其实是一款能够代替鼠标的软件，只要安装了这款插件，可以在代码中跳转到任意位置。 操作 : 第 1 步：Ctrl+; 快捷键，激活插件。此时，IDE 代码编辑区会出现一个蓝色光标，然后输入你要跳转的标签。 第 2 步，这是，IDE 全屏所有你刚才输入的标签都会被高亮显示，并且在这个高亮的标签前面会出现相应的键盘字母，你按照相应提示的字母去敲击键盘就可以自动跳转了。 markdown安装这个插件之后，打开 .md 文件就可以通过一个支持 md 的视图查看和编辑内容。一般用于写 README.md 文件。但是这个插件我不太用，因为他对 md 语法支持的并不是很好 Key promoter很多开发都是从 Eclipse 转到 Idea 的。用习惯了 Eclipse 的快捷键之后在使用 IDEA 真的非常不习惯。Key promoter 这款插件适合新手使用。当你点击鼠标一个功能的时候，可以提示你这个功能快捷键是什么。 ideaVim这个插件的作用是在 Intellij 中模拟 Vim 的操作方式。咋看上去，似乎是一个只有 Vim的狂热玩家才会选用的插件。但事实上这个插件提供了一个非常实用功能，让它成为了我们这种普通开发者居家旅行的必备选择。这个功能是，IdeaVim 允许设置一个快捷键来激活或关闭 IdeaVim 模拟器，而且在激活或关闭时，会自动切换 Keymap。也就是说，你在输入大段代码时，可以使用自己惯用的 Keymap。在阅读代码，小范围修改，或者进行一些重复性修改时，可以切换到 Vim 模式。甚至你可以把 “ 关闭 IdeaVim” 看做 “ 增强的 Vim 插入模式 ”。有了 Vim 普通模式下的各种功能，就可以省去记忆大量快捷键的苦恼，而且本来熟悉 vim 使用，是程序员迟早都要遇到的问题。 在普通模式下输入 :s/ 正则表达式 / 替换文本 /g 可以在当前行范围内查找替换。（在正常的 IDEA 中需要选中当前行后在当前选区查找替换） 在普通模式下输入 小数点 将在当前光标位置重复上一次修改操作。例如你在某一行进行了上述的查找替换，如果立即需要在另一行做同样操作，把光标移动到该行按小数点即可。 yyp 复制当前行。 yy10p 复制当前行 10 次 u 撤销修改 / Ctrl+R 重做修改 q 加任何单个数字或字母，录制后续操作，记录到名为该数字或字母的宏（Macro ）中。在录制状态下按 q 结束录制。@ 加某个已录制的宏名（单个数字或字母），回放宏。录制的宏只要不被覆盖，会自动保存。重启 IDEA 后仍然有效。（在正常的 IDEA 中使用宏需要进行菜单操作，不甚方便） daw 删除一个单词，d$ 删除至行尾，d0 删除至行首（包括缩进）， d^ 删除至行首（保留缩进）， dd 删除当前行。删除后按 p 可以复制删除内容。 J 直接把下一行连接到本行末尾，去除缩进 % 跳到匹配的括号 10ib 插入 10 个 b。（数字）i/a/o/O （字符串） 可插入 n 个重复字符串，i 在光标前插入，a 在光标后插入，o 在下一行插入，O 在上一行插入。注意在 IDEA默认情况下输入 “i 字符 ” 后会弹出自动补全菜单，需要多按一下 ESC 取消掉补全菜单。 在一个数字上按 ctrl+a，可将该数字加 1. 按 ctrl+x 可将数字减 1. 按（数字）ctrl+a ，可将光标数字加上输入的数字。 ~ - 将光标下的字母改变大小写。 g~aw - 改变当前单词的大小写。gU&lt; 空格 &gt; - 当前字母改大写。gu&lt; 空格 &gt; - 当前字母改小写。 gUaw - 当前单词改大写。 guaw -当前单词改小写。 在字符串前面的引号上 gUf” - 字符串改大写。 行号 G - 直接移动到某行。（使用 IDEA 的 Ctrl+G 会弹出对话框，且移动到的那行会自动居中，颇为眼花） H - 光标移动到屏幕第一行。 L - 光标移动到屏幕最后一行。 M - 光标移动到屏幕中间。 zz - 光标所在行居中 CodeGlance类似 SublimeText 的 Mini Map 插件 Background Image Plus这又是一款装备 B 插件了，想想别人看到你的 IDE 背景是怎样的，安装之后，在打开View 选项，就可以看到 Set Background Image 选项了 Shifter检测光标所在选中、行或关键字的类型，然后用键盘快捷键上的 “up” 或 “down” 键移动它。如果在一行中只有一个可移动的单词，那么它不需要碰触光标，我们就可以移动它。支持小写 / 大写或小写所移动单词中的第一个大写的字符。 默认快捷键 1234Ctrl + Shift + Alt+逗号：下移Ctrl + Shift + Alt +句号：上移Ctrl + Shift + Alt + K：上移更多Ctrl + Shift + Alt + J：下移更多 移动更多：多次重复选择所选中的值。重复次数可在插件配置中进行配置（默认为 10） bashsupportlinux支持…对于IntelliJ的Bash语言支持。它支持语法高亮，更名重构，文档查询，检查，快速修复。BashSupport可以直接在IntelliJ中运行脚本。你可以为bash脚本创建一个新的运行配置。在这里你可以设置哪个解释器是用来运行它。每当执行脚本时，就会记录输出。如果Bash打印出语法错误，那么点击错误的行就可以跳到错误的位置。 Cmd Support我们已经可以用命令行来调度脚本了，但是每次执行的时候不是要到对应目录下去双击文件就是要在命令行中敲出对应的脚本执行语句这里我们又一个更方便的工具执行脚本,cmd support,他允许直接运行cmd或者bat文件,与windows的bat完全一样.右键run cmd script String Manipulation提供强大的文本转换操作： 切换样式（camelCase, hyphen-lowercase, HYPHEN-UPPERCASE, snakecase, SCREAMINGSNAKE_CASE, dot.case, words lowercase, Words Capitalized, PascalCase） 转换为SCREAMINGSNAKECASE (或转换为camelCase) 转换为 snake_case (或转换为camelCase) 转换为dot.case (或转换为camelCase) 转换为hyphen-case (或转换为camelCase) 转换为hyphen-case (或转换为snake_case) 转换为camelCase (或转换为Words) 转换为camelCase (或转换为lowercase words) 转换为PascalCase (或转换为camelCase) 选定文本大写 样式反转 Un/Escape: Un/Escape 选中的 java 文本 Un/Escape 选中的 javascript 文本 Un/Escape 选中的 HTML 文本 Un/Escape 选中的 XML 文本 Un/Escape 选中的 SQL 文本 Un/Escape 选中的 PHP 文本 将 diacritics(accents) 转换为 ASCII 将非ASCII 转换为转义的Unicode 将转义的Unicode转换为字符串Encode/Decode: Encode 选中的文本为 MD5 Hex16 De/Encode 选中的文本为 URL De/Encode 选中的文本为 Base64 递增/递减: 递增/递减所有找到的数字 复制行并且递增/递减所有找到的数字 创建序列：保持第一个数字，递增替换所有其他数字 递增重复的数字 按自然顺序排序: 按行倒序 按行随机排序 区分大小写A-z排序 区分大小写z-A排序 不区分大小写A-Z排序 不区分大小写Z-A排序 按行长度排序 通过子选择行排序：每行仅处理一个选择/插入符号 对齐： 通过选定的分隔将选定的文本格式化为列/表格 将文本对齐为左/中/右 过滤/删除/移除： grep选定的文本，所有行不匹配输入文字将被删除。 （不能在列模式下工作） 移除选定的文本 移除选定文本中的所有空格 删除选定文本中的所有空格 删除重复的行 只保留重复的行 删除空行 删除所有换行符 其他: 交换字符/选择/线/标记 切换文件路径分隔符：Windows &lt; - &gt; UNIX Grep Console允许你定义一系列将通过控制台输出或文件测试的正则表达式。匹配代码行的每个表达式将会影响整行的样式，或播放声音。例如，错误消息可以被设置在一个红色的背景中显示。 附加功能：ANSI着色 File Tailing： Main menu | Tools | Open File in Console Main Menu | Help | Tail (IntelliJ) Log in Console 在主工具条中拖放“Tail File”面板 HTTP和Windows右键菜单集成 .ignore版本控制时标记一些不需要上传到git上的文件把不需要的文件添加到.ignorefiles中,文件就不会上传到git,比如本次的,.idea文件夹是我的工程配置文件包括了我的jdk位置,jar包位置等信息,别人打开就是出现错误,还是不要上传到git上好,target是编译后的class文件,也不需要上传,courses.iml是 intellij idea的工程配置文件,里面是当前projec的一些配置信息 markdown navigator书写 Markdown 文章比自带的markdown要好一点如图: Properties to YAML Converter把 Properties 的配置格式改为 YAML 格式 statistic使用statistic插件可以统计代码总行数在idea左下角点击statistic图标显示各个文件的行数,代码数 lombok 安装lombok插件 在自己的项目里添加lombok的编译支持(此处本人所操作的项目为maven项目),在pom文件里面添加如下indenpence 123456 &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.6&lt;/version&gt;&lt;/dependency&gt; 3 . 然后就可以尽情在自己项目里面编写简略风格的Java代码咯 123456789101112131415161718192021222324252627282930package com.lombok; import lombok.Data; import lombok.EqualsAndHashCode; import java.util.List; /** * Created by Hinsteny on 2016/1/3. */ @Data @EqualsAndHashCode(callSuper = false) public class Student &#123; String name; int sex; Integer age; String address; List&lt;String&gt; books; &#125; //使用Student类对象 Student student = new Student(); student.setName(name); student.setAge(age); student.setAddress(address); student.setBooks(Arrays.asList(books));]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑小技巧]]></title>
    <url>%2F2017%2F01%2F30%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BC%80%E5%8F%91css3%E5%8A%A8%E7%94%BB-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[程序员开发 css3 动画-实现自己的代码库1.前言 在月初的时候，发了 CSS3 热身实战–过渡与动画（实现炫酷下拉，手风琴，无缝滚动）。js 的代码库也发过两次，两篇文章。之前也写了 css3 的热身实战，既然热身完了，是时候开始封装 css3 的代码库了，相比起 js 的代码库，css3 的代码库的逻辑性就更加简单了！可以说只要打上注释和一张效果图就可以让大家明白了其中的原理了！ 我写代码库的时候，动画效果主要是参考了三个开源项目，nec，hover.css，animate.css 这三个项目的质量非常的高，建议大家去了解。 声明 1.下面将会看到很多个 类似这样的举行，都是 span 标签，样式都是给出的 css 1span&#123; cursor: pointer; height: 40px; line-height: 40px; text-align: center; display: inline-block; color: #333; background: #ccc; min-width: 80px; padding: 0 10px; margin: 10px; 2.关于 class 命名方式，l 代表 left，r 代表 right，t 代表 top，b 代表 bottom，c 代表 center，m 代表 middle。切记 文章比较长，但是说得就是两点，大家看得也应该会很快 1.写出一些 hover 动画和预设动画的运行效果，并且贴出代码 2.发现几个动画组合，和加上无限动画，反向动画，会有不一样的效果，并且继续研究，看下能不能研究出不一样的东西！ 2.hover 动画 说了那么多，是时候进入正文了， 首先是 hover 动画，关于这个概念，我解释下，就是鼠标移上去触发的动画，就是触发了鼠标的 hover 事件时能看到的动画！下面，按照类型，一个一个的写！ 2-1.简单动画 2-1-1 大小变化 html 1&lt;span class="ech-big"&gt;big&lt;/span&gt;&lt;span class="ech-small"&gt;small&lt;/span&gt; css 1.ech-big,.ech-small &#123; transition: all .4s; 2-1-2 形状变化 html 1&lt;span class="ech-skew-l"&gt;skew-l&lt;/span&gt;&lt;span class="ech-skew-r"&gt;skew-r&lt;/span&gt;&lt;span class="ech-skew-l-t"&gt;skew-l-t&lt;/span&gt;&lt;span class="ech-skew-r-t"&gt;skew-r-t&lt;/span&gt;&lt;span class="ech-skew-l-b"&gt;skew-l-b&lt;/span&gt;&lt;span class="ech-skew-r-b"&gt;skew-r-b&lt;/span&gt; css 1.ech-skew-l, .ech-skew-r, .ech-skew-l-t, .ech-skew-r-b, .ech-skew-l-b, .ech-skew-r-t&#123; transition: all .4s; 2-1-3 旋转角度变化 html 1&lt;span class=&quot;ech-grow-rotate-l&quot;&gt;grow-rotate-l&lt;/span&gt;&lt;span class=&quot;ech-grow-rotate-r&quot;&gt;grow-rotate-r&lt;/span&gt;&lt;span class=&quot;ech-rotate5&quot;&gt;rotate5&lt;/span&gt;&lt;span class=&quot;ech-rotate15&quot;&gt;rotate15&lt;/span&gt;&lt;span class=&quot;ech-rotate30&quot;&gt;rotate30&lt;/span&gt;&lt;span class=&quot;ech-rotate60&quot;&gt;rotate60&lt;/span&gt;&lt;span class=&quot;ech-rotate90&quot;&gt;rotate90&lt;/span&gt;&lt;span class=&quot;ech-rotate180&quot;&gt;rotate180&lt;/span&gt;&lt;span class=&quot;ech-rotate360&quot;&gt;rotate360&lt;/span&gt;&lt;span class=&quot;ech-rotate-5&quot;&gt;rotate-5&lt;/span&gt;&lt;span class=&quot;ech-rotate-15&quot;&gt;rotate-15&lt;/span&gt;&lt;span class=&quot;ech-rotate-30&quot;&gt;rotate-30&lt;/span&gt;&lt;span class=&quot;ech-rotate-60&quot;&gt;rotate-60&lt;/span&gt;&lt;span class=&quot;ech-rotate-90&quot;&gt;rotate-90&lt;/span&gt;&lt;span class=&quot;ech-rotate-180&quot;&gt;rotate-180&lt;/span&gt; css 1.ech-grow-rotate-l,.ech-grow-rotate-r, .ech-rotate5, .ech-rotate15, .ech-rotate30, .ech-rotate60, .ech-rotate90, .ech-rotate180, .ech-rotate360, .ech-rotate-5,.ech-rotate-15, .ech-rotate-30, .ech-rotate-60, .ech-rotate-90, .ech-rotate-180&#123;transition: all .4s; 2-1-4 位移变化 html 1&lt;span class="ech-t"&gt;up&lt;/span&gt; css 1.ech-t,.ech-bottom,.ech-top,.ech-right&#123; transition: all .4s; 2-1-5 边框变化 html 1&lt;span class="ech-border"&gt;border&lt;/span&gt; css 1.ech-border,.ech-border-in&#123; transition: all .4s; 2-1-6 阴影变化 (gif 图看得效果太难看了，大家可以去 github 下载看) html 1&lt;span class="ech-shadow"&gt;shadow&lt;/span&gt; css 1.ech-shadow,.ech-shadow-in,.ech-shadow-write,.ech-shadow-big&#123; transition: all .4s; 2-1-7 透明度变化 html 1&lt;span class="ech-fade-out"&gt;fade-out&lt;/span&gt; css 1.ech-fade-out,.ech-fade-in&#123; transition: all .4s; 2-1-8 圆角变化 html 1&lt;span class="ech-rectangle"&gt;rectangle&lt;/span&gt;&lt;span class="ech-radius"&gt;radius&lt;/span&gt; css 1.ech-radius,.ech-rectangle&#123; transition: all .4s; 2-2.颜色动画效果 这部分的动画主要是利用:before 和:after 进行实现的，所以，大家如果使用的时候，切记:before 和:after 没有被占用，否则会显示不正常 2-2-1.颜色块变化 因为这块内容很像，我就一大块一起说，大家看代码的时候要留神注意。看代码看不明白，直接在 github 下载，然后运行文件，边调试边看效果！这样大家就很容易明白了！ html 1&lt;span class="ech-fade"&gt;fade&lt;/span&gt; css 1/*当前元素设置相对定位*/.ech-fade, .ech-fade-t, .ech-fade-b, .ech-fade-l, .ech-fade-r, .ech-fade-c-in, .ech-fade-m-in, .ech-fade-m-out, .ech-fade-c-out, .ech-bounce-t, .ech-bounce-b, .ech-bounce-r, .ech-bounce-l &#123; position: relative; transition: all .3s; z-index: 1; 2-2-2.颜色上下划线变化 这里也是一大块一起说，看代码可能会更乱，所以大家看代码的时候要更加留神注意。看代码看不明白，直接在 github 下载，然后运行文件，边调试边看效果！这样大家就很容易明白了！ html 1&lt;span class="ech-overline-l"&gt;overline-l&lt;/span&gt; css 1/*上划线和下划线变化 当前元素样式设置相对定位*/.ech-overline-r, .ech-overline-l, .ech-underline-r, .ech-underline-l, .ech-underline-c, .ech-overline-c, .ech-underline-c-out, .ech-overline-c-out&#123; position: relative; transition: all .3s; z-index: 1; 2-2-3 箭头动画 html 1&lt;span class=&quot;ech-arrow-l&quot;&gt;arrow-l&lt;/span&gt;&lt;span class=&quot;ech-arrow-r&quot;&gt;arrow-r&lt;/span&gt;&lt;span class=&quot;ech-arrow-t&quot;&gt;arrow-t&lt;/span&gt;&lt;span class=&quot;ech-arrow-b&quot;&gt;arrow-b&lt;/span&gt;&lt;span class=&quot;ech-arrow-l-move&quot;&gt;arrow-l&lt;/span&gt;&lt;span class=&quot;ech-arrow-r-move&quot;&gt;arrow-r&lt;/span&gt;&lt;span class=&quot;ech-arrow-t-move&quot;&gt;arrow-t&lt;/span&gt;&lt;span class=&quot;ech-arrow-b-move&quot;&gt;arrow-b&lt;/span&gt; css 1.ech-arrow-l, .ech-arrow-r, .ech-arrow-t, .ech-arrow-b, .ech-arrow-l-move, .ech-arrow-r-move, .ech-arrow-t-move, .ech-arrow-b-move&#123; position: relative; transition: all .3s; z-index: 1; 2-3 较复杂动画 2-1 和 2-2 的内容，都是利用过渡实现效果，那么这一块就是利用动画来实现效果！区别就是 hover 的写法是增加一个动画，动画的封装，难度就在于创意。 2-3-1 闪烁效果 html 1&lt;span class=&quot;ech-flash&quot;&gt;flash&lt;/span&gt; css 1.ech-flash:hover &#123; animation: flash .5s ease; 2-3-2 闹钟振铃效果 html 1&lt;span class=&quot;ech-shake-time&quot;&gt;shake-time&lt;/span&gt; css 1/*仿闹钟振铃效果*/.ech-shake-time:hover &#123; animation: shake-time 1s ease; 2-3-3 摇摆效果 html 1&lt;span class=&quot;ech-wobble-c&quot;&gt;wobble-c&lt;/span&gt;&lt;span class=&quot;ech-wobble-t&quot;&gt;wobble-t&lt;/span&gt;&lt;span class=&quot;ech-wobble-b&quot;&gt;wobble-b&lt;/span&gt; css 1.ech-wobble-t, .ech-skew-r-t, .ech-skew-l-t &#123; transform-origin: 0 100%; 2-3-4 摇晃效果 html 1&lt;span class=&quot;ech-swing&quot;&gt;swing&lt;/span&gt; css 1.ech-swing:hover &#123; animation: swing .5s ease alternate; 2-3-5 抖动效果 html 1&lt;span class=&quot;ech-shake&quot;&gt;shake&lt;/span&gt; css 1.ech-shake:hover &#123; animation: shake .5s ease; 2-3-6 弹跳效果 html 1&lt;span class=&quot;ech-bounce&quot;&gt;bounce&lt;/span&gt; css 1.ech-bounce:hover &#123; animation: bounce 1s ease; 3.预设动画 受限于篇幅的长度，我也不想分开两篇文章写。关于这个预设动画，我就简单的说一下，写一下，我直接给一个大概的操作演示，和完整的代码！反正写法这个也是比较单一，无非就是改一个类名而已。难的是动画的一些编写，这个需要创意，大家可以上网参考。 （不知道为什么，gif 截大图放不上来，就放了张小的，大家结果下面的 jpg 一起看把，就是通过下面的按钮，展示动画，大家也可以在 github 下面下载代码看下） （完整代码比较多，这里贴出，但是建议大家稍微看一下，过一下就好，因为这个只看代码是会懵逼的，要在浏览器打开文件，一看调试一边看，这样会很简单，很容易的明白） html 代码 代码过长需要文档版源码来我的前端群 657137906，源码已经上传了！ css 代码过长需要文档版源码来我的前端群 657137906，源码已经上传了！ 4.未知探索 好了，说完了 hover 动画和预设动画，我开发的时候，发现了这样一些好玩的东西，我也准备继续研究，也建议大家玩下，说不定哪天做出了了不起的东西！如下面的栗子！ 下面说的动画，不分 hover 动画和预设动画，大家注意 4-1.无限执行动画 一个普通的动画，加上无限执行，一般会出现很友好的效果， 但是有些时候的效果差强人意 4-2.反向动画 在 4-1 的基础上，加上方向执行动画，也会有不一样的效果 没加反向动画效果 加上反向动画效果 4-3.组合效果 阴影效果和其它效果的组合，(gif 看不出阴影效果，哎。。) 上面的几个的栗子 css 代码不变，区别是 html 代码，多加了一些类名 上面几个是我在开发时候发现的栗子，这个我会继续研究，也希望大家能研究，研究出什么好玩的效果，或者动画写法，欢迎分享！ 5.鸡肋选择 在写 css3 代码库的时候，我也发现封装 css3 的一个鸡肋情况。 1.css3 的效果太过于灵活，多样，封装非常容易出现众口难调的情况，以及每个项目的效果可能出现效果差不多，但就是不一样，这样就是说封装的库并不适合用在项目上。 2.还有一点在于，css3 效果基本上每一个项目都是有用到，并且是常用，但是平常项目要用到的 css3 效果最多也就 10 个，而且也不难，手写很快可以实现，根本没必要去引一个插件或者库。 但是最后我还是坚持写下去了，原因如下 1.如果项目开发，对动画效果的要求基本不会达到非常的严格的地步，我完全可以多引一个文件，增加我的开发效率，压缩过后的文件可能只有 10K 左右，可以接受。 2.就算在项目用不上，我也可以当作是练手，学习的作用。如果以后项目需要动画效果，即使动画效果跟我封装的不一样，我也可以看着来进行修改。 3.就算开发的时候没使用上这个库，万一有些动画，我写过，但是忘了怎么写，也可以回头看怎么实现！ 4.如果开发的时候，不知道放什么效果好，这个库，也能起到一定的参考作用！ 5.现在多写几个，说不定起到一个发散思维的作用，写了这些效果，想到了另一些效果怎么写，或者想到还有什么效果可以写，这个也是非常好的一个结果和收获！ 6.小结 好了，css3 的代码库封装到这里就差不多了，如果你能看完全篇，你已经是勇士了，证明你很有耐心，看完马上掌握，这个对于大家来说问题不大，毕竟不是什么逻辑性强的代码。我想要的效果虽然都实现了，不过以后肯定也是要修改完善的(至少看源码的话，我自己看得都有点乱，但是一时之间又不知道该如果整理，就先放上去了)。话说回来，通过以上的案例，希望能帮到大家，最理想就是能起到发散思维的作用，就是通过我的案例，能让大家知道其它的一些动画怎么做，或者想到有什么好看动画效果。web 前端这一行，最重要的就是多练，大家除了看别人的项目，博客之外，一定要多练，多写，这样进步才会更快，知识才会记得更牢。 如果想看到更加系统的文章和学习方法经验可以关注我的微信公众号：‘前端根据地’关注后回复‘给我资料’可以领取一套完整的学习视频]]></content>
      <categories>
        <category>工具</category>
        <category>css</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Windows</tag>
        <tag>Config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源工具]]></title>
    <url>%2F2016%2F12%2F27%2F2016%20%E5%B9%B4%E5%BA%A6%E9%A1%B6%E7%BA%A7%E5%BC%80%E6%BA%90%E5%88%9B%E4%BD%9C%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[2016 年度顶级开源创作工具标签：开源 2016 年度顶级开源创作工具原创 Linux 中国 2017-04-23 19:17:46 无论你是想修改图片、编译音频，还是制作动画，这里的自由而开源的工具都能帮你做到。 – Máirín Duffy 本文导航 -核心应用 …… 02% -GIMP …… 09% -Inkscape …… 16% -Scribus …… 24% -MyPaint …… 29% -Blender …… 34% -Krita …… 41% -视频处理工具 …… 45% -Kdenlive …… 48% -Flowblade …… 51% -Pitivi …… 52% -Shotcut …… 55% -OpenShot Video Editor …… 57% -其它工具 …… 59% -SwatchBooker …… 59% -GNOME Color Manager …… 61% -GNOME Wacom Control …… 63% -Xournal …… 64% -PDF Mod …… 66% -SparkleShare …… 67% -摄影 …… 69% -Darktable …… 69% -Entangle …… 71% -Hugin …… 72% -2D 动画 …… 73% -Synfig Studio …… 73% -Blender Grease Pencil …… 75% -Krita …… 76% -音频编辑 …… 77% -Audacity …… 77% -Ardour …… 78% -Hydrogen …… 79% -Mixxx …… 80% -Rosegarden …… 81% -MuseScore …… 83% -其它具有创造力的工具 …… 84% -MakeHuman …… 84% -Natron …… 85% -FontForge …… 86% -Valentina …… 87% -Calligra Flow …… 87% -资源 …… 88% 编译自： https://opensource.com/article/16/12/yearbook-top-open-source-creative-tools-2016 作者： Máirín Duffy 译者： GitFuture 无论你是想修改图片、编译音频，还是制作动画，这里的自由而开源的工具都能帮你做到。 几年前，我在 Red Hat 总结会上做了一个简单的演讲，给与会者展示了 2012 年度开源创作工具[1]。开源软件在过去几年里发展迅速，现在我们来看看 2016 年的相关领域的软件。 核心应用这六款应用是开源的设计软件中的最强王者。它们做的很棒，拥有完善的功能特征集、稳定发行版以及活跃的开发者社区，是很成熟的项目。这六款应用都是跨平台的，每一个都能在 Linux、OS X 和 Windows 上使用，不过大多数情况下 Linux 版本一般都是最先更新的。这些应用广为人知，我已经把最新特性的重要部分写进来了，如果你不是非常了解它们的开发情况，你有可能会忽视这些特性。 如果你想要对这些软件做更深层次的了解，或许你可以帮助测试这四个软件 —— GIMP、Inkscape、Scribus，以及 MyPaint 的最新版本，在 Linux 机器上你可以用 Flatpak[2] 软件轻松地安装它们。这些应用的每日构建版本可以按照指令[3] 通过 Flatpak 的“每日构建的绘图应用（Nightly Graphics Apps）”得到。有一件事要注意：如果你要给每个应用的 Flatpak 版本安装笔刷或者其它扩展，用于移除这些扩展的目录将会位于相应应用的目录 ~/.var/app 下。 GIMPGIMP[4] 在 2015 年迎来了它的 20 周岁[5]，使得它成为这里资历最久的开源创造型应用之一。GIMP 是一款强大的应用，可以处理图片，创作简单的绘画，以及插图。你可以通过简单的任务来尝试 GIMP，比如裁剪、缩放图片，然后循序渐进使用它的其它功能。GIMP 可以在 Linux、Mac OS X 以及 Windows 上使用，是一款跨平台的应用，而且能够打开、导出一系列格式的文件，包括在与之相似的软件 Photoshop 上广为应用的那些格式。 GIMP 开发团队正在忙着 2.10 发行版的工作；2.8.18[6] 是最新的稳定版本。更振奋人心的是非稳定版，2.9.4[7]，拥有全新的用户界面，旨在节省空间的符号式图标和黑色主题，改进了颜色管理，更多的基于 GEGL 的支持分离预览的过滤器，支持 MyPaint 笔刷（如下图所示），对称绘图，以及命令行批次处理。想了解更多信息，请关注 完整的发行版注记[8]。 GIMP 截图 InkscapeInkscape[9] 是一款富有特色的矢量绘图设计软件。可以用它来创作简单的图形、图表、布局或者图标。 最新的稳定版是 0.91[10] 版本；与 GIMP 相似，能在预发布版 0.92pre3 版本中找到更多有趣的东西，其发布于 2016 年 11 月。最新推出的预发布版的突出特点是梯度网格特性 gradient mesh feature[11]（如下图所示）；0.91 发行版里介绍的新特性包括：强力笔触（power stroke）[12] 用于完全可配置的书法笔画（下图的 “opensource.com” 中的 “open” 用的就是强力笔触技术），画布测量工具，以及 全新的符号对话框[13]（如下图右侧所示）。（很多符号库可以从 GitHub 上获得；Xaviju’s inkscape-open-symbols set[14] 就很不错。）对象对话框是在改进版或每日构建中可用的新特性，整合了一个文档中的所有对象，提供工具来管理这些对象。 Inkscape 截图 ScribusScribus[15] 是一款强大的桌面出版和页面布局工具。Scribus 让你能够创造精致美丽的物品，包括信封、书籍、杂志以及其它印刷品。Scribus 的颜色管理工具可以处理和输出 CMYK 格式，还能给文件配色，可靠地用于印刷车间的重印。 1.4.6[16] 是 Scribus 的最新稳定版本；1.5.x[17] 系列的发行版更令人期待，因为它们是即将到来的 1.6.0 发行版的预览。1.5.3 版本包含了 Krita 文件（*.KRA）导入工具； 1.5.x 系列中其它的改进包括了表格工具、文本框对齐、脚注、导出可选 PDF 格式、改进的字典、可驻留边框的调色盘、符号工具，和丰富的文件格式支持。 Scribus 截图 MyPaintMyPaint[18] 是一款用于数位屏的快速绘图和插画工具。它很轻巧，界面虽小，但快捷键丰富，因此你能够不用放下数位笔而专心于绘图。 MyPaint 1.2.0[19] 是其最新的稳定版本，包含了一些新特性，诸如 直观上墨工具[20] 用来跟踪铅笔绘图的轨迹，新的填充工具，层分组，笔刷和颜色的历史面板，用户界面的改进包括暗色主题和小型符号图标，以及可编辑的矢量层。想要尝试 MyPaint 里的最新改进，我建议安装每日构建版的 Flatpak 构建，尽管自从 1.2.0 版本没有添加重要的特性。 MyPaint 截图 BlenderBlender[21] 最初发布于 1995 年 1 月，像 GIMP 一样，已经有 20 多年的历史了。Blender 是一款功能强大的开源 3D 制作套件，包含建模、雕刻、渲染、真实材质、套索、动画、影像合成、视频编辑、游戏创作以及模拟。 Blender 最新的稳定版是 2.78a[22]。2.78 版本很庞大，包含的特性有：改进的 2D 蜡笔 Grease Pencil 动画工具；针对球面立体图片的 VR 渲染支持；以及新的手绘曲线的绘图工具。 Inkscape 截图 要尝试最新的 Blender 开发工具，有很多种选择，包括： Blender 基金会在官方网址提供 非稳定版的每日构建版[23]。 如果你在寻找特殊的开发中特性，graphicall.org[24] 是一个适合社区的网站，能够提供特殊版本的 Blender（偶尔还有其它的创造型开源应用），让艺术家能够尝试体验最新的代码。 Mathieu Bridon 通过 Flatpak 做了 Blender 的一个开发版本。查看它的博客以了解详情：Flatpak 上每日构建版的 Blender[25] KritaKrita[26] 是一款拥有强大功能的数字绘图应用。这款应用贴合插画师、印象艺术家以及漫画家的需求，有很多附件，比如笔刷、调色板、图案以及模版。 最新的稳定版是 Krita 3.0.1[27]，于 2016 年 9 月发布。3.0.x 系列的新特性包括 2D 逐帧动画；改进的层管理器和功能；丰富的常用快捷键；改进了网格、向导和图形捕捉；还有软打样。 Krita 截图 视频处理工具关于开源的视频编辑工具则有很多很多。这这些工具之中，Flowblade[28] 是新推出的，而 Kdenlive 则是构建完善、对新手友好、功能最全的竞争者。对你排除某些备选品有所帮助的主要标准是它们所支持的平台，其中一些只支持 Linux 平台。它们的软件上游都很活跃，最新的稳定版都于近期发布，发布时间相差不到一周。 KdenliveKdenlive[29]，最初于 2002 年发布，是一款强大的非线性视频编辑器，有 Linux 和 OS X 版本（但是 OS X 版本已经过时了）。Kdenlive 有用户友好的、基于拖拽的用户界面，适合初学者，又有专业人员需要的深层次功能。 可以看看 Seth Kenlon 写的 Kdenlive 系列教程[30]，了解如何使用 Kdenlive。 最新稳定版: 16.08.2 (2016 年 10 月) Flowblade2012 年发布, Flowblade[31]，只有 Linux 版本的视频编辑器，是个相当不错的后起之秀。 最新稳定版: 1.8 (2016 年 9 月) PitiviPitivi[32] 是用户友好型的自由开源视频编辑器。Pitivi 是用 Python[33] 编写的（“Pitivi” 中的 “Pi”来源于此），使用了 GStreamer[34] 多媒体框架，社区活跃。 最新稳定版: 0.97 (2016 年 8 月) 通过 Flatpak 获取 最新版本[35] ShotcutShotcut[36] 是一款自由开源的跨平台视频编辑器，早在 2004 年就发布了，之后由现在的主要开发者 Dan Dennedy[37] 重写。 最新稳定版: 16.11 (2016 年 11 月) 支持 4K 分辨率 仅以 tar 包方式发布 OpenShot Video Editor始于 2008 年，OpenShot Video Editor[38] 是一款自由、开源、易于使用、跨平台的视频编辑器。 最新稳定版: 2.1[39] (2016 年 8 月) 其它工具SwatchBookerSwatchBooker[40] 是一款很方便的工具，尽管它近几年都没有更新了，但它还是很有用。SwatchBooler 能帮助用户从各大制造商那里合法地获取色卡，你可以用其它自由开源的工具处理它导出的格式，包括 Scribus。 GNOME Color ManagerGNOME Color Manager[41] 是 GNOME 桌面环境内建的颜色管理器，而 GNOME 是某些 Linux 发行版的默认桌面。这个工具让你能够用色度计为自己的显示设备创建属性文件，还可以为这些设备加载/管理 ICC 颜色属性文件。 GNOME Wacom ControlThe GNOME Wacom controls[42] 允许你在 GNOME 桌面环境中配置自己的 Wacom 手写板；你可以修改手写板交互的很多选项，包括自定义手写板灵敏度，以及手写板映射到哪块屏幕上。 XournalXournal[43] 是一款简单但可靠的应用，可以让你通过手写板手写或者在笔记上涂鸦。Xournal 是一款有用的工具，可以让你签名或注解 PDF 文档。 PDF ModPDF Mod[44] 是一款编辑 PDF 文件很方便的工具。PDF Mod 让用户可以移除页面、添加页面，将多个 PDF 文档合并成一个单独的 PDF 文件，重新排列页面，旋转页面等。 SparkleShareSparkleShare[45] 是一款基于 git 的文件分享工具，艺术家用来协作和分享资源。它会挂载在 GitLab 仓库上，你能够采用一个精妙的开源架构来进行资源管理。SparkleShare 的前端通过在顶部提供一个类似下拉框界面，避免了使用 git 的复杂性。 摄影DarktableDarktable[46] 是一款能让你开发数位 RAW 文件的应用，有一系列工具，可以管理工作流、无损编辑图片。Darktable 支持许多流行的相机和镜头。 改变颜色平衡度的图片 EntangleEntangle[47] 允许你将数字相机连接到电脑上，让你能从电脑上完全控制相机。 HuginHugin[48] 是一款工具，让你可以拼接照片，从而制作全景照片。 2D 动画Synfig StudioSynfig Studio[49] 是基于矢量的二维动画套件，支持位图原图，在平板上用起来方便。 Blender Grease Pencil我在前面讲过了 Blender，但值得注意的是，最近的发行版里重构的蜡笔特性[50]，添加了创作二维动画的功能。 KritaKrita[51] 现在同样提供了二维动画功能。 音频编辑AudacityAudacity[52] 在编辑音频文件、记录声音方面很有名，是用户友好型的工具。 ArdourArdour[53] 是一款数字音频工作软件，界面中间是录音，编辑和混音工作流。使用上它比 Audacity 要稍微难一点，但它允许自动操作，并且更高端。（有 Linux、Mac OS X 和 Windows 版本） HydrogenHydrogen[54] 是一款开源的电子鼓，界面直观。它可以用合成的乐器创作、整理各种乐谱。 MixxxMixxx[55] 是四仓 DJ 套件，让你能够以强大操控来 DJ 和混音歌曲，包含节拍循环、时间延长、音高变化，还可以用 DJ 硬件控制器直播混音和衔接。 RosegardenRosegarden[56] 是一款作曲软件，有乐谱编写和音乐作曲或编辑的功能，提供音频和 MIDI 音序器。（LCTT 译注：MIDI 即 Musical Instrument Digital Interface 乐器数字接口） MuseScoreMuseScore[57] 是乐谱创作、记谱和编辑的软件，它还有个乐谱贡献者社区。 其它具有创造力的工具MakeHumanMakeHuman[58] 是一款三维绘图工具，可以创造人型的真实模型。 NatronNatron[59] 是基于节点的合成工具，用于视频后期制作、动态图象和设计特效。 FontForgeFontForge[60] 是创作和编辑字体的工具。允许你编辑某个字体中的字形，也能够使用这些字形生成字体。 ValentinaValentina[61] 是用来设计缝纫图案的应用。 Calligra FlowCalligra Flow[62] 是一款图表工具，类似 Visio（有 Linux，Mac OS X 和 Windows 版本）。 资源这里有很多小玩意和彩蛋值得尝试。需要一点灵感来探索？这些网站和论坛有很多教程和精美的成品能够激发你开始创作： 1、 pixls.us[63]： 摄影师 Pat David 管理的博客，他专注于专业摄影师使用的自由开源的软件和工作流。 2、 David Revoy ‘s Blog[64]： David Revoy 的博客，热爱自由开源，非常有天赋的插画师，概念派画师和开源倡议者，对 Blender 基金会电影有很大贡献。 3、 The Open Source Creative Podcast[65]: 由 Opensource.com 社区版主和专栏作家 Jason van Gumster[66] 管理，他是 Blender 和 GIMP 的专家， 《Blender for Dummies》[67] 的作者，该文章正好是面向我们这些热爱开源创作工具和这些工具周边的文化的人。 4、 Libre Graphics Meeting[68]: 自由开源创作软件的开发者和使用这些软件的创作者的年度会议。这是个好地方，你可以通过它找到你喜爱的开源创作软件将会推出哪些有意思的特性，还可以了解到这些软件的用户用它们在做什么。 作者简介： Máirín Duffy - Máirín 是 Red Hat 的首席交互设计师。她热衷于自由软件和开源工具，尤其是在创作领域：她最喜欢的应用是 Inkscape[69]。 （题图： pixabay[70]，CC0） via: https://opensource.com/article/16/12/yearbook-top-open-source-creative-tools-2016 作者：Máirín Duffy[71] 译者：GitFuture 校对：wxy 本文由 LCTT 原创编译，Linux 中国 荣誉推出 [1]: 2012 年度开源创作工具 - https://opensource.com/life/12/9/tour-through-open-source-creative-tools [2]: Flatpak - https://opensource.com/business/16/8/flatpak [3]: 按照指令 - http://flatpak.org/apps.html [4]: GIMP - https://opensource.com/tags/gimp [5]: 在 2015 年迎来了它的 20 周岁 - https://linux.cn/article-7131-1.html [6]: 2.8.18 - https://www.gimp.org/news/2016/07/14/gimp-2-8-18-released/ [7]: 2.9.4 - https://www.gimp.org/news/2016/07/13/gimp-2-9-4-released/ [8]: 完整的发行版注记 - https://www.gimp.org/news/2016/07/13/gimp-2-9-4-released/ [9]: Inkscape - https://opensource.com/tags/inkscape [10]: 0.91 - http://wiki.inkscape.org/wiki/index.php/Release_notes/0.91 [11]: 梯度网格特性 - http://wiki.inkscape.org/wiki/index.php/Mesh_Gradients [12]: 强力笔触（power stroke） - https://www.youtube.com/watch?v=IztyV-Dy4CE [13]: 全新的符号对话框 - https://inkscape.org/cs/%7Edoctormo/%E2%98%85symbols-dialog [14]: Xaviju’s inkscape-open-symbols set - https://github.com/Xaviju/inkscape-open-symbols [15]: Scribus - https://opensource.com/tags/scribus [16]: 1.4.6 - https://www.scribus.net/scribus-1-4-6-released/ [17]: 1.5.x - https://www.scribus.net/scribus-1-5-2-released/ [18]: MyPaint - http://mypaint.org/ [19]: MyPaint 1.2.0 - http://mypaint.org/blog/2016/01/15/mypaint-1.2.0-released/ [20]: 直观上墨工具 - https://github.com/mypaint/mypaint/wiki/v1.2-Inking-Tool [21]: Blender - https://opensource.com/tags/blender [22]: 2.78a - http://www.blender.org/features/2-78/ [23]: 非稳定版的每日构建版 - https://builder.blender.org/download/ [24]: graphicall.org - http://graphicall.org/ [25]: Flatpak 上每日构建版的 Blender - https://mathieu.daitauha.fr/blog/2016/09/23/blender-nightly-in-flatpak/ [26]: Krita - https://opensource.com/tags/krita [27]: Krita 3.0.1 - https://krita.org/en/item/krita-3-0-1-update-brings-numerous-fixes/ [28]: Flowblade - https://opensource.com/life/16/9/10-reasons-flowblade-linux-video-editor [29]: Kdenlive - https://opensource.com/tags/kdenlive [30]: Kdenlive 系列教程 - https://opensource.com/life/11/11/introduction-kdenlive [31]: Flowblade - http://jliljebl.github.io/flowblade/ [32]: Pitivi - http://pitivi.org/ [33]: Python - http://wiki.pitivi.org/wiki/Why_Python%3F [34]: GStreamer - https://gstreamer.freedesktop.org/ [35]: 最新版本 - https://pitivi.wordpress.com/2016/07/18/get-pitivi-directly-from-us-with-flatpak/ [36]: Shotcut - http://shotcut.org/ [37]: Dan Dennedy - http://www.dennedy.org/ [38]: OpenShot Video Editor - http://openshot.org/ [39]: 2.1 - http://www.openshotvideo.com/2016/08/openshot-21-released.html [40]: SwatchBooker - http://www.selapa.net/swatchbooker/ [41]: GNOME Color Manager - https://help.gnome.org/users/gnome-help/stable/color.html.en [42]: The GNOME Wacom controls - https://help.gnome.org/users/gnome-help/stable/wacom.html.en [43]: Xournal - http://xournal.sourceforge.net/ [44]: PDF Mod - https://wiki.gnome.org/Apps/PdfMod [45]: SparkleShare - https://www.sparkleshare.org/ [46]: Darktable - https://opensource.com/life/16/4/how-use-darktable-digital-darkroom [47]: Entangle - https://entangle-photo.org/ [48]: Hugin - http://hugin.sourceforge.net/ [49]: Synfig Studio - https://opensource.com/article/16/12/synfig-studio-animation-software-tutorial [50]: 重构的蜡笔特性 - https://wiki.blender.org/index.php/Dev:Ref/Release_Notes/2.78/GPencil [51]: Krita - https://opensource.com/tags/krita [52]: Audacity - https://opensource.com/tags/audacity [53]: Ardour - https://ardour.org/ [54]: Hydrogen - http://www.hydrogen-music.org/ [55]: Mixxx - http://mixxx.org/ [56]: Rosegarden - http://www.rosegardenmusic.com/ [57]: MuseScore - https://opensource.com/life/16/03/musescore-tutorial [58]: MakeHuman - http://makehuman.org/ [59]: Natron - https://natron.fr/ [60]: FontForge - http://fontforge.github.io/en-US/ [61]: Valentina - http://valentina-project.org/ [62]: Calligra Flow - https://www.calligra.org/flow/ [63]: pixls.us - http://pixls.us/ [64]: David Revoy ‘s Blog - http://davidrevoy.com/ [65]: The Open Source Creative Podcast - http://monsterjavaguns.com/podcast/ [66]: Jason van Gumster - https://opensource.com/users/jason-van-gumster [67]: 《Blender for Dummies》 - http://www.blenderbasics.com/ [68]: Libre Graphics Meeting - http://libregraphicsmeeting.org/2016/ [69]: Inkscape - http://inkscape.org [70]: pixabay - https://pixabay.com [71]: Máirín Duffy - https://opensource.com/users/mairin]]></content>
      <categories>
        <category>开源</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>开源</tag>
      </tags>
  </entry>
</search>
